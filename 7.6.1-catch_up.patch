diff --git a/CMakeLists.txt b/CMakeLists.txt
index e6435f5..30ba726 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -29,7 +29,7 @@ set(PACKAGE "condor")
 #   Condor and other systems parse this number. Keep it simple:
 #   Number.Number.Number. Do nothing else.  If you need to add
 #   more information, PRE_RELEASE is usually the right location.
-set(VERSION "7.6.0")
+set(VERSION "7.6.1")
 
 # Set PRE_RELEASE to either a string (i.e. "PRE-RELEASE-UWCS") or OFF
 #   This shuld be "PRE-RELEASE-UWCS most of the time, and OFF when
@@ -90,15 +90,16 @@ include (CondorStaticLib)
 include (CondorPlugin)
 include (CheckCXXCompilerFlag)
 include (CheckCXXSourceCompiles)
-include (CondorConfigure)     # will initiate the configure
 include (AddSubdirectories)
 include (CondorPLTest)
 include (CondorExeTest)
 include (CondorStdExeTest)
 include (SrcTargetRef)
 include (DumpLocalFlags)
+include (CondorConfigure)     # will initiate the configure
 include (TarGz) # Must be after include(CondorPackageConfig)
 
+
 if ( WINDOWS )
 	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
 endif ( WINDOWS )
diff --git a/build/cmake/CondorConfigure.cmake b/build/cmake/CondorConfigure.cmake
index ad69e0c..7cd2fcb 100644
--- a/build/cmake/CondorConfigure.cmake
+++ b/build/cmake/CondorConfigure.cmake
@@ -128,7 +128,15 @@ if( NOT WINDOWS)
 
 	set(HAVE_PTHREAD_H ${CMAKE_HAVE_PTHREAD_H})
 
-	find_library(HAVE_DMTCP dmtcpaware HINTS /usr/local/lib/dmtcp )
+	find_library( HAVE_DMTCP dmtcpaware HINTS /usr/local/lib/dmtcp )
+	find_library( LIBRESOLV_PATH resolv )
+    if( NOT "${LIBRESOLV_PATH}" MATCHES "-NOTFOUND" )
+      set(HAVE_LIBRESOLV ON)
+    endif()
+	find_library( LIBDL_PATH resolv )
+    if( NOT "${LIBDL_PATH}" MATCHES "-NOTFOUND" )
+      set(HAVE_LIBDL ON)
+    endif()
 	check_library_exists(dl dlopen "" HAVE_DLOPEN)
 	check_symbol_exists(res_init "sys/types.h;netinet/in.h;arpa/nameser.h;resolv.h" HAVE_DECL_RES_INIT)
 
@@ -198,7 +206,11 @@ if( NOT WINDOWS)
 
 	check_struct_has_member("struct statfs" f_fstyp "sys/statfs.h" HAVE_STRUCT_STATFS_F_FSTYP)
 	if (NOT ${OS_NAME} STREQUAL "DARWIN")
-		check_struct_has_member("struct statfs" f_fstypename "sys/statfs.h" HAVE_STRUCT_STATFS_F_FSTYPENAME)
+  	  if( HAVE_SYS_STATFS_H )
+		check_struct_has_member("struct statfs" f_fstypename "sys/statfs.h" HAVE_STRUCT_STATFS_F_FSTYPENAME )
+	  else()
+		check_struct_has_member("struct statfs" f_fstypename "sys/mount.h" HAVE_STRUCT_STATFS_F_FSTYPENAME )
+	  endif()
 	endif()
 	check_struct_has_member("struct statfs" f_type "sys/statfs.h" HAVE_STRUCT_STATFS_F_TYPE)
 	check_struct_has_member("struct statvfs" f_basetype "sys/types.h;sys/statvfs.h" HAVE_STRUCT_STATVFS_F_BASETYPE)
@@ -322,6 +334,10 @@ elseif(${OS_NAME} STREQUAL "HPUX")
 	set(HPUX ON)
 	set(DOES_SAVE_SIGSTATE ON)
 	set(NEEDS_64BIT_STRUCTS ON)
+elseif(${OS_NAME} STREQUAL "HPUX")
+	set(HPUX ON)
+	set(DOES_SAVE_SIGSTATE ON)
+	set(NEEDS_64BIT_STRUCTS ON)
 endif()
 
 ##################################################
@@ -338,6 +354,7 @@ option(BUILD_TESTS "Will build internal test applications" ON)
 option(WANT_CONTRIB "Enable quill functionality" OFF)
 option(WANT_FULL_DEPLOYMENT "Install condors deployment scripts, libs, and includes" ON)
 option(WANT_GLEXEC "Build and install condor glexec functionality" ON)
+option(ENABLE_JAVA_TESTS "Enable java tests" ON)
 
 if (UW_BUILD OR WINDOWS)
   option(PROPER "Try to build using native env" OFF)
@@ -466,6 +483,7 @@ if (NOT WINDOWS)
 	add_subdirectory(${CONDOR_EXTERNAL_DIR}/bundles/blahp/1.16.1)
 	add_subdirectory(${CONDOR_EXTERNAL_DIR}/bundles/voms/1.9.10_4)
 	add_subdirectory(${CONDOR_EXTERNAL_DIR}/bundles/cream/1.12.1_14)
+	add_subdirectory(${CONDOR_EXTERNAL_DIR}/bundles/wso2/2.1.0)
 
 	# the following logic if for standard universe *only*
 	if (LINUX AND NOT CLIPPED AND GLIBC_VERSION AND NOT PROPER)
@@ -669,7 +687,7 @@ else(MSVC)
 		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--warn-once -Wl,--warn-common")
 	endif(LINUX)
 
-	if(HAVE_DLOPEN AND NOT DARWIN)
+	if( HAVE_LIBDL AND NOT BSD_UNIX )
 		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -ldl")
 	endif()
 
@@ -678,7 +696,7 @@ else(MSVC)
 		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-berok -Wl,-bstatic -lstdc++ -Wl,-bdynamic -lcfg -lodm -static-libgcc")
 	endif(AIX)
 
-	if (NOT PROPER AND NOT AIX)
+	if ( NOT PROPER AND HAVE_LIBRESOLV )
 		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -lresolv")
 		if (NOT DARWIN)
 			set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -lcrypt")
@@ -818,9 +836,15 @@ dprint ( "CONDOR_PACKAGE_NAME: ${CONDOR_PACKAGE_NAME}" )
 # is TRUE on all UNIX-like OS's, including Apple OS X and CygWin
 dprint ( "UNIX: ${UNIX}" )
 
+# is TRUE on all BSD-derived UNIXen
+dprint ( "BSD_UNIX: ${BSD_UNIX}" )
+
 # is TRUE on all UNIX-like OS's, including Apple OS X and CygWin
 dprint ( "Linux: ${LINUX_NAME}" )
 
+# Print FreeBSD info
+dprint ( "FreeBSD: ${FREEBSD_MAJOR}.${FREEBSD_MINOR}" )
+
 # is TRUE on Windows, including CygWin
 dprint ( "WIN32: ${WIN32}" )
 
diff --git a/build/cmake/CondorPackageConfig.cmake b/build/cmake/CondorPackageConfig.cmake
index 57b2700..73f73a1 100644
--- a/build/cmake/CondorPackageConfig.cmake
+++ b/build/cmake/CondorPackageConfig.cmake
@@ -119,6 +119,7 @@ set( C_INCLUDE		include)
 set( C_MAN			man)
 set( C_SRC			src)
 set( C_SQL			sql)
+set( C_SERVICES     services)
 
 set( C_INIT			etc/init.d )
 set( C_ETC			etc/examples )
diff --git a/build/cmake/macros/SystemSpecificInformations.cmake b/build/cmake/macros/SystemSpecificInformations.cmake
index 125de4b..a694153 100644
--- a/build/cmake/macros/SystemSpecificInformations.cmake
+++ b/build/cmake/macros/SystemSpecificInformations.cmake
@@ -227,9 +227,41 @@ if(UNIX)
       else()
 	set(LINUX_NAME "NOT-FOUND")
       endif(LINUX_NAME)
+    endif(EXISTS "/etc/issue")
+
+  elseif(CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
+    string(REGEX MATCH "(([0-9]+)\\.([0-9]+))-RELEASE" FREEBSD "${CMAKE_SYSTEM_VERSION}")
+    set( FREEBSD_RELEASE "${CMAKE_MATCH_1}" )
+    set( FREEBSD_MAJOR "${CMAKE_MATCH_2}" )
+    set( FREEBSD_MINOR "${CMAKE_MATCH_3}" )
+    set( FREEBSD_VERSION "${CMAKE_SYSTEM_VERSION}" )
+    set( SYSTEM_NAME "freebsd_${FREEBSD_RELEASE}" )
+    set( CONDOR_FREEBSD ON )
+    set( BSD_UNIX ON )
+    if(FREEBSD_MAJOR MATCHES "4" )
+      set( CONDOR_FREEBSD4 ON )
+    elseif(FREEBSD_MAJOR MATCHES "5" )
+      set( CONDOR_FREEBSD5 ON )
+    elseif(FREEBSD_MAJOR MATCHES "6" ) 
+      set( CONDOR_FREEBSD6 ON )
+    elseif(FREEBSD_MAJOR MATCHES "7" )
+      set( CONDOR_FREEBSD7 ON )
+    elseif(FREEBSD_MAJOR MATCHES "8" )
+      set( CONDOR_FREEBSD8 ON )
+    endif()
+    if( CMAKE_SYSTEM_PROCESSOR MATCHES "amd64" )
+      set( SYS_ARCH "x86_64")
+    elseif( CMAKE_SYSTEM_PROCESSOR MATCHES "i386" )
+      set( SYS_ARCH "x86")
+    endif( )
+    set( PLATFORM "${SYS_ARCH}_freebsd_${FREEBSD_RELEASE}")
+
+  elseif(OS_NAME MATCHES "DARWIN")
+    set( BSD_UNIX ON )
 
-    endif(EXISTS "/etc/issue")      
   endif(CMAKE_SYSTEM_NAME MATCHES "Linux")
+
   set(SPECIFIC_SYSTEM_VERSION_NAME "${SPECIFIC_SYSTEM_VERSION_NAME}-${CMAKE_SYSTEM_PROCESSOR}")
   set(SPECIFIC_COMPILER_NAME "")
+
 endif(UNIX)
diff --git a/externals/bundles/blahp/1.16.1/classads.m4 b/externals/bundles/blahp/1.16.1/classads.m4
index 424536f..33608eb 100644
--- a/externals/bundles/blahp/1.16.1/classads.m4
+++ b/externals/bundles/blahp/1.16.1/classads.m4
@@ -16,7 +16,7 @@ AC_DEFUN(AC_CLASSADS,
     AC_MSG_CHECKING([for CLASSAD installation])
 
     CLASSAD_CFLAGS=""
-    CLASSAD_LIBS="-lclassad_ns -lpcre"
+    CLASSAD_LIBS="-lclassad -lpcre"
     CLASSAD_DL_LIBS="-lclassad_dl"
     if test -n "$with_classads_prefix" -a "$with_classads_prefix" != "/usr" ; then
             AC_MSG_RESULT([prefix: $with_classads_prefix])
@@ -24,7 +24,7 @@ AC_DEFUN(AC_CLASSADS,
             ac_classads_prefix=$with_classads_prefix
 
             CLASSAD_CFLAGS="-I$with_classads_prefix/include"
-            CLASSAD_LIBS="$with_classads_prefix/lib/libclassad_ns.a $with_classads_prefix/lib/libpcre.a"
+            CLASSAD_LIBS="$with_classads_prefix/lib/libclassad.a $with_classads_prefix/lib/libpcre.a"
 	    CLASSAD_DL_LIBS="-L$with_classads_prefix/lib $CLASSAD_DL_LIBS"
     fi
 
diff --git a/externals/bundles/cream/1.12.1_14/classads.m4 b/externals/bundles/cream/1.12.1_14/classads.m4
index 424536f..33608eb 100644
--- a/externals/bundles/cream/1.12.1_14/classads.m4
+++ b/externals/bundles/cream/1.12.1_14/classads.m4
@@ -16,7 +16,7 @@ AC_DEFUN(AC_CLASSADS,
     AC_MSG_CHECKING([for CLASSAD installation])
 
     CLASSAD_CFLAGS=""
-    CLASSAD_LIBS="-lclassad_ns -lpcre"
+    CLASSAD_LIBS="-lclassad -lpcre"
     CLASSAD_DL_LIBS="-lclassad_dl"
     if test -n "$with_classads_prefix" -a "$with_classads_prefix" != "/usr" ; then
             AC_MSG_RESULT([prefix: $with_classads_prefix])
@@ -24,7 +24,7 @@ AC_DEFUN(AC_CLASSADS,
             ac_classads_prefix=$with_classads_prefix
 
             CLASSAD_CFLAGS="-I$with_classads_prefix/include"
-            CLASSAD_LIBS="$with_classads_prefix/lib/libclassad_ns.a $with_classads_prefix/lib/libpcre.a"
+            CLASSAD_LIBS="$with_classads_prefix/lib/libclassad.a $with_classads_prefix/lib/libpcre.a"
 	    CLASSAD_DL_LIBS="-L$with_classads_prefix/lib $CLASSAD_DL_LIBS"
     fi
 
diff --git a/externals/bundles/wso2/2.1.0/CMakeLists.txt b/externals/bundles/wso2/2.1.0/CMakeLists.txt
new file mode 100644
index 0000000..305dfd7
--- /dev/null
+++ b/externals/bundles/wso2/2.1.0/CMakeLists.txt
@@ -0,0 +1,94 @@
+ ###############################################################
+ # 
+ # Copyright 2011 Red Hat, Inc. 
+ # 
+ # Licensed under the Apache License, Version 2.0 (the "License"); you 
+ # may not use this file except in compliance with the License.  You may 
+ # obtain a copy of the License at 
+ # 
+ #    http://www.apache.org/licenses/LICENSE-2.0 
+ # 
+ # Unless required by applicable law or agreed to in writing, software 
+ # distributed under the License is distributed on an "AS IS" BASIS, 
+ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ # See the License for the specific language governing permissions and 
+ # limitations under the License. 
+ # 
+ ############################################################### 
+if (WANT_CONTRIB AND LINUX AND PROPER)
+    option(WITH_WSO2 "Compiling with support for WITH_WSO2" ON)
+endif()
+
+if (WITH_WSO2)
+
+	# need to embed libDir in axis2.xml
+	if ( ${SYS_ARCH} STREQUAL "X86_64" )
+		set (WS02_LIB_ROOT "/usr/lib64")
+	else()
+		set (WS02_LIB_ROOT "/usr/lib")
+	endif ()
+
+	if ( NOT PROPER )
+
+		set ( WSO2_VER wso2-2.0.1 )
+
+		#ExternalProject_Add(zlib
+		#		    PREFIX ${EXTERNAL_BUILD_PREFIX}/${WSO2_VER}
+		#		    #-- Download Step ----------
+		#			DOWNLOAD_COMMAND wget -N http://parrot.cs.wisc.edu/externals/${WSO2_VER}.tar.gz ${CMD_TERM}
+		#		    DOWNLOAD_DIR ${EXTERNAL_DL}
+		#		    URL http://parrot.cs.wisc.edu/externals/${WSO2_VER}.tar.gz
+		#		    #--Configure step ----------
+		#		    CONFIGURE_COMMAND cd ${WSO2_VER} && ./configure --prefix=${EXTERNAL_STAGE}
+		#		    #--Build Step ----------
+		#		    BUILD_COMMAND cd ${WSO2_VER} && make
+		#		    #--install Step ----------
+		#		    INSTALL_DIR ${EXTERNAL_STAGE}
+		#		    INSTALL_COMMAND cd ${WSO2_VER} && make install )
+		#
+		# Set the target dependencies which the rest of condor depends on.
+		#set(WSO2_FOUND "${EXTERNAL_STAGE}/STUFF?")
+		#append_var(CONDOR_EXTERNALS zlib)
+		#
+		#install ( FILES ${EXTERNAL_STAGE}/lib/libz.a DESTINATION ${C_LIB} RENAME libcondor_z.a)
+
+		
+		#########################################################
+		#### import from pmackinn's stuff.
+		#if ( NOT DEFINED ENV{WSFCPP_HOME} )
+		#	message( FATAL_ERROR "WSFCPP_HOME not defined for non-proper build")
+		#endif ()
+		#
+		#set ( AXIS2_LIBS -L$ENV{WSFCPP_HOME}/lib
+		#	-libaxis2_engine
+		#	-laxutil -laxis2_axiom -laxis2_parser
+		#	-lneethi -lguththila
+		#	-laxis2_http_common -laxis2_http_receiver -laxis2_http_sender
+		#	-lwso2_wsf )
+		#
+		#include_directories(
+		#		$ENV{WSFCPP_HOME}/include/axis2-1.6.0
+		#		$ENV{WSFCPP_HOME}/include/wso2-wsf-cpp
+		#		$ENV{WSFCPP_HOME}/include/axis2-1.6.0/platforms )
+		#	set(axis2_repo_loc $ENV{WSFCPP_HOME})
+	else( )
+
+		find_multiple( "axis2_engine;axutil;axis2_axiom;axis2_parser;axis2_http_common;axis2_http_receiver;axis2_http_sender;neethi;guththila;wso2_wsf" WSO2_FOUND )
+		append_var (WSO2_INCLUDES "/usr/include/axis2-1.6.0;/usr/include/wso2-wsf-cpp;/usr/include/axis2-1.6.0/platforms")
+
+		install (CODE "execute_process(COMMAND echo Local testing instructions )" )
+		install (CODE "execute_process(COMMAND echo set WSFCPP_HOME to \$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${_INSTALL_LOC}axis2.xml)" )
+		install (CODE "execute_process(COMMAND echo change the servicesDir parameter in axis2.xml to \$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${_INSTALL_LOC}services)" )
+
+	endif( NOT PROPER )
+
+endif(WITH_WSO2)
+
+if (WSO2_FOUND)
+	message (STATUS "external configured (WSO2_FOUND=${WSO2_FOUND})")
+	set( WSO2_FOUND ${WSO2_FOUND} PARENT_SCOPE )
+	set( HAVE_EXT_WSO2 ON PARENT_SCOPE )
+	set( WS02_LIB_ROOT ${WS02_LIB_ROOT} PARENT_SCOPE )
+else()
+	message (STATUS "external skipped (wso2)")
+endif()
diff --git a/nmi_tools/glue/SubmitInfo.pm b/nmi_tools/glue/SubmitInfo.pm
index 62a03f8..73a6cd6 100755
--- a/nmi_tools/glue/SubmitInfo.pm
+++ b/nmi_tools/glue/SubmitInfo.pm
@@ -59,9 +59,11 @@ our %build_and_test_sets = (
 		'x86_64_rhap_5.3-updated',
 		'x86_64_opensuse_11.3-updated',
 		'x86_64_opensuse_11.4-updated',
+		'x86_64_fedora_12-updated',
+		'x86_freebsd_7.4',
+		'x86_64_freebsd_8.2',
 		'x86_64_sol_5.10',
 		'x86_64_sol_5.11',
-		'x86_64_fedora_12-updated',
 	],
 
         # This is a placeholder that is intended to remain empty in V7_6-branch.
@@ -311,6 +313,55 @@ our %submit_info = (
 		},
 	},
 
+	##########################################################################
+	# Platform RHEL 6 on x86
+	##########################################################################
+	'x86_rhap_6.0'	=> {
+		'build' => {
+			'configure_args' => { @default_build_configure_args,
+				# Turn this back on when ready
+				# '-DCLIPPED:BOOL=OFF' => undef,
+			 },
+			'prereqs'	=> [ @default_prereqs ],
+			'xtests'	=> undef,
+		},
+
+		'test' => {
+			'configure_args' => { @default_test_configure_args },
+			'prereqs'	=> [ @default_prereqs, 'java-1.4.2_05' ],
+			'testclass'	=> [ @default_testclass ],
+		},
+	},
+
+	##########################################################################
+	# Platform RHEL 6 on x86. This one is continuously updated by the batlab.
+	##########################################################################
+	'x86_rhap_6.0-updated'	=> 'x86_rhap_6.0',
+
+	##########################################################################
+	# Platform RHEL 6 on x86_64
+	##########################################################################
+	'x86_64_rhap_6.0'	=> {
+		'build' => {
+			'configure_args' => { @default_build_configure_args,
+				# Turn this back on when ready
+				# '-DCLIPPED:BOOL=OFF' => undef,
+			 },
+			'prereqs'	=> [ @default_prereqs ],
+			'xtests'	=> undef,
+		},
+
+		'test' => {
+			'configure_args' => { @default_test_configure_args },
+			'prereqs'	=> [ @default_prereqs, 'java-1.4.2_05' ],
+			'testclass'	=> [ @default_testclass ],
+		},
+	},
+
+	##########################################################################
+	# Platform RHEL 6 on x86_64. This one is continuously updated by the batlab.
+	##########################################################################
+	'x86_64_rhap_6.0-updated'	=> 'x86_64_rhap_6.0',
 
 	##########################################################################
 	# Platform RHEL 5 on x86_64
@@ -324,7 +375,8 @@ our %submit_info = (
 			'xtests'	=> [ 
 				'x86_64_fedora_13', 'x86_64_rhap_5.2',
 				'x86_64_fedora_12', 'x86_64_fedora_12-updated', 
-				'x86_64_fedora_13-updated' ],
+				'x86_64_fedora_13-updated',
+				'x86_64_rhap_6.0-updated' ],
 		},
 
 		'test' => {
@@ -866,6 +918,56 @@ our %submit_info = (
 	'x86_64_opensuse_11.3-updated'		=> 'x86_64_opensuse_11.3',
 	'x86_64_opensuse_11.4'				=> 'x86_64_opensuse_11.3',
 	'x86_64_opensuse_11.4-updated'		=> 'x86_64_opensuse_11.4',
+
+
+	##########################################################################
+	# Platform FreeBSD 7.4 on x86
+	##########################################################################
+	'x86_freebsd_7.4'		=> {
+		'build' => {
+			'configure_args' => { @minimal_build_configure_args,
+				'-DWITHOUT_SOAP_TEST:BOOL=ON' => undef,
+				'-DWITHOUT_AMAZON_TEST:BOOL=ON' => undef,
+				'-DENABLE_JAVA_TESTS:BOOL=OFF' => undef,
+				'-DWITH_CURL:BOOL=OFF' => undef,
+				'-DWITH_EXPAT:BOOL=ON' => undef,
+				'-DWITH_LIBVIRT:BOOL=OFF' => undef,
+				'-DWITH_LIBXML2:BOOL=ON' => undef,
+			},
+			'prereqs'	=> [ 'tar-1.14',
+							 'patch-2.6.1',
+							 'cmake-2.8.3',
+							 'flex-2.5.4a',
+							 'make-3.80',
+							 'byacc-1.9',
+							 'bison-1.25',
+							 'wget-1.9.1',
+							 'm4-1.4.1',
+				],
+			'xtests'	=> undef,
+		},
+
+		'test' => {
+			'configure_args' => {
+				@default_test_configure_args
+				
+			},
+			'prereqs'	=> [ 'tar-1.14',
+							 'patch-2.6.1',
+							 'cmake-2.8.3',
+							 'flex-2.5.4a',
+							 'make-3.80',
+							 'byacc-1.9',
+							 'bison-1.25',
+							 'wget-1.9.1',
+							 'm4-1.4.1',
+				],
+			'testclass'	=> [ @default_testclass ],
+		},
+	},
+	'x86_64_freebsd_7.4'		=> 'x86_freebsd_7.4',
+	'x86_freebsd_8.2'			=> 'x86_freebsd_7.4',
+	'x86_64_freebsd_8.2'		=> 'x86_freebsd_7.4',
 );
 
 while( 1 ) {
@@ -1132,3 +1234,8 @@ if (!defined($main::slaved_module)) {
 }
 
 1;
+
+### Local Variables: ***
+### mode:perl ***
+### tab-width: 4  ***
+### End: ***
diff --git a/src/ccb/ccb_listener.cpp b/src/ccb/ccb_listener.cpp
index 72e7d18..101cd78 100644
--- a/src/ccb/ccb_listener.cpp
+++ b/src/ccb/ccb_listener.cpp
@@ -145,6 +145,10 @@ CCBListener::SendMsgToCCB(ClassAd &msg,bool blocking)
 		}
 		else if( !m_waiting_for_connect ) {
 			m_sock = ccb.makeConnectedSocket(Stream::reli_sock, CCB_TIMEOUT, 0, NULL, true /*nonblocking*/ );
+			if( !m_sock ) {
+				Disconnected();
+				return false;
+			}
 			m_waiting_for_connect = true;
 			incRefCount(); // do not let ourselves be deleted until called back
 			ccb.startCommand_nonblocking( cmd, m_sock, CCB_TIMEOUT, NULL, CCBListener::CCBConnectCallback, this, NULL, false, USE_TMP_SEC_SESSION );
diff --git a/src/classad/CHANGELOG b/src/classad/CHANGELOG
index e577a9e..f36b747 100644
--- a/src/classad/CHANGELOG
+++ b/src/classad/CHANGELOG
@@ -1,4 +1,4 @@
-Changes for version 1.0.10 (Released ????-??-??)
+Changes for version 1.0.10 (Released 2011-04-08)
 * Fix infinite loop and bad iterator comparison in FunctionCall::SameAs().
 * Fix memory leak in FunctionCall::eval().
 * Fix ClassAd::GetInternalReferences() and ClassAd::GetExternalReferences()
diff --git a/src/classad/CMakeLists.txt b/src/classad/CMakeLists.txt
index 293ecf4..daf0866 100644
--- a/src/classad/CMakeLists.txt
+++ b/src/classad/CMakeLists.txt
@@ -15,8 +15,9 @@
  # limitations under the License. 
  # 
  ############################################################### 
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
 
-add_definitions(-DCLASSAD_DISTRIBUTION -DWANT_CLASSAD_NAMESPACE=1 -DDISABLE_DLOPEN_CHECK )
+add_definitions(-DCLASSAD_DISTRIBUTION -DWANT_CLASSAD_NAMESPACE=1 )
 
 # disable PCRE build unless dep added to externals.
 if(PCRE_FOUND)
@@ -25,41 +26,70 @@ else()
 	add_definitions(-DUSE_POSIX_REGEX) 
 endif(PCRE_FOUND)
 
-# in order to update configure
+if (HAVE_DLOPEN)
+	add_definitions(-DHAVE_DLOPEN)
+endif()
+
+if (HAVE_DLFCN_H)
+	add_definitions(-DHAVE_DLFCN_H)
+endif(HAVE_DLFCN_H)
+
+if (HAVE_LIBDL)
+	set(DL_FOUND -ldl)
+endif(HAVE_LIBDL)
+
 if (NOT WINDOWS)
 
-  # because of the external dependencies on classads we need to be careful to make it look like a normal install
-  file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/classad DESTINATION ${EXTERNAL_STAGE}/include )
+  condor_selective_glob("attrrefs.*;classad.*;collection.*;collectionBase.*;debug.*;exprList.*;exprTree.*;fnCall.*;indexfile.*;lexer.*;lexerSource.*;literals.*;matchClassad.*;operators.*;query.*;sink.*;source.*;transaction.*;util.*;value.*;view.*;xmlLexer.*;xmlSink.*;xmlSource.*;cclassad.*;common.*" ClassadSrcs)
+  add_library( classads STATIC ${ClassadSrcs} )    # the one which all of condor depends upon
 
-  if (WANT_FULL_DEPLOYMENT)
-	install( DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/classad DESTINATION ${C_INCLUDE} )
+  if (LINUX)  
+  	add_library( classad SHARED ${ClassadSrcs} )   # for distribution at this point may swap to depend at a future date.
+	set_target_properties( classad PROPERTIES VERSION 1.1.0 SOVERSION 1 )
+	install( TARGETS classad DESTINATION ${C_LIB} )
   endif()
 
-  condor_selective_glob("attrrefs.*;classad.*;collection.*;collectionBase.*;debug.*;exprList.*;exprTree.*;fnCall.*;indexfile.*;lexer.*;lexerSource.*;literals.*;matchClassad.*;operators.*;query.*;sink.*;source.*;transaction.*;util.*;value.*;view.*;xmlLexer.*;xmlSink.*;xmlSource.*;cclassad.*;common.*" ClassadSrcs)
+  set (CLASSADS_FOUND classads)
 
-  add_library( classads STATIC ${ClassadSrcs} )
-  set_target_properties( classads
-	PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib 
-	LIBRARY_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib
-	RUNTIME_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib
-	OUTPUT_NAME classad_ns)
+  ###### Test executables
+  condor_exe_test( classad_unit_tester "classad_unit_tester.cpp" "${CLASSADS_FOUND};${PCRE_FOUND};${DL_FOUND}")
+  condor_exe( classad_functional_tester "classad_functional_tester.cpp" ${C_BIN} "${CLASSADS_FOUND};${PCRE_FOUND};${DL_FOUND}" OFF)
+  condor_exe( classad_version "classad_version.cpp" ${C_BIN} "${CLASSADS_FOUND};${PCRE_FOUND};${DL_FOUND}" OFF)
+  
+  ###### Install elements with our distribution
+  install( TARGETS classads DESTINATION ${C_LIB} )
+  install( DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/classad DESTINATION ${C_INCLUDE} )
 
 else()
 	
-	# I should probably just add all and subtract tests.
+	# windows specific configuration.
 	condor_selective_glob("attrrefs.cpp;common.cpp;collection*;fnCall.cpp;expr*;indexfile*;lexer*;literals.cpp;matchClassad.cpp;classad.cpp;debug.cpp;operators.cpp;util.cpp;value.cpp;query.cpp;sink.cpp;source.cpp;transaction.cpp;view.cpp;xml*" ClassadSrcs)
 	add_library( classads STATIC ${ClassadSrcs} )
 	set_property( TARGET classads PROPERTY FOLDER "libraries" )
+    set (CLASSADS_FOUND classads)
 
 endif()
 
-set( CLASSADS_FOUND classads )
+# standard output message used to slog users.  
+message (STATUS "configured (CLASSADS_FOUND= ${CLASSADS_FOUND})")
+append_var (CONDOR_EXTERNALS ${CLASSADS_FOUND})
+set( CLASSADS_FOUND ${CLASSADS_FOUND} PARENT_SCOPE )
+set( HAVE_EXT_CLASSADS ON PARENT_SCOPE )
 
+# finally add dependencies if there are any
 if (NOT PROPER)
-  add_dependencies( classads pcre )
+  add_dependencies( ${CLASSADS_FOUND} pcre )
+
+  if (NOT WINDOWS)
+  ############################################################################## 
+  # the only reason this exists is b/c our externals depend on it  
+  file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/classad DESTINATION ${EXTERNAL_STAGE}/include )
+  set_target_properties( classads
+	PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib 
+	LIBRARY_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib
+	RUNTIME_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib
+	OUTPUT_NAME classad)
+  endif()
+
 endif(NOT PROPER)
 
-message (STATUS "external configured (CLASSADS_FOUND=${CLASSADS_FOUND})")
-set( CLASSADS_FOUND ${CLASSADS_FOUND} PARENT_SCOPE )
-set( HAVE_EXT_CLASSADS ON PARENT_SCOPE )
-append_var (CONDOR_EXTERNALS classads)
diff --git a/src/classad/Doxyfile b/src/classad/Doxyfile
index 7d61a84..df632c4 100644
--- a/src/classad/Doxyfile
+++ b/src/classad/Doxyfile
@@ -31,7 +31,7 @@ PROJECT_NAME           = ClassAds
 # This could be handy for archiving the generated documentation or
 # if some version control system is used.
 
-PROJECT_NUMBER         = 1.0.9
+PROJECT_NUMBER         = 1.0.10
 
 # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
 # base path where the generated documentation will be put.
diff --git a/src/classad/Makefile.am.m4 b/src/classad/Makefile.am.m4
index 03121c8..b85cb17 100644
--- a/src/classad/Makefile.am.m4
+++ b/src/classad/Makefile.am.m4
@@ -152,8 +152,8 @@ libclassad_la_SOURCES = \
 	sink.cpp source.cpp transaction.cpp util.cpp value.cpp view.cpp xmlLexer.cpp	\
 	xmlSink.cpp xmlSource.cpp cclassad.cpp $(_libclassad_la_SOURCES)
 
-libclassad_la_LDFLAGS = -version-info 1:0:1
-libclassad_ns_la_LDFLAGS = -version-info 1:0:1
+libclassad_la_LDFLAGS = -version-info 1:2:0
+libclassad_ns_la_LDFLAGS = -version-info 1:2:0
 
 MF_IF_NAMESPACE([libclassad_ns_la_SOURCES = $(libclassad_la_SOURCES)
    libclassad_ns_la_CXXFLAGS = $(NAMESPACE)])
diff --git a/src/classad/README b/src/classad/README
index bce8cd7..0e81df6 100644
--- a/src/classad/README
+++ b/src/classad/README
@@ -1,4 +1,4 @@
-This is version 1.0.9 of the Condor Classad library, released on 2010-08-23.
+This is version 1.0.10 of the Condor Classad library, released on 2011-04-08.
 
 ===== What is it? =====
 
diff --git a/src/classad/README.packaging b/src/classad/README.packaging
index 7e107a7..9dd1c91 100644
--- a/src/classad/README.packaging
+++ b/src/classad/README.packaging
@@ -15,11 +15,15 @@ Update the shared library version number in src/classad/Makefile.am.m4.
 Look for these two lines:
     libclassad_la_LDFLAGS = -version-info 1:0:0
     libclassad_ns_la_LDFLAGS = -version-info 1:0:0
-If the ABI has changed, you should increment the first number and set the 
-second and third ones to zero. If the ABI hasn't changed, then increment 
-the second or third number. See 
+
+If the ABI has changed (such that programs linked against an older 
+version won't work with the new version), you should increment the first 
+number and set the second and third ones to zero. If the ABI has only been 
+expanded (new symbols added), increment the first and third numbers, and 
+set the second one to zero. If the ABI hasn't changed, then increment the 
+second number. See 
 http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html#AEN135  
-for examples of things that will change the ABI.
+for examples of things that will change the ABI incompatibly.
 This ABI compliance checker program may be useful: 
 http://ispras.linuxfoundation.org/index.php/ABI_compliance_checker
 
diff --git a/src/classad/TAGS b/src/classad/TAGS
index 659cb34..a0db662 100644
--- a/src/classad/TAGS
+++ b/src/classad/TAGS
@@ -14,3 +14,4 @@ classads_1_0_6
 classads_1_0_7
 classads_1_0_8
 classads_1_0_9
+classads_1_0_10
diff --git a/src/classad/classad.cpp b/src/classad/classad.cpp
index dfb0435..f78ecc7 100644
--- a/src/classad/classad.cpp
+++ b/src/classad/classad.cpp
@@ -44,13 +44,13 @@ void ClassAdLibraryVersion(int &major, int &minor, int &patch)
 {
     major = 1;
     minor = 0;
-    patch = 9;
+    patch = 10;
     return;
 }
 
 void ClassAdLibraryVersion(string &version_string)
 {
-    version_string = "1.0.9";
+    version_string = "1.0.10";
     return;
 }
 
@@ -968,7 +968,15 @@ _GetExternalReferences( const ExprTree *expr, ClassAd *ad,
                         refs.insert( fullName );
                         return true;
                     } else {
-                        return( _GetExternalReferences( tree, ad, state, refs, fullNames ));
+                        if( state.depth_remaining <= 0 ) {
+                            return false;
+                        }
+                        state.depth_remaining--;
+
+                        bool ret = _GetExternalReferences( tree, ad, state, refs, fullNames );
+
+                        state.depth_remaining++;
+                        return ret;
                     }
                 }
                     // otherwise, if the tree didn't evaluate to a classad,
@@ -992,7 +1000,15 @@ _GetExternalReferences( const ExprTree *expr, ClassAd *ad,
 
                 case EVAL_OK: {
                         // attr is internal; find external refs in result
-					bool rval=_GetExternalReferences(result,ad,state,refs,fullNames);
+                    if( state.depth_remaining <= 0 ) {
+                        state.curAd = curAd;
+                        return false;
+                    }
+                    state.depth_remaining--;
+
+                    bool rval=_GetExternalReferences(result,ad,state,refs,fullNames);
+
+                    state.depth_remaining++;
 					state.curAd = curAd;
 					return( rval );
 				}
@@ -1043,7 +1059,15 @@ _GetExternalReferences( const ExprTree *expr, ClassAd *ad,
 
             ((const ClassAd*)expr)->GetComponents( attrs );
             for( itr = attrs.begin( ); itr != attrs.end( ); itr++ ) {
-                if( !_GetExternalReferences( itr->second, ad, state, refs, fullNames )) {
+                if( state.depth_remaining <= 0 ) {
+                    return false;
+                }
+                state.depth_remaining--;
+
+                bool ret = _GetExternalReferences( itr->second, ad, state, refs, fullNames );
+
+                state.depth_remaining++;
+                if( !ret ) {
 					return( false );
 				}
             }
@@ -1058,7 +1082,15 @@ _GetExternalReferences( const ExprTree *expr, ClassAd *ad,
 
             ((const ExprList*)expr)->GetComponents( exprs );
             for( itr = exprs.begin( ); itr != exprs.end( ); itr++ ) {
-                if( !_GetExternalReferences( *itr, ad, state, refs, fullNames ) ) {
+                if( state.depth_remaining <= 0 ) {
+                    return false;
+                }
+                state.depth_remaining--;
+
+                bool ret = _GetExternalReferences( *itr, ad, state, refs, fullNames );
+
+                state.depth_remaining++;
+                if( !ret ) {
 					return( false );
 				}
             }
@@ -1342,7 +1374,15 @@ _GetInternalReferences( const ExprTree *expr, ClassAd *ad,
                 case EVAL_OK:   {
                     //whoo, it's internal.
                     refs.insert(attr);
+                    if( state.depth_remaining <= 0 ) {
+                        state.curAd = curAd;
+                        return false;
+                    }
+                    state.depth_remaining--;
+
                     bool rval =_GetInternalReferences(result, ad, state, refs, fullNames);
+
+                    state.depth_remaining++;
                     //TODO: Does this actually matter?
                     state.curAd = curAd;
                     return rval;
@@ -1405,7 +1445,15 @@ _GetInternalReferences( const ExprTree *expr, ClassAd *ad,
 
             ((const ClassAd*)expr)->GetComponents(attrs);
             for(itr = attrs.begin(); itr != attrs.end(); itr++){
-                if( !_GetInternalReferences(itr->second, ad, state, refs, fullNames)) {
+                if( state.depth_remaining <= 0 ) {
+                    return false;
+                }
+                state.depth_remaining--;
+
+                bool ret = _GetInternalReferences(itr->second, ad, state, refs, fullNames);
+
+                state.depth_remaining++;
+                if( !ret ) {
                     return false;
                 }
             }
@@ -1420,7 +1468,15 @@ _GetInternalReferences( const ExprTree *expr, ClassAd *ad,
 
             ((const ExprList*)expr)->GetComponents(exprs);
             for(itr = exprs.begin(); itr != exprs.end(); itr++){
-                if( !_GetInternalReferences(*itr, ad, state, refs, fullNames) ) {
+                if( state.depth_remaining <= 0 ) {
+                    return false;
+                }
+                state.depth_remaining--;
+
+                bool ret = _GetInternalReferences(*itr, ad, state, refs, fullNames);
+
+                state.depth_remaining++;
+                if( !ret ) {
                     return false;
                 }
             }
diff --git a/src/classad/classad/common.h b/src/classad/classad/common.h
index f62a65c..660558b 100644
--- a/src/classad/classad/common.h
+++ b/src/classad/classad/common.h
@@ -48,6 +48,10 @@
 #define _STLP_NEW_PLATFORM_SDK
 #define _STLP_NO_OWN_IOSTREAMS 1
 
+// Disable warnings about calling posix functions like open()
+// instead of _open()
+#define _CRT_NONSTDC_NO_WARNINGS
+
 // Disable warnings about possible loss of data, since "we know what
 // we are doing" and fixing them correctly would require too much 
 // time from one of us. (Maybe this should be a student exercise.)
@@ -71,6 +75,7 @@
 
 
 #ifdef WIN32
+
 	// special definitions we need for Windows
 #ifndef DLL_IMPORT_MAGIC
 #define DLL_IMPORT_MAGIC __declspec(dllimport)
@@ -79,9 +84,6 @@
 #include <float.h>
 #include <io.h>
 #define fsync _commit
-#ifndef open
-#define open _open
-#endif
 #define strcasecmp _stricmp
 #ifndef rint
 #define rint(num) floor(num + .5)
@@ -89,9 +91,7 @@
 #define isnan _isnan
 	// isinf() defined in util.h
 
-#ifdef WIN32
 #include <hash_map>
-#endif
 
 #define snprintf _snprintf
 
@@ -102,6 +102,7 @@
 #pragma warning( disable : 4800 )  
 	// Disable warnings about truncated debug identifiers
 #pragma warning( disable : 4786 )
+
 #endif // WIN32
 
 
diff --git a/src/classad/classad_functional_tester.cpp b/src/classad/classad_functional_tester.cpp
index 12305cf..84d7cb6 100644
--- a/src/classad/classad_functional_tester.cpp
+++ b/src/classad/classad_functional_tester.cpp
@@ -21,7 +21,6 @@
 #include "classad/classad_distribution.h"
 #include "classad/lexerSource.h"
 #include "classad/xmlSink.h"
-#undef open // we don't want the open method of basic_ofstream to end up being called _open...
 #include <fstream>
 #include <iostream>
 #include <ctype.h>
diff --git a/src/classad/do_packaging b/src/classad/do_packaging
index 197ec6b..531c7dd 100755
--- a/src/classad/do_packaging
+++ b/src/classad/do_packaging
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-DIST_VERSION=1.0.9
+DIST_VERSION=1.0.10
 DISTRIBUTION_DIR=classads-${DIST_VERSION}
 
 EXCLUDE_LIST="do_packaging CMakeLists.txt README.packaging TAGS TODO man_cache_test.cpp test_classads.cpp"
diff --git a/src/classad/lexerSource.cpp b/src/classad/lexerSource.cpp
index bb08f9e..1cbc450 100644
--- a/src/classad/lexerSource.cpp
+++ b/src/classad/lexerSource.cpp
@@ -112,7 +112,7 @@ InputStreamLexerSource::ReadCharacter(void)
 	char real_character;
 	int  character;
 
-	if (_stream != NULL && !_stream->eof()) {
+	if (_stream != NULL && _stream->good()) {
 		_stream->get(real_character);
 		character = (unsigned char)real_character;
 	} else {
diff --git a/src/classad/util.cpp b/src/classad/util.cpp
index 2e06049..7f1f981 100644
--- a/src/classad/util.cpp
+++ b/src/classad/util.cpp
@@ -200,7 +200,7 @@ void convert_escapes(string &text, bool &validStr)
 						sscanf(octal, "%o", &number);
 						new_char = number;
 					} else {
-						new_char = text[source];
+						number = new_char = text[source];
 					}
 					if(number == 0) { // "\\0" is an invalid substring within a string literal
 					  validStr = false;
diff --git a/src/classad_analysis/boolExpr.cpp b/src/classad_analysis/boolExpr.cpp
index e08ecb4..fc4332b 100644
--- a/src/classad_analysis/boolExpr.cpp
+++ b/src/classad_analysis/boolExpr.cpp
@@ -67,7 +67,9 @@ ExprToMultiProfile( classad::ExprTree *expr, MultiProfile *&mp )
 
 		kind = currentTree->GetKind( );
 			
-		if( kind == classad::ExprTree::ATTRREF_NODE ) {
+		if( kind == classad::ExprTree::ATTRREF_NODE ||
+			kind == classad::ExprTree::FN_CALL_NODE )
+		{
 			atLeftMostProfile = true;
 			continue;
 		}
@@ -172,7 +174,9 @@ ExprToProfile( classad::ExprTree *expr, Profile *&p )
 
 		kind = currentTree->GetKind( );
 
-		if( kind == classad::ExprTree::ATTRREF_NODE ) {
+		if( kind == classad::ExprTree::ATTRREF_NODE ||
+			kind == classad::ExprTree::FN_CALL_NODE )
+		{
 			atLeftMostCondition = true;
 			continue;
 		}
@@ -269,6 +273,14 @@ ExprToCondition( classad::ExprTree *expr, Condition *&c )
 		return true;
 	}
 
+	if( kind == classad::ExprTree::FN_CALL_NODE ) {
+		if( !c->InitComplex( expr->Copy( ) ) ) {
+  				cerr << "error: problem with Condition::InitComplex" << endl;
+  				return false;
+		}
+		return true;
+	}
+
 	if( kind != classad::ExprTree::OP_NODE ) {
 		cerr << "error: no operator/attribute found" << endl;
 			// error: no operator/attribute  found;
diff --git a/src/condor_c-gahp/cgahp_common.cpp b/src/condor_c-gahp/cgahp_common.cpp
index b9f9c46..a13430f 100644
--- a/src/condor_c-gahp/cgahp_common.cpp
+++ b/src/condor_c-gahp/cgahp_common.cpp
@@ -36,6 +36,8 @@ parse_gahp_command (const char* raw, Gahp_Args* args) {
 	int len=strlen(raw);
 
 	char * buff = (char*)malloc(len+1);
+    ASSERT(buff);
+
 	int buff_len = 0;
 
 	for (int i = 0; i<len; i++) {
diff --git a/src/condor_ckpt/CMakeLists.txt b/src/condor_ckpt/CMakeLists.txt
index 9aab726..2b2ef62 100644
--- a/src/condor_ckpt/CMakeLists.txt
+++ b/src/condor_ckpt/CMakeLists.txt
@@ -37,18 +37,19 @@ if( STD_UNIVERSE )
 	###########################################################################
 	add_definitions( ${STD_U_C_FLAGS} -DFILE_TABLE -DIN_CKPT_LIB)
 	include_directories(${CONDOR_SOURCE_DIR}/src/condor_ckpt)
-	condor_selective_glob("*file*;signals*;image*;machdep.LINUX.cpp;tmp_*;syscall_*;fake_*;condor_error*;eprintf*;shared_*;malloc-user*;gto*;maps*" CommonCkptSrcs )
-
-	# from what I can tell this doesn't even work.
-	#if (DOES_COMPRESS_CKPT)
-	#	add_definitions(-DCOMPRESS_CKPT -DMORECORE=condor_morecore -DHAVE_MMAP=0 -Dmalloc_getpagesize=8192)
-	#	condor_selective_glob("malloc-condor.cpp;malloc.cpp" CompressSrcs)
-	#endif(DOES_COMPRESS_CKPT)
+	condor_selective_glob("*file*;signals*;machdep.LINUX.cpp;tmp_*;syscall_*;fake_*;condor_error*;eprintf*;shared_*;malloc-user*;gto*;maps*" CommonCkptSrcs )
 
 	# we create a local lib, but it's never actually used
 	# instead condorsyscall will rip out the target refs.
 	#condor_static_lib( ckpt "${CommonCkptSrcs};${CompressSrcs}")
-	add_library(ckpt STATIC EXCLUDE_FROM_ALL ${CommonCkptSrcs};${CompressSrcs})
+	add_library(ckpt STATIC EXCLUDE_FROM_ALL ${CMAKE_CURRENT_SOURCE_DIR}/image.cpp;${CommonCkptSrcs})
 	add_dependencies( ckpt syscall_numbers )
 
+	if (DOES_COMPRESS_CKPT)
+
+		add_library(zckpt STATIC EXCLUDE_FROM_ALL ${CMAKE_CURRENT_SOURCE_DIR}/zimage.cpp;${CMAKE_CURRENT_SOURCE_DIR}/malloc-condor.c;${CommonCkptSrcs})
+
+		add_dependencies( zckpt syscall_numbers )
+	endif(DOES_COMPRESS_CKPT)
+
 endif(STD_UNIVERSE)
diff --git a/src/condor_ckpt/image.cpp b/src/condor_ckpt/image.cpp
index c7cc873..39817f4 100644
--- a/src/condor_ckpt/image.cpp
+++ b/src/condor_ckpt/image.cpp
@@ -32,6 +32,19 @@
 #include "subsystem_info.h"
 #include "gtodc.h"
 
+#if defined(COMPRESS_CKPT)
+/* This structure represents an alternate heap, controlled by a specially
+	created malloc, and used by zlib for the checkpoint compression feature.
+*/
+struct alternate_memory_heap {
+	void *begin;
+	void *corestart;
+	void **coreend;
+	void **segend;
+	int pagesize;
+};
+#endif
+
 extern int _condor_in_file_stream;
 
 const int KILO = 1024;
@@ -49,6 +62,8 @@ extern "C" void _condor_restore_sigstates();
 #if defined(COMPRESS_CKPT)
 #include "zlib.h"
 extern "C" {
+	void display_alternate_memory_heap(int dlevel);
+	int condor_malloc_getpagesize(void); // in malloc-condor.c
 	int condor_malloc_init_size();
 	void condor_malloc_init(void *start);
 	char *condor_malloc(size_t);
@@ -85,6 +100,7 @@ extern "C" void _install_signal_handler( int sig, SIG_HANDLER handler );
 extern "C" int open_ckpt_file( const char *name, int flags, size_t n_bytes );
 extern "C" int get_ckpt_mode( int sig );
 extern "C" int get_ckpt_speed( );
+static void sleep_syscall(int seconds);
 
 Image MyImage;
 static jmp_buf Env;
@@ -98,6 +114,13 @@ unsigned int _condor_numrestarts = 0;
 int condor_compress_ckpt = 1; // compression off(0) or on(1)
 int condor_slow_ckpt = 0;
 
+#if defined(COMPRESS_CKPT)
+// There is only ONE alternate heap. This global variable gets saved and
+// restored across checkpoints. This means that the mmap'ed heap during
+// checkpoint will be known to be put into the right place upon restore.
+static struct alternate_memory_heap amh = { NULL, NULL, NULL, NULL, -1 };
+#endif
+
 /* these are the remote system calls we use in this file */
 extern "C" int REMOTE_CONDOR_send_rusage(struct rusage *use_p);
 
@@ -148,71 +171,225 @@ void *condor_map_seg(void *base, size_t size)
 	return base;
 }
 
+void display_alternate_memory_heap(int dlevel)
+{
+	dprintf(dlevel,
+		"Alternate Memory Heap: {begin=%p, corestart=%p, coreend=%p, segend=%p, *coreend=%p, *segend=%p, pagesize=%d}\n",
+		amh.begin, amh.corestart, amh.coreend, amh.segend, 
+		amh.coreend!=NULL?*amh.coreend:NULL,
+		amh.segend!=NULL?*amh.segend:NULL,
+		amh.pagesize);
+}
+
 // TODO: deallocate segments on negative incr
 void *condor_morecore(int incr)
 {
-	// begin points to the start of our heap segment
-	// corestart points to the start of the allocated portion of the segment
-	// *coreend points to the end of the allocated portion of the segment
-	// *segend points to the end of our allocated segment
-	// coreend and segend are stored at the start of the segment because
+	// amh.begin points to the start of our heap segment
+	// amh.corestart points to the start of the allocated portion of the segment
+	// *amh.coreend points to the end of the allocated portion of the segment
+	// *amh.segend points to the end of our allocated segment
+	// amh.coreend and segend are stored at the start of the segment because
 	//   we don't want them to be overwritten on a restart
-	static void *begin = NULL, *corestart = NULL,
-		**coreend = NULL, **segend = NULL;
-	static int pagesize = -1;
 
-	if (pagesize == -1) {
-		pagesize = getpagesize();
+	if (amh.pagesize == -1) {
+		// This is the page size of the alternate heap allocator, NOT the
+		// regular allocator used by the application. The two allocators
+		// can sometimes have different sizes and we don't want to confuse
+		// the two.
+		amh.pagesize = condor_malloc_getpagesize();
 	}
-	
-	if (begin == NULL) {
-		begin = MyImage.FindAltHeap();
+
+	if (amh.begin == NULL) {
+		amh.begin = MyImage.FindAltHeap();
 		int malloc_static_data = condor_malloc_init_size();
 		int segincr =
 			(((incr+malloc_static_data+
-			   (2*sizeof(void *)))/pagesize)+1)*pagesize;
-		begin = condor_map_seg(begin, segincr);
-		corestart = (void *) (
-			(int)begin+(int)(2*sizeof(void *))+(int)malloc_static_data ); 
-		condor_malloc_init((void *)((int)begin+(int)(2*sizeof(void *))));
-		coreend = (void **)begin;
-		segend = (void **)((int)begin+(int)sizeof(void *));
-		*segend = (void *)((int)begin+(int)segincr);
-		*coreend = (void *)((int)corestart+(int)incr);
-		return corestart;
+			   (2*sizeof(void *)))/amh.pagesize)+1)*amh.pagesize;
+		amh.begin = condor_map_seg(amh.begin, segincr);
+		amh.corestart = (void *) (
+			(int)amh.begin+(int)(2*sizeof(void *))+(int)malloc_static_data ); 
+		condor_malloc_init((void *)((int)amh.begin+(int)(2*sizeof(void *))));
+		amh.coreend = (void **)amh.begin;
+		amh.segend = (void **)((int)amh.begin+(int)sizeof(void *));
+		*amh.segend = (void *)((int)amh.begin+(int)segincr);
+		*amh.coreend = (void *)((int)amh.corestart+(int)incr);
+		return amh.corestart;
 	} else if (incr == 0) {
-		return *coreend;
+		return *amh.coreend;
 	} else {
-		void *old_break = *coreend;
-		*coreend = (void *)((int)*coreend + (int)incr);
-		if (*coreend > *segend) {
-			int segincr = (int)((((int)*coreend-(int)*segend)/(int)pagesize)+1)*(int)pagesize;
-			if ((int)*coreend+(int)segincr-(int)begin > ALT_HEAP_SIZE) {
+		void *old_break = *amh.coreend;
+		*amh.coreend = (void *)((int)*amh.coreend + (int)incr);
+		if (*amh.coreend > *amh.segend) {
+			int segincr = (int)((((int)*amh.coreend-(int)*amh.segend)/(int)amh.pagesize)+1)*(int)amh.pagesize;
+			if ((int)*amh.coreend+(int)segincr-(int)amh.begin > ALT_HEAP_SIZE) {
 				dprintf(D_ALWAYS,
 						"fatal error: exceeded ALT_HEAP_SIZE of %d bytes!\n",
 						ALT_HEAP_SIZE);
 				Suicide();
 			}
-			if (condor_map_seg(*segend, segincr) != *segend) {
+			if (condor_map_seg(*amh.segend, segincr) != *amh.segend) {
 				dprintf(D_ALWAYS, "failed to allocate contiguous segments in "
 						"condor_morecore!\n");
 				Suicide();
 			}
-			*segend = (void *)((int)*segend + (int)segincr);
+			*amh.segend = (void *)((int)*amh.segend + (int)segincr);
 		}
 		return old_break;
 	}
 }
 
 void *
-zalloc(voidpf opaque, uInt items, uInt size)
+zalloc(voidpf /* opaque */, uInt items, uInt size)
 {
-	return condor_malloc(items*size);
+	uInt total_size = 0;
+	void *chunk = NULL;
+	void *chunk_start = NULL;
+	void *chunk_end = NULL;
+
+	// Get the requested memory from the alternate heap. This may initialize
+	// the alternate heap based upon condor_morecore(). 
+	total_size = items * size;
+	chunk = condor_malloc(total_size);
+
+	// some useful pointers for later checks and messages.
+	chunk_start = chunk;
+	chunk_end = (char*)chunk + total_size;
+
+	// Check to make sure alternate heap was and still is initialized.
+	if (amh.begin == NULL ||
+		amh.corestart == NULL ||
+		amh.coreend == NULL ||
+		*amh.coreend == NULL ||
+		amh.segend == NULL ||
+		*amh.segend == NULL ||
+		amh.pagesize != condor_malloc_getpagesize())
+	{
+		dprintf(D_ALWAYS, 
+			"ERROR: The alternate heap has not been initialized properly. "
+			"Please check to see that MORECORE had been defined properly "
+			"when compiling malloc-condor.c. Committing Suicide()!\n");
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check to see that the memory we got back from the allocator is
+	// _completely contained_ in the alternate heap. We do this because if
+	// somehow condor_malloc() actually called sbrk() instead of
+	// condor_morecore(), we'd silently corrupt the checkpoint image and
+	// subsequent checkpoint. We take great care to examine how it fails 
+	// since that can lead to insight into what is going wrong.
+
+	// Check if chunk starts before the alt heap and ends after the alt heap
+	if (chunk_start < amh.corestart && chunk_end >= *amh.coreend) 
+	{
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which _completely_ overlaps the alternate heap boundaries "
+			"of [%p, %p]. "
+			"Check to see if MORECORE is defined properly when "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check if the entire chunk is below the alternate heap.
+	if (chunk_end < amh.corestart) {
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which is below the valid alternate heap boundaries of [%p, %p]. "
+			"Check to see if MORECORE is defined properly when "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check if the entire chunk is above the alternate heap.
+	if (chunk_start > *amh.coreend) {
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which is above the valid alternate heap boundaries of [%p, %p]. "
+			"Check to see if MORECORE is defined properly when "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check if the chunk overlaps the lower boundary of the alt heap.
+	if (chunk_start < amh.corestart && chunk_end >= amh.corestart)
+	{
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which overlaps the start alternate heap boundaries of [%p, %p]. "
+			"Check to see if MORECORE is defined properly when "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check if the chunk overlaps the upper boundary of the alt heap.
+	if (chunk_start >= amh.corestart && 
+		chunk_start < *amh.coreend &&
+		chunk_end >= *amh.coreend)
+	{
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which overlaps the end alternate heap boundaries of [%p, %p]. "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// If we passed the validation gauntlet, we're good to go!
+	return chunk;
 }
 
 void
-zfree(voidpf opaque, voidpf address)
+zfree(voidpf /* opaque */ , voidpf address)
 {
+	// Check to see that the pointer we are about to free actually exists IN
+	// the alternate heap. We do this because if somehow we pass pointers from
+	// the real malloc heap to here, we could silently corrupt or segfault in
+	// either heap.
+
+	if (address < amh.corestart) {
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator asked to free a pointer %p from "
+			"below the alternate heap! Check to see if MORECORE is defined "
+			"properly when compiling malloc-condor.c! Also check that a real "
+			"heap pointer isn't being passed to the alternate heap free "
+			"function! Commiting Suicide()!\n",
+			address);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	if (address >= *amh.coreend) {
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator asked to free a pointer %p from "
+			"above the alternate heap! Check to see if MORECORE is defined "
+			"properly when compiling malloc-condor.c! Also check that a real "
+			"heap pointer isn't being passed to the alternate heap free "
+			"function! Commiting Suicide()!\n",
+			address);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
 	condor_free(address);
 }
 #endif
@@ -1871,6 +2048,33 @@ void ckpt_and_exit__()
 
 }   /* end of extern "C" */
 
+/* this bypasses our need for libc */
+void sleep_syscall(int seconds)
+{
+
+#if defined(SYS_sleep)
+	SYSCALL(SYS_sleep, seconds);
+#elif defined(SYS__newselect)
+	struct timeval t;
+	t.tv_sec = seconds;
+	t.tv_usec = 0;
+	SYSCALL(SYS__newselect, 0, NULL, NULL, NULL, &t);
+#elif defined(SYS_select)
+	struct timeval t;
+	t.tv_sec = seconds;
+	t.tv_usec = 0;
+	SYSCALL(SYS_select, 0, NULL, NULL, NULL, &t);
+#elif defined(SYS_nanosleep)
+	struct timespec t;
+	t.tv_sec = seconds;
+	t.tv_nsec = 0;
+	SYSCALL(SYS_nanosleep, &t, NULL);
+#else
+#error "Please port me!  I need a sleep system call."
+#endif
+
+}
+
 /*
   Arrange to terminate abnormally with the given signal.  Note: the
   expectation is that the signal is one whose default action terminates
@@ -1918,26 +2122,7 @@ terminate_with_sig( int sig )
 	// our debug message doesn't arrive at the shadow, we won't know why
 	// the job died.  Note that we don't necessarily have access to any
 	// libc functions here, so we must use SYSCALL(SYS_something, ...).
-#if defined(SYS_sleep)
-	SYSCALL(SYS_sleep, 1);
-#elif defined(SYS__newselect)
-	struct timeval t;
-	t.tv_sec = 1;
-	t.tv_usec = 0;
-	SYSCALL(SYS__newselect, 0, NULL, NULL, NULL, &t);
-#elif defined(SYS_select)
-	struct timeval t;
-	t.tv_sec = 1;
-	t.tv_usec = 0;
-	SYSCALL(SYS_select, 0, NULL, NULL, NULL, &t);
-#elif defined(SYS_nanosleep)
-	struct timespec t;
-	t.tv_sec = 1;
-	t.tv_nsec = 0;
-	SYSCALL(SYS_nanosleep, &t, NULL);
-#else
-#error "Please port me!  I need a sleep system call."
-#endif
+	sleep_syscall(1);
 
 	if( SYSCALL(SYS_kill, my_pid, sig) < 0 ) {
 		EXCEPT( "kill" );
diff --git a/src/condor_ckpt/malloc-condor.c b/src/condor_ckpt/malloc-condor.c
index 946617c..973eac2 100644
--- a/src/condor_ckpt/malloc-condor.c
+++ b/src/condor_ckpt/malloc-condor.c
@@ -17,15 +17,47 @@
  *
  ***************************************************************/
 
+/* This file sets up some definitions in order to create a private malloc
+	implementation suitable for use by the checkpointing library to make a
+	private heap.  This is *not* the malloc called by ordinary user code.
+	Its use is primarily by zlib when it compressed/uncompresses checkpoints.
+	The privacy is enforced at the symbol namespace level via the
+	MALLOC_SYMBOL #define that is part of the malloc.c interface.
+*/
+
+
+/* First we check to make sure we're being compiled properly.
+	Traditionally, you can use the values:
+	-DMORECORE=condor_morecore
+	-DHAVE_MMAP=0
+	-Dmalloc_getpagesize=8192
+
+	The first states to use the function condor_morecore() instead of sbrk().
+	The second states that MORECORE should *always* be called instead of mmap().
+	The third dictates how big the pages are wrt to the allocator.
+*/
+#if !defined(MORECORE) || !defined(HAVE_MMAP) || !defined(malloc_getpagesize)
+#error You should be defining MORECORE, HAVE_MMAP, and malloc_getpagesize on the compilation line for this file!
+#endif
 
-/*
-This file sets up some definitions in order
-to create a private malloc implementation suitable
-for use by the checkpointing library to make 
-a private heap.  This is *not* the malloc called
-by ordinary user code.
+/* give a prototype of the morecore function for the allocator */
+extern void* MORECORE(int);
+
+/* We use this function to figure out whatever the pagesize was that we told
+	the allocator to use. This allows up to later compute the correct size
+	of our alternate heap. The prototype is in image.cpp.
 */
+int condor_malloc_getpagesize(void)
+{
+	return malloc_getpagesize;
+}
 
+/* Change all usual malloc calls to be prefixed with condor_. The ckpt
+	library uses this new interface when performing compressed checkpoints.
+*/
 #define MALLOC_SYMBOL(x) condor_##x
 
 #include "malloc.c"
+
+
+
diff --git a/src/condor_ckpt/zimage.cpp b/src/condor_ckpt/zimage.cpp
new file mode 100644
index 0000000..5dede3c
--- /dev/null
+++ b/src/condor_ckpt/zimage.cpp
@@ -0,0 +1,22 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#define COMPRESS_CKPT
+
+#include "image.cpp"
diff --git a/src/condor_contrib/aviary/CMakeLists.txt b/src/condor_contrib/aviary/CMakeLists.txt
new file mode 100644
index 0000000..71baf72
--- /dev/null
+++ b/src/condor_contrib/aviary/CMakeLists.txt
@@ -0,0 +1,28 @@
+ ###############################################################
+ # 
+ # Copyright (C) 2009-2011, Red Hat, Inc.
+ # 
+ # Licensed under the Apache License, Version 2.0 (the "License"); you 
+ # may not use this file except in compliance with the License.  You may 
+ # obtain a copy of the License at 
+ # 
+ #    http://www.apache.org/licenses/LICENSE-2.0 
+ # 
+ # Unless required by applicable law or agreed to in writing, software 
+ # distributed under the License is distributed on an "AS IS" BASIS, 
+ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ # See the License for the specific language governing permissions and 
+ # limitations under the License. 
+ # 
+ ############################################################### 
+
+if (LINUX)
+	option(WITH_AVIARY "Support for aviary SOAP plugins" ON)
+endif()
+
+if ( WITH_AVIARY AND HAVE_EXT_WSO2 )
+ 
+ include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/src ${CMAKE_CURRENT_BINARY_DIR}/src ${CMAKE_CURRENT_SOURCE_DIR}/include ${WSO2_INCLUDES})
+ add_subdirectory( ${CMAKE_CURRENT_SOURCE_DIR}/src )
+
+endif()
\ No newline at end of file
diff --git a/src/condor_contrib/aviary/README b/src/condor_contrib/aviary/README
new file mode 100644
index 0000000..400943b
--- /dev/null
+++ b/src/condor_contrib/aviary/README
@@ -0,0 +1,2 @@
+Aviary - Simplified RPC Interface for Condor
+--------------------------------------------
diff --git a/src/condor_contrib/aviary/author.txt b/src/condor_contrib/aviary/author.txt
new file mode 100644
index 0000000..7b62f15
--- /dev/null
+++ b/src/condor_contrib/aviary/author.txt
@@ -0,0 +1,3 @@
+author: Peter MacKinnon
+organization: Red Hat Inc.
+e-mail: pmackinn@redhat.com
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ArchType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ArchType.cpp
new file mode 100644
index 0000000..deb2802
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ArchType.cpp
@@ -0,0 +1,354 @@
+
+
+        /**
+         * ArchType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ArchType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the ArchType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::ArchType::ArchType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_ArchType;
+                
+            isValidArchType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ArchType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::ArchType::ArchType(std::string arg_ArchType)
+        {
+             
+                   qname = NULL;
+             
+                 property_ArchType;
+             
+            isValidArchType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ArchType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ArchType = arg_ArchType;
+            
+        }
+        AviaryCommon::ArchType::~ArchType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            ArchType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setArchType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::ArchType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element ArchType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ArchType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ArchType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::ArchType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_ArchType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_ArchType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ArchType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ArchType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::ArchType::getProperty1()
+            {
+                return getArchType();
+            }
+
+            /**
+             * getter for ArchType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ArchType::getArchType()
+             {
+                return property_ArchType;
+             }
+
+            /**
+             * setter for ArchType
+             */
+            bool WSF_CALL
+            AviaryCommon::ArchType::setArchType(
+                    const std::string  arg_ArchType)
+             {
+                
+
+                if(isValidArchType &&
+                        arg_ArchType == property_ArchType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_ArchType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ArchType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetArchType();
+
+                
+                        property_ArchType = std::string(arg_ArchType.c_str());
+                        isValidArchType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for ArchType.
+             */
+             ADBArchTypeEnum WSF_CALL
+             AviaryCommon::ArchType::getArchTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_ArchType.c_str(), "INTEL") == 0)
+                    return ArchType_INTEL;
+             
+                 if (axutil_strcmp(property_ArchType.c_str(), "X86_64") == 0)
+                    return ArchType_X86_64;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBArchTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for ArchType.
+             */
+             bool WSF_CALL
+            AviaryCommon::ArchType::setArchTypeEnum(const ADBArchTypeEnum  arg_ArchType)
+             {
+                
+
+                
+                resetArchType();
+
+                   
+                   switch (arg_ArchType)
+                   {
+                     
+                       case ArchType_INTEL :
+                            property_ArchType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "INTEL");
+                          break;
+                     
+                       case ArchType_X86_64 :
+                            property_ArchType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "X86_64");
+                          break;
+                     
+                     
+                       default:
+                          isValidArchType = false;
+                          property_ArchType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting ArchType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_ArchType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidArchType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for ArchType
+            */
+           bool WSF_CALL
+           AviaryCommon::ArchType::resetArchType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidArchType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ArchType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ArchType::isArchTypeNil()
+           {
+               return !isValidArchType;
+           }
+
+           /**
+            * Set ArchType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ArchType::setArchTypeNil()
+           {
+               return resetArchType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attribute.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attribute.cpp
new file mode 100644
index 0000000..1047122
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attribute.cpp
@@ -0,0 +1,1022 @@
+
+
+        /**
+         * Attribute.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_Attribute.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = Attribute
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::Attribute::Attribute()
+        {
+
+        
+                    property_Name;
+                
+            isValidName  = false;
+        
+                property_Type  = NULL;
+              
+            isValidType  = false;
+        
+                    property_Value;
+                
+            isValidValue  = false;
+        
+        }
+
+       AviaryCommon::Attribute::Attribute(std::string arg_Name,AviaryCommon::AttributeType* arg_Type,std::string arg_Value)
+        {
+             
+                 property_Name;
+             
+            isValidName  = true;
+            
+               property_Type  = NULL;
+             
+            isValidType  = true;
+            
+                 property_Value;
+             
+            isValidValue  = true;
+            
+                    property_Name = arg_Name;
+            
+                    property_Type = arg_Type;
+            
+                    property_Value = arg_Value;
+            
+        }
+        AviaryCommon::Attribute::~Attribute()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::Attribute::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building name element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setName(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setName("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element name missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building type element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::AttributeType* element = new AviaryCommon::AttributeType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element type");
+                                      }
+                                      else
+                                      {
+                                          status = setType(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building value element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "value", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setValue(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element value");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setValue("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for value ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element value missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::Attribute::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::Attribute::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::Attribute::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t *text_value_1;
+                    axis2_char_t *text_value_1_temp;
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidName)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property name");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_1 = (axis2_char_t*)property_Name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_1_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_1, true);
+                           if (text_value_1_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1_temp, axutil_strlen(text_value_1_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_1_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1, axutil_strlen(text_value_1));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidType)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stype",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stype>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Type->serialize(current_node, parent_element,
+                                                                                 property_Type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidValue)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property value");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("value"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("value")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing value element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_Value.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for name by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::Attribute::getProperty1()
+            {
+                return getName();
+            }
+
+            /**
+             * getter for name.
+             */
+            std::string WSF_CALL
+            AviaryCommon::Attribute::getName()
+             {
+                return property_Name;
+             }
+
+            /**
+             * setter for name
+             */
+            bool WSF_CALL
+            AviaryCommon::Attribute::setName(
+                    const std::string  arg_Name)
+             {
+                
+
+                if(isValidName &&
+                        arg_Name == property_Name)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Name.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"name is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetName();
+
+                
+                        property_Name = std::string(arg_Name.c_str());
+                        isValidName = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for name
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::resetName()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidName = false; 
+               return true;
+           }
+
+           /**
+            * Check whether name is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::isNameNil()
+           {
+               return !isValidName;
+           }
+
+           /**
+            * Set name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::setNameNil()
+           {
+               return resetName();
+           }
+
+           
+
+            /**
+             * Getter for type by  Property Number 2
+             */
+            AviaryCommon::AttributeType* WSF_CALL
+            AviaryCommon::Attribute::getProperty2()
+            {
+                return getType();
+            }
+
+            /**
+             * getter for type.
+             */
+            AviaryCommon::AttributeType* WSF_CALL
+            AviaryCommon::Attribute::getType()
+             {
+                return property_Type;
+             }
+
+            /**
+             * setter for type
+             */
+            bool WSF_CALL
+            AviaryCommon::Attribute::setType(
+                    AviaryCommon::AttributeType*  arg_Type)
+             {
+                
+
+                if(isValidType &&
+                        arg_Type == property_Type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetType();
+
+                
+                    if(NULL == arg_Type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Type = arg_Type;
+                        isValidType = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for type
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::resetType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Type != NULL)
+                {
+                   
+                   
+                         delete  property_Type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::isTypeNil()
+           {
+               return !isValidType;
+           }
+
+           /**
+            * Set type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::setTypeNil()
+           {
+               return resetType();
+           }
+
+           
+
+            /**
+             * Getter for value by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryCommon::Attribute::getProperty3()
+            {
+                return getValue();
+            }
+
+            /**
+             * getter for value.
+             */
+            std::string WSF_CALL
+            AviaryCommon::Attribute::getValue()
+             {
+                return property_Value;
+             }
+
+            /**
+             * setter for value
+             */
+            bool WSF_CALL
+            AviaryCommon::Attribute::setValue(
+                    const std::string  arg_Value)
+             {
+                
+
+                if(isValidValue &&
+                        arg_Value == property_Value)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Value.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"value is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetValue();
+
+                
+                        property_Value = std::string(arg_Value.c_str());
+                        isValidValue = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for value
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::resetValue()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidValue = false; 
+               return true;
+           }
+
+           /**
+            * Check whether value is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::isValueNil()
+           {
+               return !isValidValue;
+           }
+
+           /**
+            * Set value to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::setValueNil()
+           {
+               return resetValue();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_AttributeType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_AttributeType.cpp
new file mode 100644
index 0000000..7495e14
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_AttributeType.cpp
@@ -0,0 +1,389 @@
+
+
+        /**
+         * AttributeType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_AttributeType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the AttributeType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::AttributeType::AttributeType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_AttributeType;
+                
+            isValidAttributeType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "AttributeType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::AttributeType::AttributeType(std::string arg_AttributeType)
+        {
+             
+                   qname = NULL;
+             
+                 property_AttributeType;
+             
+            isValidAttributeType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "AttributeType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_AttributeType = arg_AttributeType;
+            
+        }
+        AviaryCommon::AttributeType::~AttributeType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            AttributeType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setAttributeType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::AttributeType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element AttributeType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::AttributeType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::AttributeType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::AttributeType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_AttributeType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_AttributeType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::AttributeType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for AttributeType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::AttributeType::getProperty1()
+            {
+                return getAttributeType();
+            }
+
+            /**
+             * getter for AttributeType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::AttributeType::getAttributeType()
+             {
+                return property_AttributeType;
+             }
+
+            /**
+             * setter for AttributeType
+             */
+            bool WSF_CALL
+            AviaryCommon::AttributeType::setAttributeType(
+                    const std::string  arg_AttributeType)
+             {
+                
+
+                if(isValidAttributeType &&
+                        arg_AttributeType == property_AttributeType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_AttributeType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"AttributeType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetAttributeType();
+
+                
+                        property_AttributeType = std::string(arg_AttributeType.c_str());
+                        isValidAttributeType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for AttributeType.
+             */
+             ADBAttributeTypeEnum WSF_CALL
+             AviaryCommon::AttributeType::getAttributeTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_AttributeType.c_str(), "INTEGER") == 0)
+                    return AttributeType_INTEGER;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "FLOAT") == 0)
+                    return AttributeType_FLOAT;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "STRING") == 0)
+                    return AttributeType_STRING;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "EXPRESSION") == 0)
+                    return AttributeType_EXPRESSION;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "BOOLEAN") == 0)
+                    return AttributeType_BOOLEAN;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "UNDEFINED") == 0)
+                    return AttributeType_UNDEFINED;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "ERROR") == 0)
+                    return AttributeType_ERROR;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBAttributeTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for AttributeType.
+             */
+             bool WSF_CALL
+            AviaryCommon::AttributeType::setAttributeTypeEnum(const ADBAttributeTypeEnum  arg_AttributeType)
+             {
+                
+
+                
+                resetAttributeType();
+
+                   
+                   switch (arg_AttributeType)
+                   {
+                     
+                       case AttributeType_INTEGER :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "INTEGER");
+                          break;
+                     
+                       case AttributeType_FLOAT :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "FLOAT");
+                          break;
+                     
+                       case AttributeType_STRING :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "STRING");
+                          break;
+                     
+                       case AttributeType_EXPRESSION :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "EXPRESSION");
+                          break;
+                     
+                       case AttributeType_BOOLEAN :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "BOOLEAN");
+                          break;
+                     
+                       case AttributeType_UNDEFINED :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "UNDEFINED");
+                          break;
+                     
+                       case AttributeType_ERROR :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "ERROR");
+                          break;
+                     
+                     
+                       default:
+                          isValidAttributeType = false;
+                          property_AttributeType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting AttributeType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_AttributeType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidAttributeType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for AttributeType
+            */
+           bool WSF_CALL
+           AviaryCommon::AttributeType::resetAttributeType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidAttributeType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether AttributeType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::AttributeType::isAttributeTypeNil()
+           {
+               return !isValidAttributeType;
+           }
+
+           /**
+            * Set AttributeType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::AttributeType::setAttributeTypeNil()
+           {
+               return resetAttributeType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attributes.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attributes.cpp
new file mode 100644
index 0000000..f2dc649
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attributes.cpp
@@ -0,0 +1,735 @@
+
+
+        /**
+         * Attributes.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_Attributes.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = Attributes
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::Attributes::Attributes()
+        {
+
+        
+                property_Attrs  = NULL;
+              
+            isValidAttrs  = false;
+        
+        }
+
+       AviaryCommon::Attributes::Attributes(std::vector<AviaryCommon::Attribute*>* arg_Attrs)
+        {
+             
+               property_Attrs  = NULL;
+             
+            isValidAttrs  = true;
+            
+                    property_Attrs = arg_Attrs;
+            
+        }
+        AviaryCommon::Attributes::~Attributes()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::Attributes::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+                       { 
+                    /*
+                     * building Attrs array
+                     */
+                       std::vector<AviaryCommon::Attribute*>* arr_list =new std::vector<AviaryCommon::Attribute*>();
+                   
+
+                     
+                     /*
+                      * building attrs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "attrs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("attrs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::Attribute* element = new AviaryCommon::Attribute();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element attrs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for attrs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"attrs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setAttrs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::Attributes::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::Attributes::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::Attributes::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidAttrs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("attrs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("attrs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Attrs array
+                      */
+                     if (property_Attrs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sattrs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sattrs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Attrs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::Attribute* element = (*property_Attrs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing attrs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for attrs by  Property Number 1
+             */
+            std::vector<AviaryCommon::Attribute*>* WSF_CALL
+            AviaryCommon::Attributes::getProperty1()
+            {
+                return getAttrs();
+            }
+
+            /**
+             * getter for attrs.
+             */
+            std::vector<AviaryCommon::Attribute*>* WSF_CALL
+            AviaryCommon::Attributes::getAttrs()
+             {
+                return property_Attrs;
+             }
+
+            /**
+             * setter for attrs
+             */
+            bool WSF_CALL
+            AviaryCommon::Attributes::setAttrs(
+                    std::vector<AviaryCommon::Attribute*>*  arg_Attrs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidAttrs &&
+                        arg_Attrs == property_Attrs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Attrs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"attrs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Attrs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetAttrs();
+
+                
+                    if(NULL == arg_Attrs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Attrs = arg_Attrs;
+                        if(non_nil_exists)
+                        {
+                            isValidAttrs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of attrs.
+             */
+            AviaryCommon::Attribute* WSF_CALL
+            AviaryCommon::Attributes::getAttrsAt(int i)
+            {
+                AviaryCommon::Attribute* ret_val;
+                if(property_Attrs == NULL)
+                {
+                    return (AviaryCommon::Attribute*)0;
+                }
+                ret_val =   (*property_Attrs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of attrs.
+             */
+           bool WSF_CALL
+            AviaryCommon::Attributes::setAttrsAt(int i,
+                    AviaryCommon::Attribute* arg_Attrs)
+            {
+                 AviaryCommon::Attribute* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidAttrs &&
+                    property_Attrs &&
+                  
+                    arg_Attrs == (*property_Attrs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Attrs == NULL)
+                {
+                    property_Attrs = new std::vector<AviaryCommon::Attribute*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Attrs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidAttrs = true;
+                        (*property_Attrs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Attrs)[i] = arg_Attrs;
+                  
+
+               isValidAttrs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to attrs.
+             */
+            bool WSF_CALL
+            AviaryCommon::Attributes::addAttrs(
+                    AviaryCommon::Attribute* arg_Attrs)
+             {
+
+                
+                    if( NULL == arg_Attrs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Attrs == NULL)
+                {
+                    property_Attrs = new std::vector<AviaryCommon::Attribute*>();
+                }
+              
+               property_Attrs->push_back(arg_Attrs);
+              
+                isValidAttrs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the attrs array.
+             */
+            int WSF_CALL
+            AviaryCommon::Attributes::sizeofAttrs()
+            {
+
+                if(property_Attrs == NULL)
+                {
+                    return 0;
+                }
+                return property_Attrs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryCommon::Attributes::removeAttrsAt(int i)
+            {
+                return setAttrsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for attrs
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::resetAttrs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Attrs != NULL)
+                {
+                  std::vector<AviaryCommon::Attribute*>::iterator it =  property_Attrs->begin();
+                  for( ; it <  property_Attrs->end() ; ++it)
+                  {
+                     AviaryCommon::Attribute* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Attrs)
+                 delete property_Attrs;
+                
+               isValidAttrs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether attrs is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::isAttrsNil()
+           {
+               return !isValidAttrs;
+           }
+
+           /**
+            * Set attrs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::setAttrsNil()
+           {
+               return resetAttrs();
+           }
+
+           
+           /**
+            * Check whether attrs is nill at i
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::isAttrsNilAt(int i)
+           {
+               return (isValidAttrs == false ||
+                       NULL == property_Attrs ||
+                     NULL == (*property_Attrs)[i]);
+            }
+
+           /**
+            * Set attrs to nil at i
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::setAttrsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Attrs == NULL ||
+                            isValidAttrs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Attrs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Attrs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of attrs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Attrs == NULL)
+                {
+                    isValidAttrs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::Attribute* element = (*property_Attrs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidAttrs = false;
+                        (*property_Attrs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Attrs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraint.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraint.cpp
new file mode 100644
index 0000000..f17f65c
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraint.cpp
@@ -0,0 +1,717 @@
+
+
+        /**
+         * JobConstraint.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobConstraint.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobConstraint
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobConstraint::JobConstraint()
+        {
+
+        
+                property_Type  = NULL;
+              
+            isValidType  = false;
+        
+                    property_Value;
+                
+            isValidValue  = false;
+        
+        }
+
+       AviaryCommon::JobConstraint::JobConstraint(AviaryCommon::JobConstraintType* arg_Type,std::string arg_Value)
+        {
+             
+               property_Type  = NULL;
+             
+            isValidType  = true;
+            
+                 property_Value;
+             
+            isValidValue  = true;
+            
+                    property_Type = arg_Type;
+            
+                    property_Value = arg_Value;
+            
+        }
+        AviaryCommon::JobConstraint::~JobConstraint()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobConstraint::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building type element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobConstraintType* element = new AviaryCommon::JobConstraintType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element type");
+                                      }
+                                      else
+                                      {
+                                          status = setType(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building value element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "value", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setValue(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element value");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setValue("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for value ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element value missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobConstraint::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobConstraint::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobConstraint::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidType)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stype",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stype>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Type->serialize(current_node, parent_element,
+                                                                                 property_Type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidValue)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property value");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("value"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("value")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing value element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Value.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for type by  Property Number 1
+             */
+            AviaryCommon::JobConstraintType* WSF_CALL
+            AviaryCommon::JobConstraint::getProperty1()
+            {
+                return getType();
+            }
+
+            /**
+             * getter for type.
+             */
+            AviaryCommon::JobConstraintType* WSF_CALL
+            AviaryCommon::JobConstraint::getType()
+             {
+                return property_Type;
+             }
+
+            /**
+             * setter for type
+             */
+            bool WSF_CALL
+            AviaryCommon::JobConstraint::setType(
+                    AviaryCommon::JobConstraintType*  arg_Type)
+             {
+                
+
+                if(isValidType &&
+                        arg_Type == property_Type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetType();
+
+                
+                    if(NULL == arg_Type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Type = arg_Type;
+                        isValidType = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for type
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::resetType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Type != NULL)
+                {
+                   
+                   
+                         delete  property_Type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::isTypeNil()
+           {
+               return !isValidType;
+           }
+
+           /**
+            * Set type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::setTypeNil()
+           {
+               return resetType();
+           }
+
+           
+
+            /**
+             * Getter for value by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobConstraint::getProperty2()
+            {
+                return getValue();
+            }
+
+            /**
+             * getter for value.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobConstraint::getValue()
+             {
+                return property_Value;
+             }
+
+            /**
+             * setter for value
+             */
+            bool WSF_CALL
+            AviaryCommon::JobConstraint::setValue(
+                    const std::string  arg_Value)
+             {
+                
+
+                if(isValidValue &&
+                        arg_Value == property_Value)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Value.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"value is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetValue();
+
+                
+                        property_Value = std::string(arg_Value.c_str());
+                        isValidValue = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for value
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::resetValue()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidValue = false; 
+               return true;
+           }
+
+           /**
+            * Check whether value is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::isValueNil()
+           {
+               return !isValidValue;
+           }
+
+           /**
+            * Set value to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::setValueNil()
+           {
+               return resetValue();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraintType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraintType.cpp
new file mode 100644
index 0000000..b5c7161
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraintType.cpp
@@ -0,0 +1,361 @@
+
+
+        /**
+         * JobConstraintType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobConstraintType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the JobConstraintType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::JobConstraintType::JobConstraintType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_JobConstraintType;
+                
+            isValidJobConstraintType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "JobConstraintType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::JobConstraintType::JobConstraintType(std::string arg_JobConstraintType)
+        {
+             
+                   qname = NULL;
+             
+                 property_JobConstraintType;
+             
+            isValidJobConstraintType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "JobConstraintType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_JobConstraintType = arg_JobConstraintType;
+            
+        }
+        AviaryCommon::JobConstraintType::~JobConstraintType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            JobConstraintType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setJobConstraintType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobConstraintType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element JobConstraintType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobConstraintType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobConstraintType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::JobConstraintType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_JobConstraintType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_JobConstraintType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobConstraintType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for JobConstraintType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobConstraintType::getProperty1()
+            {
+                return getJobConstraintType();
+            }
+
+            /**
+             * getter for JobConstraintType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobConstraintType::getJobConstraintType()
+             {
+                return property_JobConstraintType;
+             }
+
+            /**
+             * setter for JobConstraintType
+             */
+            bool WSF_CALL
+            AviaryCommon::JobConstraintType::setJobConstraintType(
+                    const std::string  arg_JobConstraintType)
+             {
+                
+
+                if(isValidJobConstraintType &&
+                        arg_JobConstraintType == property_JobConstraintType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_JobConstraintType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"JobConstraintType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJobConstraintType();
+
+                
+                        property_JobConstraintType = std::string(arg_JobConstraintType.c_str());
+                        isValidJobConstraintType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for JobConstraintType.
+             */
+             ADBJobConstraintTypeEnum WSF_CALL
+             AviaryCommon::JobConstraintType::getJobConstraintTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_JobConstraintType.c_str(), "CMD") == 0)
+                    return JobConstraintType_CMD;
+             
+                 if (axutil_strcmp(property_JobConstraintType.c_str(), "ARGS") == 0)
+                    return JobConstraintType_ARGS;
+             
+                 if (axutil_strcmp(property_JobConstraintType.c_str(), "OWNER") == 0)
+                    return JobConstraintType_OWNER;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBJobConstraintTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for JobConstraintType.
+             */
+             bool WSF_CALL
+            AviaryCommon::JobConstraintType::setJobConstraintTypeEnum(const ADBJobConstraintTypeEnum  arg_JobConstraintType)
+             {
+                
+
+                
+                resetJobConstraintType();
+
+                   
+                   switch (arg_JobConstraintType)
+                   {
+                     
+                       case JobConstraintType_CMD :
+                            property_JobConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "CMD");
+                          break;
+                     
+                       case JobConstraintType_ARGS :
+                            property_JobConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "ARGS");
+                          break;
+                     
+                       case JobConstraintType_OWNER :
+                            property_JobConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "OWNER");
+                          break;
+                     
+                     
+                       default:
+                          isValidJobConstraintType = false;
+                          property_JobConstraintType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting JobConstraintType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_JobConstraintType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidJobConstraintType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for JobConstraintType
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraintType::resetJobConstraintType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidJobConstraintType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether JobConstraintType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraintType::isJobConstraintTypeNil()
+           {
+               return !isValidJobConstraintType;
+           }
+
+           /**
+            * Set JobConstraintType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraintType::setJobConstraintTypeNil()
+           {
+               return resetJobConstraintType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobData.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobData.cpp
new file mode 100644
index 0000000..fd24b98
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobData.cpp
@@ -0,0 +1,679 @@
+
+
+        /**
+         * JobData.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobData.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobData
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobData::JobData()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Type  = NULL;
+              
+            isValidType  = false;
+        
+        }
+
+       AviaryCommon::JobData::JobData(AviaryCommon::JobID* arg_Id,AviaryCommon::JobDataType* arg_Type)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Type  = NULL;
+             
+            isValidType  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Type = arg_Type;
+            
+        }
+        AviaryCommon::JobData::~JobData()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobData::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building type element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobDataType* element = new AviaryCommon::JobDataType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element type");
+                                      }
+                                      else
+                                      {
+                                          status = setType(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobData::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobData::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobData::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidType)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stype",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stype>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Type->serialize(current_node, parent_element,
+                                                                                 property_Type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobData::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobData::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::JobData::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for type by  Property Number 2
+             */
+            AviaryCommon::JobDataType* WSF_CALL
+            AviaryCommon::JobData::getProperty2()
+            {
+                return getType();
+            }
+
+            /**
+             * getter for type.
+             */
+            AviaryCommon::JobDataType* WSF_CALL
+            AviaryCommon::JobData::getType()
+             {
+                return property_Type;
+             }
+
+            /**
+             * setter for type
+             */
+            bool WSF_CALL
+            AviaryCommon::JobData::setType(
+                    AviaryCommon::JobDataType*  arg_Type)
+             {
+                
+
+                if(isValidType &&
+                        arg_Type == property_Type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetType();
+
+                
+                    if(NULL == arg_Type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Type = arg_Type;
+                        isValidType = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for type
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::resetType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Type != NULL)
+                {
+                   
+                   
+                         delete  property_Type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::isTypeNil()
+           {
+               return !isValidType;
+           }
+
+           /**
+            * Set type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::setTypeNil()
+           {
+               return resetType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDataType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDataType.cpp
new file mode 100644
index 0000000..6c259b7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDataType.cpp
@@ -0,0 +1,361 @@
+
+
+        /**
+         * JobDataType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobDataType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the JobDataType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::JobDataType::JobDataType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_JobDataType;
+                
+            isValidJobDataType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "JobDataType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::JobDataType::JobDataType(std::string arg_JobDataType)
+        {
+             
+                   qname = NULL;
+             
+                 property_JobDataType;
+             
+            isValidJobDataType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "JobDataType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_JobDataType = arg_JobDataType;
+            
+        }
+        AviaryCommon::JobDataType::~JobDataType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            JobDataType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setJobDataType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobDataType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element JobDataType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobDataType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobDataType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::JobDataType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_JobDataType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_JobDataType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobDataType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for JobDataType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobDataType::getProperty1()
+            {
+                return getJobDataType();
+            }
+
+            /**
+             * getter for JobDataType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobDataType::getJobDataType()
+             {
+                return property_JobDataType;
+             }
+
+            /**
+             * setter for JobDataType
+             */
+            bool WSF_CALL
+            AviaryCommon::JobDataType::setJobDataType(
+                    const std::string  arg_JobDataType)
+             {
+                
+
+                if(isValidJobDataType &&
+                        arg_JobDataType == property_JobDataType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_JobDataType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"JobDataType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJobDataType();
+
+                
+                        property_JobDataType = std::string(arg_JobDataType.c_str());
+                        isValidJobDataType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for JobDataType.
+             */
+             ADBJobDataTypeEnum WSF_CALL
+             AviaryCommon::JobDataType::getJobDataTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_JobDataType.c_str(), "ERR") == 0)
+                    return JobDataType_ERR;
+             
+                 if (axutil_strcmp(property_JobDataType.c_str(), "LOG") == 0)
+                    return JobDataType_LOG;
+             
+                 if (axutil_strcmp(property_JobDataType.c_str(), "OUT") == 0)
+                    return JobDataType_OUT;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBJobDataTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for JobDataType.
+             */
+             bool WSF_CALL
+            AviaryCommon::JobDataType::setJobDataTypeEnum(const ADBJobDataTypeEnum  arg_JobDataType)
+             {
+                
+
+                
+                resetJobDataType();
+
+                   
+                   switch (arg_JobDataType)
+                   {
+                     
+                       case JobDataType_ERR :
+                            property_JobDataType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "ERR");
+                          break;
+                     
+                       case JobDataType_LOG :
+                            property_JobDataType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "LOG");
+                          break;
+                     
+                       case JobDataType_OUT :
+                            property_JobDataType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "OUT");
+                          break;
+                     
+                     
+                       default:
+                          isValidJobDataType = false;
+                          property_JobDataType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting JobDataType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_JobDataType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidJobDataType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for JobDataType
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDataType::resetJobDataType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidJobDataType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether JobDataType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDataType::isJobDataTypeNil()
+           {
+               return !isValidJobDataType;
+           }
+
+           /**
+            * Set JobDataType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDataType::setJobDataTypeNil()
+           {
+               return resetJobDataType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDetails.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDetails.cpp
new file mode 100644
index 0000000..0848d89
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDetails.cpp
@@ -0,0 +1,927 @@
+
+
+        /**
+         * JobDetails.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobDetails.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobDetails
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobDetails::JobDetails()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                property_Details  = NULL;
+              
+            isValidDetails  = false;
+        
+        }
+
+       AviaryCommon::JobDetails::JobDetails(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,AviaryCommon::Attributes* arg_Details)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+               property_Details  = NULL;
+             
+            isValidDetails  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+                    property_Details = arg_Details;
+            
+        }
+        AviaryCommon::JobDetails::~JobDetails()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobDetails::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building details element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "details", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("details", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("details", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Attributes* element = new AviaryCommon::Attributes();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element details");
+                                      }
+                                      else
+                                      {
+                                          status = setDetails(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for details ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobDetails::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobDetails::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobDetails::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidDetails)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("details"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("details")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing details element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sdetails",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sdetails>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Details->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Details->serialize(current_node, parent_element,
+                                                                                 property_Details->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Details->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobDetails::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobDetails::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::JobDetails::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobDetails::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobDetails::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobDetails::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for details by  Property Number 3
+             */
+            AviaryCommon::Attributes* WSF_CALL
+            AviaryCommon::JobDetails::getProperty3()
+            {
+                return getDetails();
+            }
+
+            /**
+             * getter for details.
+             */
+            AviaryCommon::Attributes* WSF_CALL
+            AviaryCommon::JobDetails::getDetails()
+             {
+                return property_Details;
+             }
+
+            /**
+             * setter for details
+             */
+            bool WSF_CALL
+            AviaryCommon::JobDetails::setDetails(
+                    AviaryCommon::Attributes*  arg_Details)
+             {
+                
+
+                if(isValidDetails &&
+                        arg_Details == property_Details)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetDetails();
+
+                
+                    if(NULL == arg_Details)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Details = arg_Details;
+                        isValidDetails = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for details
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::resetDetails()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Details != NULL)
+                {
+                   
+                   
+                         delete  property_Details;
+                     
+
+                   }
+
+                
+                
+                
+               isValidDetails = false; 
+               return true;
+           }
+
+           /**
+            * Check whether details is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::isDetailsNil()
+           {
+               return !isValidDetails;
+           }
+
+           /**
+            * Set details to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::setDetailsNil()
+           {
+               return resetDetails();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobID.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobID.cpp
new file mode 100644
index 0000000..249a55b
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobID.cpp
@@ -0,0 +1,1270 @@
+
+
+        /**
+         * JobID.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobID.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobID
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobID::JobID()
+        {
+
+        
+                    property_Job;
+                
+            isValidJob  = false;
+        
+                    property_Pool;
+                
+            isValidPool  = false;
+        
+                    property_Scheduler;
+                
+            isValidScheduler  = false;
+        
+                property_Submission  = NULL;
+              
+            isValidSubmission  = false;
+        
+        }
+
+       AviaryCommon::JobID::JobID(std::string arg_Job,std::string arg_Pool,std::string arg_Scheduler,AviaryCommon::SubmissionID* arg_Submission)
+        {
+             
+                 property_Job;
+             
+            isValidJob  = true;
+            
+                 property_Pool;
+             
+            isValidPool  = true;
+            
+                 property_Scheduler;
+             
+            isValidScheduler  = true;
+            
+               property_Submission  = NULL;
+             
+            isValidSubmission  = true;
+            
+                    property_Job = arg_Job;
+            
+                    property_Pool = arg_Pool;
+            
+                    property_Scheduler = arg_Scheduler;
+            
+                    property_Submission = arg_Submission;
+            
+        }
+        AviaryCommon::JobID::~JobID()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobID::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building job element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "job", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setJob(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element job");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setJob("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for job ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element job missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building pool element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "pool", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("pool", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("pool", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setPool(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element pool");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setPool("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for pool ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building scheduler element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "scheduler", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("scheduler", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("scheduler", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setScheduler(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element scheduler");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setScheduler("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for scheduler ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building submission element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "submission", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submission", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submission", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::SubmissionID* element = new AviaryCommon::SubmissionID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element submission");
+                                      }
+                                      else
+                                      {
+                                          status = setSubmission(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for submission ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobID::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobID::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobID::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t *text_value_1;
+                    axis2_char_t *text_value_1_temp;
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t text_value_4[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJob)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property job");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("job"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("job")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing job element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sjob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sjob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_1 = (axis2_char_t*)property_Job.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_1_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_1, true);
+                           if (text_value_1_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1_temp, axutil_strlen(text_value_1_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_1_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1, axutil_strlen(text_value_1));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidPool)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("pool"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("pool")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing pool element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%spool>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%spool>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Pool.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidScheduler)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("scheduler"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("scheduler")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing scheduler element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sscheduler>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sscheduler>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_Scheduler.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidSubmission)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("submission"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("submission")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing submission element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%ssubmission",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%ssubmission>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Submission->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Submission->serialize(current_node, parent_element,
+                                                                                 property_Submission->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Submission->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for job by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getProperty1()
+            {
+                return getJob();
+            }
+
+            /**
+             * getter for job.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getJob()
+             {
+                return property_Job;
+             }
+
+            /**
+             * setter for job
+             */
+            bool WSF_CALL
+            AviaryCommon::JobID::setJob(
+                    const std::string  arg_Job)
+             {
+                
+
+                if(isValidJob &&
+                        arg_Job == property_Job)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Job.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"job is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJob();
+
+                
+                        property_Job = std::string(arg_Job.c_str());
+                        isValidJob = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for job
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::resetJob()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidJob = false; 
+               return true;
+           }
+
+           /**
+            * Check whether job is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::isJobNil()
+           {
+               return !isValidJob;
+           }
+
+           /**
+            * Set job to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::setJobNil()
+           {
+               return resetJob();
+           }
+
+           
+
+            /**
+             * Getter for pool by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getProperty2()
+            {
+                return getPool();
+            }
+
+            /**
+             * getter for pool.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getPool()
+             {
+                return property_Pool;
+             }
+
+            /**
+             * setter for pool
+             */
+            bool WSF_CALL
+            AviaryCommon::JobID::setPool(
+                    const std::string  arg_Pool)
+             {
+                
+
+                if(isValidPool &&
+                        arg_Pool == property_Pool)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPool();
+
+                
+                        property_Pool = std::string(arg_Pool.c_str());
+                        isValidPool = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for pool
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::resetPool()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPool = false; 
+               return true;
+           }
+
+           /**
+            * Check whether pool is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::isPoolNil()
+           {
+               return !isValidPool;
+           }
+
+           /**
+            * Set pool to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::setPoolNil()
+           {
+               return resetPool();
+           }
+
+           
+
+            /**
+             * Getter for scheduler by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getProperty3()
+            {
+                return getScheduler();
+            }
+
+            /**
+             * getter for scheduler.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getScheduler()
+             {
+                return property_Scheduler;
+             }
+
+            /**
+             * setter for scheduler
+             */
+            bool WSF_CALL
+            AviaryCommon::JobID::setScheduler(
+                    const std::string  arg_Scheduler)
+             {
+                
+
+                if(isValidScheduler &&
+                        arg_Scheduler == property_Scheduler)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetScheduler();
+
+                
+                        property_Scheduler = std::string(arg_Scheduler.c_str());
+                        isValidScheduler = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for scheduler
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::resetScheduler()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidScheduler = false; 
+               return true;
+           }
+
+           /**
+            * Check whether scheduler is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::isSchedulerNil()
+           {
+               return !isValidScheduler;
+           }
+
+           /**
+            * Set scheduler to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::setSchedulerNil()
+           {
+               return resetScheduler();
+           }
+
+           
+
+            /**
+             * Getter for submission by  Property Number 4
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryCommon::JobID::getProperty4()
+            {
+                return getSubmission();
+            }
+
+            /**
+             * getter for submission.
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryCommon::JobID::getSubmission()
+             {
+                return property_Submission;
+             }
+
+            /**
+             * setter for submission
+             */
+            bool WSF_CALL
+            AviaryCommon::JobID::setSubmission(
+                    AviaryCommon::SubmissionID*  arg_Submission)
+             {
+                
+
+                if(isValidSubmission &&
+                        arg_Submission == property_Submission)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetSubmission();
+
+                
+                    if(NULL == arg_Submission)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Submission = arg_Submission;
+                        isValidSubmission = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for submission
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::resetSubmission()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Submission != NULL)
+                {
+                   
+                   
+                         delete  property_Submission;
+                     
+
+                   }
+
+                
+                
+                
+               isValidSubmission = false; 
+               return true;
+           }
+
+           /**
+            * Check whether submission is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::isSubmissionNil()
+           {
+               return !isValidSubmission;
+           }
+
+           /**
+            * Set submission to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::setSubmissionNil()
+           {
+               return resetSubmission();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatus.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatus.cpp
new file mode 100644
index 0000000..bf70be7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatus.cpp
@@ -0,0 +1,927 @@
+
+
+        /**
+         * JobStatus.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobStatus.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobStatus
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobStatus::JobStatus()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                property_Job_status  = NULL;
+              
+            isValidJob_status  = false;
+        
+        }
+
+       AviaryCommon::JobStatus::JobStatus(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,AviaryCommon::JobStatusType* arg_Job_status)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+               property_Job_status  = NULL;
+             
+            isValidJob_status  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+                    property_Job_status = arg_Job_status;
+            
+        }
+        AviaryCommon::JobStatus::~JobStatus()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobStatus::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building job_status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "job_status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job_status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job_status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobStatusType* element = new AviaryCommon::JobStatusType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element job_status");
+                                      }
+                                      else
+                                      {
+                                          status = setJob_status(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for job_status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobStatus::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobStatus::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobStatus::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJob_status)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("job_status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("job_status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing job_status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sjob_status",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sjob_status>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Job_status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Job_status->serialize(current_node, parent_element,
+                                                                                 property_Job_status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Job_status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobStatus::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobStatus::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::JobStatus::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobStatus::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobStatus::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobStatus::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for job_status by  Property Number 3
+             */
+            AviaryCommon::JobStatusType* WSF_CALL
+            AviaryCommon::JobStatus::getProperty3()
+            {
+                return getJob_status();
+            }
+
+            /**
+             * getter for job_status.
+             */
+            AviaryCommon::JobStatusType* WSF_CALL
+            AviaryCommon::JobStatus::getJob_status()
+             {
+                return property_Job_status;
+             }
+
+            /**
+             * setter for job_status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobStatus::setJob_status(
+                    AviaryCommon::JobStatusType*  arg_Job_status)
+             {
+                
+
+                if(isValidJob_status &&
+                        arg_Job_status == property_Job_status)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetJob_status();
+
+                
+                    if(NULL == arg_Job_status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Job_status = arg_Job_status;
+                        isValidJob_status = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for job_status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::resetJob_status()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Job_status != NULL)
+                {
+                   
+                   
+                         delete  property_Job_status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidJob_status = false; 
+               return true;
+           }
+
+           /**
+            * Check whether job_status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::isJob_statusNil()
+           {
+               return !isValidJob_status;
+           }
+
+           /**
+            * Set job_status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::setJob_statusNil()
+           {
+               return resetJob_status();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatusType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatusType.cpp
new file mode 100644
index 0000000..278c54a
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatusType.cpp
@@ -0,0 +1,375 @@
+
+
+        /**
+         * JobStatusType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobStatusType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the JobStatusType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::JobStatusType::JobStatusType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_JobStatusType;
+                
+            isValidJobStatusType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "JobStatusType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::JobStatusType::JobStatusType(std::string arg_JobStatusType)
+        {
+             
+                   qname = NULL;
+             
+                 property_JobStatusType;
+             
+            isValidJobStatusType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "JobStatusType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_JobStatusType = arg_JobStatusType;
+            
+        }
+        AviaryCommon::JobStatusType::~JobStatusType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            JobStatusType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setJobStatusType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobStatusType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element JobStatusType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobStatusType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobStatusType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::JobStatusType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_JobStatusType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_JobStatusType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobStatusType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for JobStatusType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobStatusType::getProperty1()
+            {
+                return getJobStatusType();
+            }
+
+            /**
+             * getter for JobStatusType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobStatusType::getJobStatusType()
+             {
+                return property_JobStatusType;
+             }
+
+            /**
+             * setter for JobStatusType
+             */
+            bool WSF_CALL
+            AviaryCommon::JobStatusType::setJobStatusType(
+                    const std::string  arg_JobStatusType)
+             {
+                
+
+                if(isValidJobStatusType &&
+                        arg_JobStatusType == property_JobStatusType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_JobStatusType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"JobStatusType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJobStatusType();
+
+                
+                        property_JobStatusType = std::string(arg_JobStatusType.c_str());
+                        isValidJobStatusType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for JobStatusType.
+             */
+             ADBJobStatusTypeEnum WSF_CALL
+             AviaryCommon::JobStatusType::getJobStatusTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "IDLE") == 0)
+                    return JobStatusType_IDLE;
+             
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "RUNNING") == 0)
+                    return JobStatusType_RUNNING;
+             
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "REMOVED") == 0)
+                    return JobStatusType_REMOVED;
+             
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "COMPLETED") == 0)
+                    return JobStatusType_COMPLETED;
+             
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "HELD") == 0)
+                    return JobStatusType_HELD;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBJobStatusTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for JobStatusType.
+             */
+             bool WSF_CALL
+            AviaryCommon::JobStatusType::setJobStatusTypeEnum(const ADBJobStatusTypeEnum  arg_JobStatusType)
+             {
+                
+
+                
+                resetJobStatusType();
+
+                   
+                   switch (arg_JobStatusType)
+                   {
+                     
+                       case JobStatusType_IDLE :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "IDLE");
+                          break;
+                     
+                       case JobStatusType_RUNNING :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "RUNNING");
+                          break;
+                     
+                       case JobStatusType_REMOVED :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "REMOVED");
+                          break;
+                     
+                       case JobStatusType_COMPLETED :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "COMPLETED");
+                          break;
+                     
+                       case JobStatusType_HELD :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "HELD");
+                          break;
+                     
+                     
+                       default:
+                          isValidJobStatusType = false;
+                          property_JobStatusType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting JobStatusType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_JobStatusType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidJobStatusType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for JobStatusType
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatusType::resetJobStatusType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidJobStatusType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether JobStatusType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatusType::isJobStatusTypeNil()
+           {
+               return !isValidJobStatusType;
+           }
+
+           /**
+            * Set JobStatusType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatusType::setJobStatusTypeNil()
+           {
+               return resetJobStatusType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobSummary.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobSummary.cpp
new file mode 100644
index 0000000..9fe45ed
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobSummary.cpp
@@ -0,0 +1,3241 @@
+
+
+        /**
+         * JobSummary.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobSummary.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobSummary
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobSummary::JobSummary()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                property_Queued  = NULL;
+              
+            isValidQueued  = false;
+        
+                property_Last_update  = NULL;
+              
+            isValidLast_update  = false;
+        
+                property_Job_status  = NULL;
+              
+            isValidJob_status  = false;
+        
+                    property_Cmd;
+                
+            isValidCmd  = false;
+        
+                    property_Args1;
+                
+            isValidArgs1  = false;
+        
+                    property_Args2;
+                
+            isValidArgs2  = false;
+        
+                    property_Held;
+                
+            isValidHeld  = false;
+        
+                    property_Released;
+                
+            isValidReleased  = false;
+        
+                    property_Removed;
+                
+            isValidRemoved  = false;
+        
+        }
+
+       AviaryCommon::JobSummary::JobSummary(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,axutil_date_time_t* arg_Queued,axutil_date_time_t* arg_Last_update,AviaryCommon::JobStatusType* arg_Job_status,std::string arg_Cmd,std::string arg_Args1,std::string arg_Args2,std::string arg_Held,std::string arg_Released,std::string arg_Removed)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+               property_Queued  = NULL;
+             
+            isValidQueued  = true;
+            
+               property_Last_update  = NULL;
+             
+            isValidLast_update  = true;
+            
+               property_Job_status  = NULL;
+             
+            isValidJob_status  = true;
+            
+                 property_Cmd;
+             
+            isValidCmd  = true;
+            
+                 property_Args1;
+             
+            isValidArgs1  = true;
+            
+                 property_Args2;
+             
+            isValidArgs2  = true;
+            
+                 property_Held;
+             
+            isValidHeld  = true;
+            
+                 property_Released;
+             
+            isValidReleased  = true;
+            
+                 property_Removed;
+             
+            isValidRemoved  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+                    property_Queued = arg_Queued;
+            
+                    property_Last_update = arg_Last_update;
+            
+                    property_Job_status = arg_Job_status;
+            
+                    property_Cmd = arg_Cmd;
+            
+                    property_Args1 = arg_Args1;
+            
+                    property_Args2 = arg_Args2;
+            
+                    property_Held = arg_Held;
+            
+                    property_Released = arg_Released;
+            
+                    property_Removed = arg_Removed;
+            
+        }
+        AviaryCommon::JobSummary::~JobSummary()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobSummary::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building queued element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "queued", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("queued", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("queued", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                          axutil_date_time_t* element = axutil_date_time_create(Environment::getEnv());
+                                          status = axutil_date_time_deserialize_date_time((axutil_date_time_t*)element, Environment::getEnv(),
+                                                                          text_value);
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+                                              if(element != NULL)
+                                              {
+                                                  axutil_date_time_free(element, Environment::getEnv());
+                                              }
+					                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI ,"failed in building element queued ");
+                                          }
+                                          else
+                                          {
+                                            status = setQueued(element);
+                                          }
+                                      }
+                                      
+                                      else
+                                      {
+				                            WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "NULL value is set to a non nillable element queued");
+                                            status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for queued ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element queued missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building last_update element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "last_update", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("last_update", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("last_update", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                          axutil_date_time_t* element = axutil_date_time_create(Environment::getEnv());
+                                          status = axutil_date_time_deserialize_date_time((axutil_date_time_t*)element, Environment::getEnv(),
+                                                                          text_value);
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+                                              if(element != NULL)
+                                              {
+                                                  axutil_date_time_free(element, Environment::getEnv());
+                                              }
+					                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI ,"failed in building element last_update ");
+                                          }
+                                          else
+                                          {
+                                            status = setLast_update(element);
+                                          }
+                                      }
+                                      
+                                      else
+                                      {
+				                            WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "NULL value is set to a non nillable element last_update");
+                                            status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for last_update ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element last_update missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building job_status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "job_status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job_status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job_status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobStatusType* element = new AviaryCommon::JobStatusType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element job_status");
+                                      }
+                                      else
+                                      {
+                                          status = setJob_status(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for job_status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element job_status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building cmd element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "cmd", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("cmd", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("cmd", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setCmd(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element cmd");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setCmd("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for cmd ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element cmd missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building args1 element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "args1", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args1", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args1", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setArgs1(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element args1");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setArgs1("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for args1 ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building args2 element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "args2", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args2", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args2", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setArgs2(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element args2");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setArgs2("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for args2 ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building held element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "held", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("held", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("held", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setHeld(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element held");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setHeld("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for held ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building released element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "released", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("released", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("released", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setReleased(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element released");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setReleased("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for released ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building removed element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "removed", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("removed", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("removed", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setRemoved(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element removed");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setRemoved("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for removed ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobSummary::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobSummary::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobSummary::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t *text_value_4;
+                    axis2_char_t *text_value_4_temp;
+                    
+                    axis2_char_t text_value_5[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_6;
+                    axis2_char_t *text_value_6_temp;
+                    
+                    axis2_char_t *text_value_7;
+                    axis2_char_t *text_value_7_temp;
+                    
+                    axis2_char_t *text_value_8;
+                    axis2_char_t *text_value_8_temp;
+                    
+                    axis2_char_t *text_value_9;
+                    axis2_char_t *text_value_9_temp;
+                    
+                    axis2_char_t *text_value_10;
+                    axis2_char_t *text_value_10_temp;
+                    
+                    axis2_char_t *text_value_11;
+                    axis2_char_t *text_value_11_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidQueued)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property queued");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("queued"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("queued")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing queued element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%squeued>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%squeued>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                          text_value_3 = axutil_date_time_serialize_date_time(property_Queued, Environment::getEnv());
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidLast_update)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property last_update");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("last_update"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("last_update")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing last_update element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%slast_update>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%slast_update>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                          text_value_4 = axutil_date_time_serialize_date_time(property_Last_update, Environment::getEnv());
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJob_status)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property job_status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("job_status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("job_status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing job_status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sjob_status",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sjob_status>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Job_status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Job_status->serialize(current_node, parent_element,
+                                                                                 property_Job_status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Job_status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCmd)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property cmd");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("cmd"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("cmd")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing cmd element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scmd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scmd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_6 = (axis2_char_t*)property_Cmd.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_6_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_6, true);
+                           if (text_value_6_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_6_temp, axutil_strlen(text_value_6_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_6_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_6, axutil_strlen(text_value_6));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidArgs1)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("args1"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("args1")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing args1 element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sargs1>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sargs1>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_7 = (axis2_char_t*)property_Args1.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_7_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_7, true);
+                           if (text_value_7_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_7_temp, axutil_strlen(text_value_7_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_7_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_7, axutil_strlen(text_value_7));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidArgs2)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("args2"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("args2")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing args2 element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sargs2>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sargs2>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_8 = (axis2_char_t*)property_Args2.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_8_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_8, true);
+                           if (text_value_8_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_8_temp, axutil_strlen(text_value_8_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_8_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_8, axutil_strlen(text_value_8));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidHeld)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("held"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("held")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing held element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sheld>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sheld>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_9 = (axis2_char_t*)property_Held.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_9_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_9, true);
+                           if (text_value_9_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_9_temp, axutil_strlen(text_value_9_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_9_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_9, axutil_strlen(text_value_9));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidReleased)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("released"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("released")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing released element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sreleased>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sreleased>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_10 = (axis2_char_t*)property_Released.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_10_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_10, true);
+                           if (text_value_10_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_10_temp, axutil_strlen(text_value_10_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_10_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_10, axutil_strlen(text_value_10));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidRemoved)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("removed"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("removed")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing removed element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sremoved>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sremoved>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_11 = (axis2_char_t*)property_Removed.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_11_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_11, true);
+                           if (text_value_11_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_11_temp, axutil_strlen(text_value_11_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_11_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_11, axutil_strlen(text_value_11));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobSummary::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobSummary::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobSummary::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobSummary::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for queued by  Property Number 3
+             */
+            axutil_date_time_t* WSF_CALL
+            AviaryCommon::JobSummary::getProperty3()
+            {
+                return getQueued();
+            }
+
+            /**
+             * getter for queued.
+             */
+            axutil_date_time_t* WSF_CALL
+            AviaryCommon::JobSummary::getQueued()
+             {
+                return property_Queued;
+             }
+
+            /**
+             * setter for queued
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setQueued(
+                    axutil_date_time_t*  arg_Queued)
+             {
+                
+
+                if(isValidQueued &&
+                        arg_Queued == property_Queued)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Queued)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"queued is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetQueued();
+
+                
+                    if(NULL == arg_Queued)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Queued = arg_Queued;
+                        isValidQueued = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for queued
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetQueued()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Queued != NULL)
+                {
+                   
+                   
+                      axutil_date_time_free(property_Queued, Environment::getEnv());
+                         property_Queued = NULL;
+                     
+
+                   }
+
+                
+                
+                
+               isValidQueued = false; 
+               return true;
+           }
+
+           /**
+            * Check whether queued is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isQueuedNil()
+           {
+               return !isValidQueued;
+           }
+
+           /**
+            * Set queued to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setQueuedNil()
+           {
+               return resetQueued();
+           }
+
+           
+
+            /**
+             * Getter for last_update by  Property Number 4
+             */
+            axutil_date_time_t* WSF_CALL
+            AviaryCommon::JobSummary::getProperty4()
+            {
+                return getLast_update();
+            }
+
+            /**
+             * getter for last_update.
+             */
+            axutil_date_time_t* WSF_CALL
+            AviaryCommon::JobSummary::getLast_update()
+             {
+                return property_Last_update;
+             }
+
+            /**
+             * setter for last_update
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setLast_update(
+                    axutil_date_time_t*  arg_Last_update)
+             {
+                
+
+                if(isValidLast_update &&
+                        arg_Last_update == property_Last_update)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Last_update)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"last_update is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetLast_update();
+
+                
+                    if(NULL == arg_Last_update)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Last_update = arg_Last_update;
+                        isValidLast_update = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for last_update
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetLast_update()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Last_update != NULL)
+                {
+                   
+                   
+                      axutil_date_time_free(property_Last_update, Environment::getEnv());
+                         property_Last_update = NULL;
+                     
+
+                   }
+
+                
+                
+                
+               isValidLast_update = false; 
+               return true;
+           }
+
+           /**
+            * Check whether last_update is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isLast_updateNil()
+           {
+               return !isValidLast_update;
+           }
+
+           /**
+            * Set last_update to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setLast_updateNil()
+           {
+               return resetLast_update();
+           }
+
+           
+
+            /**
+             * Getter for job_status by  Property Number 5
+             */
+            AviaryCommon::JobStatusType* WSF_CALL
+            AviaryCommon::JobSummary::getProperty5()
+            {
+                return getJob_status();
+            }
+
+            /**
+             * getter for job_status.
+             */
+            AviaryCommon::JobStatusType* WSF_CALL
+            AviaryCommon::JobSummary::getJob_status()
+             {
+                return property_Job_status;
+             }
+
+            /**
+             * setter for job_status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setJob_status(
+                    AviaryCommon::JobStatusType*  arg_Job_status)
+             {
+                
+
+                if(isValidJob_status &&
+                        arg_Job_status == property_Job_status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Job_status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"job_status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJob_status();
+
+                
+                    if(NULL == arg_Job_status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Job_status = arg_Job_status;
+                        isValidJob_status = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for job_status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetJob_status()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Job_status != NULL)
+                {
+                   
+                   
+                         delete  property_Job_status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidJob_status = false; 
+               return true;
+           }
+
+           /**
+            * Check whether job_status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isJob_statusNil()
+           {
+               return !isValidJob_status;
+           }
+
+           /**
+            * Set job_status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setJob_statusNil()
+           {
+               return resetJob_status();
+           }
+
+           
+
+            /**
+             * Getter for cmd by  Property Number 6
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty6()
+            {
+                return getCmd();
+            }
+
+            /**
+             * getter for cmd.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getCmd()
+             {
+                return property_Cmd;
+             }
+
+            /**
+             * setter for cmd
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setCmd(
+                    const std::string  arg_Cmd)
+             {
+                
+
+                if(isValidCmd &&
+                        arg_Cmd == property_Cmd)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Cmd.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"cmd is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetCmd();
+
+                
+                        property_Cmd = std::string(arg_Cmd.c_str());
+                        isValidCmd = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for cmd
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetCmd()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidCmd = false; 
+               return true;
+           }
+
+           /**
+            * Check whether cmd is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isCmdNil()
+           {
+               return !isValidCmd;
+           }
+
+           /**
+            * Set cmd to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setCmdNil()
+           {
+               return resetCmd();
+           }
+
+           
+
+            /**
+             * Getter for args1 by  Property Number 7
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty7()
+            {
+                return getArgs1();
+            }
+
+            /**
+             * getter for args1.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getArgs1()
+             {
+                return property_Args1;
+             }
+
+            /**
+             * setter for args1
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setArgs1(
+                    const std::string  arg_Args1)
+             {
+                
+
+                if(isValidArgs1 &&
+                        arg_Args1 == property_Args1)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetArgs1();
+
+                
+                        property_Args1 = std::string(arg_Args1.c_str());
+                        isValidArgs1 = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for args1
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetArgs1()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidArgs1 = false; 
+               return true;
+           }
+
+           /**
+            * Check whether args1 is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isArgs1Nil()
+           {
+               return !isValidArgs1;
+           }
+
+           /**
+            * Set args1 to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setArgs1Nil()
+           {
+               return resetArgs1();
+           }
+
+           
+
+            /**
+             * Getter for args2 by  Property Number 8
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty8()
+            {
+                return getArgs2();
+            }
+
+            /**
+             * getter for args2.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getArgs2()
+             {
+                return property_Args2;
+             }
+
+            /**
+             * setter for args2
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setArgs2(
+                    const std::string  arg_Args2)
+             {
+                
+
+                if(isValidArgs2 &&
+                        arg_Args2 == property_Args2)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetArgs2();
+
+                
+                        property_Args2 = std::string(arg_Args2.c_str());
+                        isValidArgs2 = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for args2
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetArgs2()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidArgs2 = false; 
+               return true;
+           }
+
+           /**
+            * Check whether args2 is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isArgs2Nil()
+           {
+               return !isValidArgs2;
+           }
+
+           /**
+            * Set args2 to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setArgs2Nil()
+           {
+               return resetArgs2();
+           }
+
+           
+
+            /**
+             * Getter for held by  Property Number 9
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty9()
+            {
+                return getHeld();
+            }
+
+            /**
+             * getter for held.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getHeld()
+             {
+                return property_Held;
+             }
+
+            /**
+             * setter for held
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setHeld(
+                    const std::string  arg_Held)
+             {
+                
+
+                if(isValidHeld &&
+                        arg_Held == property_Held)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetHeld();
+
+                
+                        property_Held = std::string(arg_Held.c_str());
+                        isValidHeld = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for held
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetHeld()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidHeld = false; 
+               return true;
+           }
+
+           /**
+            * Check whether held is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isHeldNil()
+           {
+               return !isValidHeld;
+           }
+
+           /**
+            * Set held to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setHeldNil()
+           {
+               return resetHeld();
+           }
+
+           
+
+            /**
+             * Getter for released by  Property Number 10
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty10()
+            {
+                return getReleased();
+            }
+
+            /**
+             * getter for released.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getReleased()
+             {
+                return property_Released;
+             }
+
+            /**
+             * setter for released
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setReleased(
+                    const std::string  arg_Released)
+             {
+                
+
+                if(isValidReleased &&
+                        arg_Released == property_Released)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetReleased();
+
+                
+                        property_Released = std::string(arg_Released.c_str());
+                        isValidReleased = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for released
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetReleased()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidReleased = false; 
+               return true;
+           }
+
+           /**
+            * Check whether released is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isReleasedNil()
+           {
+               return !isValidReleased;
+           }
+
+           /**
+            * Set released to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setReleasedNil()
+           {
+               return resetReleased();
+           }
+
+           
+
+            /**
+             * Getter for removed by  Property Number 11
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty11()
+            {
+                return getRemoved();
+            }
+
+            /**
+             * getter for removed.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getRemoved()
+             {
+                return property_Removed;
+             }
+
+            /**
+             * setter for removed
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setRemoved(
+                    const std::string  arg_Removed)
+             {
+                
+
+                if(isValidRemoved &&
+                        arg_Removed == property_Removed)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetRemoved();
+
+                
+                        property_Removed = std::string(arg_Removed.c_str());
+                        isValidRemoved = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for removed
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetRemoved()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidRemoved = false; 
+               return true;
+           }
+
+           /**
+            * Check whether removed is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isRemovedNil()
+           {
+               return !isValidRemoved;
+           }
+
+           /**
+            * Set removed to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setRemovedNil()
+           {
+               return resetRemoved();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_OSType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_OSType.cpp
new file mode 100644
index 0000000..75c1fe0
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_OSType.cpp
@@ -0,0 +1,354 @@
+
+
+        /**
+         * OSType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_OSType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the OSType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::OSType::OSType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_OSType;
+                
+            isValidOSType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "OSType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::OSType::OSType(std::string arg_OSType)
+        {
+             
+                   qname = NULL;
+             
+                 property_OSType;
+             
+            isValidOSType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "OSType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_OSType = arg_OSType;
+            
+        }
+        AviaryCommon::OSType::~OSType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            OSType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setOSType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::OSType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element OSType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::OSType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::OSType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::OSType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_OSType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_OSType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::OSType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for OSType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::OSType::getProperty1()
+            {
+                return getOSType();
+            }
+
+            /**
+             * getter for OSType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::OSType::getOSType()
+             {
+                return property_OSType;
+             }
+
+            /**
+             * setter for OSType
+             */
+            bool WSF_CALL
+            AviaryCommon::OSType::setOSType(
+                    const std::string  arg_OSType)
+             {
+                
+
+                if(isValidOSType &&
+                        arg_OSType == property_OSType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_OSType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"OSType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetOSType();
+
+                
+                        property_OSType = std::string(arg_OSType.c_str());
+                        isValidOSType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for OSType.
+             */
+             ADBOSTypeEnum WSF_CALL
+             AviaryCommon::OSType::getOSTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_OSType.c_str(), "LINUX") == 0)
+                    return OSType_LINUX;
+             
+                 if (axutil_strcmp(property_OSType.c_str(), "WINDOWS") == 0)
+                    return OSType_WINDOWS;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBOSTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for OSType.
+             */
+             bool WSF_CALL
+            AviaryCommon::OSType::setOSTypeEnum(const ADBOSTypeEnum  arg_OSType)
+             {
+                
+
+                
+                resetOSType();
+
+                   
+                   switch (arg_OSType)
+                   {
+                     
+                       case OSType_LINUX :
+                            property_OSType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "LINUX");
+                          break;
+                     
+                       case OSType_WINDOWS :
+                            property_OSType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "WINDOWS");
+                          break;
+                     
+                     
+                       default:
+                          isValidOSType = false;
+                          property_OSType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting OSType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_OSType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidOSType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for OSType
+            */
+           bool WSF_CALL
+           AviaryCommon::OSType::resetOSType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidOSType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether OSType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::OSType::isOSTypeNil()
+           {
+               return !isValidOSType;
+           }
+
+           /**
+            * Set OSType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::OSType::setOSTypeNil()
+           {
+               return resetOSType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraint.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraint.cpp
new file mode 100644
index 0000000..ed3dd61
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraint.cpp
@@ -0,0 +1,717 @@
+
+
+        /**
+         * ResourceConstraint.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ResourceConstraint.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = ResourceConstraint
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::ResourceConstraint::ResourceConstraint()
+        {
+
+        
+                property_Type  = NULL;
+              
+            isValidType  = false;
+        
+                    property_Value;
+                
+            isValidValue  = false;
+        
+        }
+
+       AviaryCommon::ResourceConstraint::ResourceConstraint(AviaryCommon::ResourceConstraintType* arg_Type,std::string arg_Value)
+        {
+             
+               property_Type  = NULL;
+             
+            isValidType  = true;
+            
+                 property_Value;
+             
+            isValidValue  = true;
+            
+                    property_Type = arg_Type;
+            
+                    property_Value = arg_Value;
+            
+        }
+        AviaryCommon::ResourceConstraint::~ResourceConstraint()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::ResourceConstraint::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building type element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::ResourceConstraintType* element = new AviaryCommon::ResourceConstraintType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element type");
+                                      }
+                                      else
+                                      {
+                                          status = setType(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building value element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "value", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setValue(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element value");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setValue("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for value ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element value missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ResourceConstraint::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ResourceConstraint::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ResourceConstraint::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidType)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stype",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stype>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Type->serialize(current_node, parent_element,
+                                                                                 property_Type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidValue)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property value");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("value"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("value")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing value element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Value.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for type by  Property Number 1
+             */
+            AviaryCommon::ResourceConstraintType* WSF_CALL
+            AviaryCommon::ResourceConstraint::getProperty1()
+            {
+                return getType();
+            }
+
+            /**
+             * getter for type.
+             */
+            AviaryCommon::ResourceConstraintType* WSF_CALL
+            AviaryCommon::ResourceConstraint::getType()
+             {
+                return property_Type;
+             }
+
+            /**
+             * setter for type
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceConstraint::setType(
+                    AviaryCommon::ResourceConstraintType*  arg_Type)
+             {
+                
+
+                if(isValidType &&
+                        arg_Type == property_Type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetType();
+
+                
+                    if(NULL == arg_Type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Type = arg_Type;
+                        isValidType = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for type
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::resetType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Type != NULL)
+                {
+                   
+                   
+                         delete  property_Type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::isTypeNil()
+           {
+               return !isValidType;
+           }
+
+           /**
+            * Set type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::setTypeNil()
+           {
+               return resetType();
+           }
+
+           
+
+            /**
+             * Getter for value by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceConstraint::getProperty2()
+            {
+                return getValue();
+            }
+
+            /**
+             * getter for value.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceConstraint::getValue()
+             {
+                return property_Value;
+             }
+
+            /**
+             * setter for value
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceConstraint::setValue(
+                    const std::string  arg_Value)
+             {
+                
+
+                if(isValidValue &&
+                        arg_Value == property_Value)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Value.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"value is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetValue();
+
+                
+                        property_Value = std::string(arg_Value.c_str());
+                        isValidValue = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for value
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::resetValue()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidValue = false; 
+               return true;
+           }
+
+           /**
+            * Check whether value is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::isValueNil()
+           {
+               return !isValidValue;
+           }
+
+           /**
+            * Set value to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::setValueNil()
+           {
+               return resetValue();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraintType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraintType.cpp
new file mode 100644
index 0000000..a216860
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraintType.cpp
@@ -0,0 +1,375 @@
+
+
+        /**
+         * ResourceConstraintType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ResourceConstraintType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the ResourceConstraintType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::ResourceConstraintType::ResourceConstraintType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_ResourceConstraintType;
+                
+            isValidResourceConstraintType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ResourceConstraintType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::ResourceConstraintType::ResourceConstraintType(std::string arg_ResourceConstraintType)
+        {
+             
+                   qname = NULL;
+             
+                 property_ResourceConstraintType;
+             
+            isValidResourceConstraintType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ResourceConstraintType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ResourceConstraintType = arg_ResourceConstraintType;
+            
+        }
+        AviaryCommon::ResourceConstraintType::~ResourceConstraintType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            ResourceConstraintType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setResourceConstraintType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::ResourceConstraintType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element ResourceConstraintType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ResourceConstraintType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ResourceConstraintType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::ResourceConstraintType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_ResourceConstraintType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_ResourceConstraintType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ResourceConstraintType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ResourceConstraintType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceConstraintType::getProperty1()
+            {
+                return getResourceConstraintType();
+            }
+
+            /**
+             * getter for ResourceConstraintType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceConstraintType::getResourceConstraintType()
+             {
+                return property_ResourceConstraintType;
+             }
+
+            /**
+             * setter for ResourceConstraintType
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceConstraintType::setResourceConstraintType(
+                    const std::string  arg_ResourceConstraintType)
+             {
+                
+
+                if(isValidResourceConstraintType &&
+                        arg_ResourceConstraintType == property_ResourceConstraintType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_ResourceConstraintType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ResourceConstraintType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetResourceConstraintType();
+
+                
+                        property_ResourceConstraintType = std::string(arg_ResourceConstraintType.c_str());
+                        isValidResourceConstraintType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for ResourceConstraintType.
+             */
+             ADBResourceConstraintTypeEnum WSF_CALL
+             AviaryCommon::ResourceConstraintType::getResourceConstraintTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "OS") == 0)
+                    return ResourceConstraintType_OS;
+             
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "ARCH") == 0)
+                    return ResourceConstraintType_ARCH;
+             
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "MEMORY") == 0)
+                    return ResourceConstraintType_MEMORY;
+             
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "DISK") == 0)
+                    return ResourceConstraintType_DISK;
+             
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "FILESYSTEM") == 0)
+                    return ResourceConstraintType_FILESYSTEM;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBResourceConstraintTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for ResourceConstraintType.
+             */
+             bool WSF_CALL
+            AviaryCommon::ResourceConstraintType::setResourceConstraintTypeEnum(const ADBResourceConstraintTypeEnum  arg_ResourceConstraintType)
+             {
+                
+
+                
+                resetResourceConstraintType();
+
+                   
+                   switch (arg_ResourceConstraintType)
+                   {
+                     
+                       case ResourceConstraintType_OS :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "OS");
+                          break;
+                     
+                       case ResourceConstraintType_ARCH :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "ARCH");
+                          break;
+                     
+                       case ResourceConstraintType_MEMORY :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "MEMORY");
+                          break;
+                     
+                       case ResourceConstraintType_DISK :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "DISK");
+                          break;
+                     
+                       case ResourceConstraintType_FILESYSTEM :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "FILESYSTEM");
+                          break;
+                     
+                     
+                       default:
+                          isValidResourceConstraintType = false;
+                          property_ResourceConstraintType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting ResourceConstraintType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_ResourceConstraintType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidResourceConstraintType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for ResourceConstraintType
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraintType::resetResourceConstraintType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidResourceConstraintType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ResourceConstraintType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraintType::isResourceConstraintTypeNil()
+           {
+               return !isValidResourceConstraintType;
+           }
+
+           /**
+            * Set ResourceConstraintType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraintType::setResourceConstraintTypeNil()
+           {
+               return resetResourceConstraintType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceID.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceID.cpp
new file mode 100644
index 0000000..e38ce4f
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceID.cpp
@@ -0,0 +1,1308 @@
+
+
+        /**
+         * ResourceID.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ResourceID.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = ResourceID
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::ResourceID::ResourceID()
+        {
+
+        
+                property_Subsystem_type  = NULL;
+              
+            isValidSubsystem_type  = false;
+        
+                    property_Pool;
+                
+            isValidPool  = false;
+        
+                    property_Name;
+                
+            isValidName  = false;
+        
+                    property_Custom_name;
+                
+            isValidCustom_name  = false;
+        
+        }
+
+       AviaryCommon::ResourceID::ResourceID(AviaryCommon::ResourceType* arg_Subsystem_type,std::string arg_Pool,std::string arg_Name,std::string arg_Custom_name)
+        {
+             
+               property_Subsystem_type  = NULL;
+             
+            isValidSubsystem_type  = true;
+            
+                 property_Pool;
+             
+            isValidPool  = true;
+            
+                 property_Name;
+             
+            isValidName  = true;
+            
+                 property_Custom_name;
+             
+            isValidCustom_name  = true;
+            
+                    property_Subsystem_type = arg_Subsystem_type;
+            
+                    property_Pool = arg_Pool;
+            
+                    property_Name = arg_Name;
+            
+                    property_Custom_name = arg_Custom_name;
+            
+        }
+        AviaryCommon::ResourceID::~ResourceID()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::ResourceID::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building subsystem_type element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "subsystem_type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("subsystem_type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("subsystem_type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::ResourceType* element = new AviaryCommon::ResourceType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element subsystem_type");
+                                      }
+                                      else
+                                      {
+                                          status = setSubsystem_type(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for subsystem_type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element subsystem_type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building pool element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "pool", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("pool", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("pool", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setPool(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element pool");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setPool("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for pool ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element pool missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building name element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setName(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setName("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element name missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building custom_name element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "custom_name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("custom_name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("custom_name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setCustom_name(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element custom_name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setCustom_name("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for custom_name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ResourceID::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ResourceID::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ResourceID::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t *text_value_4;
+                    axis2_char_t *text_value_4_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidSubsystem_type)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property subsystem_type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("subsystem_type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("subsystem_type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing subsystem_type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%ssubsystem_type",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%ssubsystem_type>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Subsystem_type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Subsystem_type->serialize(current_node, parent_element,
+                                                                                 property_Subsystem_type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Subsystem_type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidPool)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property pool");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("pool"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("pool")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing pool element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%spool>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%spool>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Pool.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidName)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property name");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_Name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCustom_name)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("custom_name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("custom_name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing custom_name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scustom_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scustom_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_4 = (axis2_char_t*)property_Custom_name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_4_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_4, true);
+                           if (text_value_4_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_4_temp, axutil_strlen(text_value_4_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_4_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for subsystem_type by  Property Number 1
+             */
+            AviaryCommon::ResourceType* WSF_CALL
+            AviaryCommon::ResourceID::getProperty1()
+            {
+                return getSubsystem_type();
+            }
+
+            /**
+             * getter for subsystem_type.
+             */
+            AviaryCommon::ResourceType* WSF_CALL
+            AviaryCommon::ResourceID::getSubsystem_type()
+             {
+                return property_Subsystem_type;
+             }
+
+            /**
+             * setter for subsystem_type
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceID::setSubsystem_type(
+                    AviaryCommon::ResourceType*  arg_Subsystem_type)
+             {
+                
+
+                if(isValidSubsystem_type &&
+                        arg_Subsystem_type == property_Subsystem_type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Subsystem_type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"subsystem_type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetSubsystem_type();
+
+                
+                    if(NULL == arg_Subsystem_type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Subsystem_type = arg_Subsystem_type;
+                        isValidSubsystem_type = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for subsystem_type
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::resetSubsystem_type()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Subsystem_type != NULL)
+                {
+                   
+                   
+                         delete  property_Subsystem_type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidSubsystem_type = false; 
+               return true;
+           }
+
+           /**
+            * Check whether subsystem_type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::isSubsystem_typeNil()
+           {
+               return !isValidSubsystem_type;
+           }
+
+           /**
+            * Set subsystem_type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::setSubsystem_typeNil()
+           {
+               return resetSubsystem_type();
+           }
+
+           
+
+            /**
+             * Getter for pool by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getProperty2()
+            {
+                return getPool();
+            }
+
+            /**
+             * getter for pool.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getPool()
+             {
+                return property_Pool;
+             }
+
+            /**
+             * setter for pool
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceID::setPool(
+                    const std::string  arg_Pool)
+             {
+                
+
+                if(isValidPool &&
+                        arg_Pool == property_Pool)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Pool.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"pool is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetPool();
+
+                
+                        property_Pool = std::string(arg_Pool.c_str());
+                        isValidPool = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for pool
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::resetPool()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPool = false; 
+               return true;
+           }
+
+           /**
+            * Check whether pool is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::isPoolNil()
+           {
+               return !isValidPool;
+           }
+
+           /**
+            * Set pool to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::setPoolNil()
+           {
+               return resetPool();
+           }
+
+           
+
+            /**
+             * Getter for name by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getProperty3()
+            {
+                return getName();
+            }
+
+            /**
+             * getter for name.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getName()
+             {
+                return property_Name;
+             }
+
+            /**
+             * setter for name
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceID::setName(
+                    const std::string  arg_Name)
+             {
+                
+
+                if(isValidName &&
+                        arg_Name == property_Name)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Name.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"name is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetName();
+
+                
+                        property_Name = std::string(arg_Name.c_str());
+                        isValidName = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for name
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::resetName()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidName = false; 
+               return true;
+           }
+
+           /**
+            * Check whether name is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::isNameNil()
+           {
+               return !isValidName;
+           }
+
+           /**
+            * Set name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::setNameNil()
+           {
+               return resetName();
+           }
+
+           
+
+            /**
+             * Getter for custom_name by  Property Number 4
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getProperty4()
+            {
+                return getCustom_name();
+            }
+
+            /**
+             * getter for custom_name.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getCustom_name()
+             {
+                return property_Custom_name;
+             }
+
+            /**
+             * setter for custom_name
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceID::setCustom_name(
+                    const std::string  arg_Custom_name)
+             {
+                
+
+                if(isValidCustom_name &&
+                        arg_Custom_name == property_Custom_name)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetCustom_name();
+
+                
+                        property_Custom_name = std::string(arg_Custom_name.c_str());
+                        isValidCustom_name = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for custom_name
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::resetCustom_name()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidCustom_name = false; 
+               return true;
+           }
+
+           /**
+            * Check whether custom_name is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::isCustom_nameNil()
+           {
+               return !isValidCustom_name;
+           }
+
+           /**
+            * Set custom_name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::setCustom_nameNil()
+           {
+               return resetCustom_name();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceType.cpp
new file mode 100644
index 0000000..04c6865
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceType.cpp
@@ -0,0 +1,403 @@
+
+
+        /**
+         * ResourceType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ResourceType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the ResourceType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::ResourceType::ResourceType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_ResourceType;
+                
+            isValidResourceType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ResourceType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::ResourceType::ResourceType(std::string arg_ResourceType)
+        {
+             
+                   qname = NULL;
+             
+                 property_ResourceType;
+             
+            isValidResourceType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ResourceType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ResourceType = arg_ResourceType;
+            
+        }
+        AviaryCommon::ResourceType::~ResourceType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            ResourceType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setResourceType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::ResourceType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element ResourceType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ResourceType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ResourceType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::ResourceType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_ResourceType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_ResourceType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ResourceType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ResourceType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceType::getProperty1()
+            {
+                return getResourceType();
+            }
+
+            /**
+             * getter for ResourceType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceType::getResourceType()
+             {
+                return property_ResourceType;
+             }
+
+            /**
+             * setter for ResourceType
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceType::setResourceType(
+                    const std::string  arg_ResourceType)
+             {
+                
+
+                if(isValidResourceType &&
+                        arg_ResourceType == property_ResourceType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_ResourceType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ResourceType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetResourceType();
+
+                
+                        property_ResourceType = std::string(arg_ResourceType.c_str());
+                        isValidResourceType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for ResourceType.
+             */
+             ADBResourceTypeEnum WSF_CALL
+             AviaryCommon::ResourceType::getResourceTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_ResourceType.c_str(), "COLLECTOR") == 0)
+                    return ResourceType_COLLECTOR;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "EXECUTOR") == 0)
+                    return ResourceType_EXECUTOR;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "EVENT_SERVER") == 0)
+                    return ResourceType_EVENT_SERVER;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "JOB_SERVER") == 0)
+                    return ResourceType_JOB_SERVER;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "LOW_LATENCY") == 0)
+                    return ResourceType_LOW_LATENCY;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "MASTER") == 0)
+                    return ResourceType_MASTER;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "NEGOTIATOR") == 0)
+                    return ResourceType_NEGOTIATOR;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "SCHEDULER") == 0)
+                    return ResourceType_SCHEDULER;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "CUSTOM") == 0)
+                    return ResourceType_CUSTOM;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBResourceTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for ResourceType.
+             */
+             bool WSF_CALL
+            AviaryCommon::ResourceType::setResourceTypeEnum(const ADBResourceTypeEnum  arg_ResourceType)
+             {
+                
+
+                
+                resetResourceType();
+
+                   
+                   switch (arg_ResourceType)
+                   {
+                     
+                       case ResourceType_COLLECTOR :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "COLLECTOR");
+                          break;
+                     
+                       case ResourceType_EXECUTOR :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "EXECUTOR");
+                          break;
+                     
+                       case ResourceType_EVENT_SERVER :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "EVENT_SERVER");
+                          break;
+                     
+                       case ResourceType_JOB_SERVER :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "JOB_SERVER");
+                          break;
+                     
+                       case ResourceType_LOW_LATENCY :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "LOW_LATENCY");
+                          break;
+                     
+                       case ResourceType_MASTER :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "MASTER");
+                          break;
+                     
+                       case ResourceType_NEGOTIATOR :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "NEGOTIATOR");
+                          break;
+                     
+                       case ResourceType_SCHEDULER :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "SCHEDULER");
+                          break;
+                     
+                       case ResourceType_CUSTOM :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "CUSTOM");
+                          break;
+                     
+                     
+                       default:
+                          isValidResourceType = false;
+                          property_ResourceType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting ResourceType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_ResourceType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidResourceType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for ResourceType
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceType::resetResourceType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidResourceType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ResourceType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceType::isResourceTypeNil()
+           {
+               return !isValidResourceType;
+           }
+
+           /**
+            * Set ResourceType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceType::setResourceTypeNil()
+           {
+               return resetResourceType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Status.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Status.cpp
new file mode 100644
index 0000000..d959dff
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Status.cpp
@@ -0,0 +1,698 @@
+
+
+        /**
+         * Status.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_Status.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = Status
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::Status::Status()
+        {
+
+        
+                property_Code  = NULL;
+              
+            isValidCode  = false;
+        
+                    property_Text;
+                
+            isValidText  = false;
+        
+        }
+
+       AviaryCommon::Status::Status(AviaryCommon::StatusCodeType* arg_Code,std::string arg_Text)
+        {
+             
+               property_Code  = NULL;
+             
+            isValidCode  = true;
+            
+                 property_Text;
+             
+            isValidText  = true;
+            
+                    property_Code = arg_Code;
+            
+                    property_Text = arg_Text;
+            
+        }
+        AviaryCommon::Status::~Status()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::Status::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building code element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "code", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("code", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("code", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::StatusCodeType* element = new AviaryCommon::StatusCodeType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element code");
+                                      }
+                                      else
+                                      {
+                                          status = setCode(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for code ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element code missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building text element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "text", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("text", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("text", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setText(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element text");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setText("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for text ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::Status::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::Status::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::Status::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCode)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property code");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("code"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("code")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing code element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scode",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scode>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Code->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Code->serialize(current_node, parent_element,
+                                                                                 property_Code->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Code->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidText)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("text"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("text")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing text element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stext>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stext>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Text.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for code by  Property Number 1
+             */
+            AviaryCommon::StatusCodeType* WSF_CALL
+            AviaryCommon::Status::getProperty1()
+            {
+                return getCode();
+            }
+
+            /**
+             * getter for code.
+             */
+            AviaryCommon::StatusCodeType* WSF_CALL
+            AviaryCommon::Status::getCode()
+             {
+                return property_Code;
+             }
+
+            /**
+             * setter for code
+             */
+            bool WSF_CALL
+            AviaryCommon::Status::setCode(
+                    AviaryCommon::StatusCodeType*  arg_Code)
+             {
+                
+
+                if(isValidCode &&
+                        arg_Code == property_Code)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Code)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"code is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetCode();
+
+                
+                    if(NULL == arg_Code)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Code = arg_Code;
+                        isValidCode = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for code
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::resetCode()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Code != NULL)
+                {
+                   
+                   
+                         delete  property_Code;
+                     
+
+                   }
+
+                
+                
+                
+               isValidCode = false; 
+               return true;
+           }
+
+           /**
+            * Check whether code is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::isCodeNil()
+           {
+               return !isValidCode;
+           }
+
+           /**
+            * Set code to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::setCodeNil()
+           {
+               return resetCode();
+           }
+
+           
+
+            /**
+             * Getter for text by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::Status::getProperty2()
+            {
+                return getText();
+            }
+
+            /**
+             * getter for text.
+             */
+            std::string WSF_CALL
+            AviaryCommon::Status::getText()
+             {
+                return property_Text;
+             }
+
+            /**
+             * setter for text
+             */
+            bool WSF_CALL
+            AviaryCommon::Status::setText(
+                    const std::string  arg_Text)
+             {
+                
+
+                if(isValidText &&
+                        arg_Text == property_Text)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetText();
+
+                
+                        property_Text = std::string(arg_Text.c_str());
+                        isValidText = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for text
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::resetText()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidText = false; 
+               return true;
+           }
+
+           /**
+            * Check whether text is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::isTextNil()
+           {
+               return !isValidText;
+           }
+
+           /**
+            * Set text to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::setTextNil()
+           {
+               return resetText();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_StatusCodeType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_StatusCodeType.cpp
new file mode 100644
index 0000000..470823a
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_StatusCodeType.cpp
@@ -0,0 +1,382 @@
+
+
+        /**
+         * StatusCodeType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_StatusCodeType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the StatusCodeType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::StatusCodeType::StatusCodeType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_StatusCodeType;
+                
+            isValidStatusCodeType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "StatusCodeType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::StatusCodeType::StatusCodeType(std::string arg_StatusCodeType)
+        {
+             
+                   qname = NULL;
+             
+                 property_StatusCodeType;
+             
+            isValidStatusCodeType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "StatusCodeType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_StatusCodeType = arg_StatusCodeType;
+            
+        }
+        AviaryCommon::StatusCodeType::~StatusCodeType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            StatusCodeType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setStatusCodeType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::StatusCodeType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element StatusCodeType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::StatusCodeType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::StatusCodeType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::StatusCodeType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_StatusCodeType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_StatusCodeType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::StatusCodeType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for StatusCodeType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::StatusCodeType::getProperty1()
+            {
+                return getStatusCodeType();
+            }
+
+            /**
+             * getter for StatusCodeType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::StatusCodeType::getStatusCodeType()
+             {
+                return property_StatusCodeType;
+             }
+
+            /**
+             * setter for StatusCodeType
+             */
+            bool WSF_CALL
+            AviaryCommon::StatusCodeType::setStatusCodeType(
+                    const std::string  arg_StatusCodeType)
+             {
+                
+
+                if(isValidStatusCodeType &&
+                        arg_StatusCodeType == property_StatusCodeType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_StatusCodeType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"StatusCodeType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatusCodeType();
+
+                
+                        property_StatusCodeType = std::string(arg_StatusCodeType.c_str());
+                        isValidStatusCodeType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for StatusCodeType.
+             */
+             ADBStatusCodeTypeEnum WSF_CALL
+             AviaryCommon::StatusCodeType::getStatusCodeTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "OK") == 0)
+                    return StatusCodeType_OK;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "FAIL") == 0)
+                    return StatusCodeType_FAIL;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "NO_MATCH") == 0)
+                    return StatusCodeType_NO_MATCH;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "INVALID_OFFSET") == 0)
+                    return StatusCodeType_INVALID_OFFSET;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "UNIMPLEMENTED") == 0)
+                    return StatusCodeType_UNIMPLEMENTED;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "UNAVAILABLE") == 0)
+                    return StatusCodeType_UNAVAILABLE;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBStatusCodeTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for StatusCodeType.
+             */
+             bool WSF_CALL
+            AviaryCommon::StatusCodeType::setStatusCodeTypeEnum(const ADBStatusCodeTypeEnum  arg_StatusCodeType)
+             {
+                
+
+                
+                resetStatusCodeType();
+
+                   
+                   switch (arg_StatusCodeType)
+                   {
+                     
+                       case StatusCodeType_OK :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "OK");
+                          break;
+                     
+                       case StatusCodeType_FAIL :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "FAIL");
+                          break;
+                     
+                       case StatusCodeType_NO_MATCH :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "NO_MATCH");
+                          break;
+                     
+                       case StatusCodeType_INVALID_OFFSET :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "INVALID_OFFSET");
+                          break;
+                     
+                       case StatusCodeType_UNIMPLEMENTED :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "UNIMPLEMENTED");
+                          break;
+                     
+                       case StatusCodeType_UNAVAILABLE :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "UNAVAILABLE");
+                          break;
+                     
+                     
+                       default:
+                          isValidStatusCodeType = false;
+                          property_StatusCodeType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting StatusCodeType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_StatusCodeType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidStatusCodeType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for StatusCodeType
+            */
+           bool WSF_CALL
+           AviaryCommon::StatusCodeType::resetStatusCodeType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidStatusCodeType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether StatusCodeType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::StatusCodeType::isStatusCodeTypeNil()
+           {
+               return !isValidStatusCodeType;
+           }
+
+           /**
+            * Set StatusCodeType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::StatusCodeType::setStatusCodeTypeNil()
+           {
+               return resetStatusCodeType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionID.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionID.cpp
new file mode 100644
index 0000000..0d23b22
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionID.cpp
@@ -0,0 +1,717 @@
+
+
+        /**
+         * SubmissionID.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_SubmissionID.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = SubmissionID
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::SubmissionID::SubmissionID()
+        {
+
+        
+                    property_Name;
+                
+            isValidName  = false;
+        
+                    property_Owner;
+                
+            isValidOwner  = false;
+        
+        }
+
+       AviaryCommon::SubmissionID::SubmissionID(std::string arg_Name,std::string arg_Owner)
+        {
+             
+                 property_Name;
+             
+            isValidName  = true;
+            
+                 property_Owner;
+             
+            isValidOwner  = true;
+            
+                    property_Name = arg_Name;
+            
+                    property_Owner = arg_Owner;
+            
+        }
+        AviaryCommon::SubmissionID::~SubmissionID()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::SubmissionID::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building name element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setName(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setName("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building owner element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "owner", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("owner", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("owner", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setOwner(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element owner");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setOwner("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for owner ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::SubmissionID::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::SubmissionID::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::SubmissionID::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t *text_value_1;
+                    axis2_char_t *text_value_1_temp;
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidName)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_1 = (axis2_char_t*)property_Name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_1_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_1, true);
+                           if (text_value_1_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1_temp, axutil_strlen(text_value_1_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_1_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1, axutil_strlen(text_value_1));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidOwner)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("owner"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("owner")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing owner element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sowner>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sowner>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Owner.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for name by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::SubmissionID::getProperty1()
+            {
+                return getName();
+            }
+
+            /**
+             * getter for name.
+             */
+            std::string WSF_CALL
+            AviaryCommon::SubmissionID::getName()
+             {
+                return property_Name;
+             }
+
+            /**
+             * setter for name
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionID::setName(
+                    const std::string  arg_Name)
+             {
+                
+
+                if(isValidName &&
+                        arg_Name == property_Name)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetName();
+
+                
+                        property_Name = std::string(arg_Name.c_str());
+                        isValidName = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for name
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::resetName()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidName = false; 
+               return true;
+           }
+
+           /**
+            * Check whether name is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::isNameNil()
+           {
+               return !isValidName;
+           }
+
+           /**
+            * Set name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::setNameNil()
+           {
+               return resetName();
+           }
+
+           
+
+            /**
+             * Getter for owner by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::SubmissionID::getProperty2()
+            {
+                return getOwner();
+            }
+
+            /**
+             * getter for owner.
+             */
+            std::string WSF_CALL
+            AviaryCommon::SubmissionID::getOwner()
+             {
+                return property_Owner;
+             }
+
+            /**
+             * setter for owner
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionID::setOwner(
+                    const std::string  arg_Owner)
+             {
+                
+
+                if(isValidOwner &&
+                        arg_Owner == property_Owner)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetOwner();
+
+                
+                        property_Owner = std::string(arg_Owner.c_str());
+                        isValidOwner = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for owner
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::resetOwner()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidOwner = false; 
+               return true;
+           }
+
+           /**
+            * Check whether owner is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::isOwnerNil()
+           {
+               return !isValidOwner;
+           }
+
+           /**
+            * Set owner to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::setOwnerNil()
+           {
+               return resetOwner();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionSummary.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionSummary.cpp
new file mode 100644
index 0000000..bf367ee
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionSummary.cpp
@@ -0,0 +1,2415 @@
+
+
+        /**
+         * SubmissionSummary.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_SubmissionSummary.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = SubmissionSummary
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::SubmissionSummary::SubmissionSummary()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+            isValidCompleted  = false;
+        
+            isValidHeld  = false;
+        
+            isValidIdle  = false;
+        
+            isValidRemoved  = false;
+        
+            isValidRunning  = false;
+        
+                property_Jobs  = NULL;
+              
+            isValidJobs  = false;
+        
+        }
+
+       AviaryCommon::SubmissionSummary::SubmissionSummary(AviaryCommon::SubmissionID* arg_Id,AviaryCommon::Status* arg_Status,int arg_Completed,int arg_Held,int arg_Idle,int arg_Removed,int arg_Running,std::vector<AviaryCommon::JobSummary*>* arg_Jobs)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+            isValidCompleted  = true;
+            
+            isValidHeld  = true;
+            
+            isValidIdle  = true;
+            
+            isValidRemoved  = true;
+            
+            isValidRunning  = true;
+            
+               property_Jobs  = NULL;
+             
+            isValidJobs  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+                    property_Completed = arg_Completed;
+            
+                    property_Held = arg_Held;
+            
+                    property_Idle = arg_Idle;
+            
+                    property_Removed = arg_Removed;
+            
+                    property_Running = arg_Running;
+            
+                    property_Jobs = arg_Jobs;
+            
+        }
+        AviaryCommon::SubmissionSummary::~SubmissionSummary()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::SubmissionSummary::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::SubmissionID* element = new AviaryCommon::SubmissionID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building completed element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "completed", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("completed", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("completed", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setCompleted(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element completed");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for completed ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element completed missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building held element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "held", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("held", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("held", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setHeld(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element held");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for held ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element held missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building idle element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "idle", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("idle", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("idle", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setIdle(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element idle");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for idle ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element idle missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building removed element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "removed", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("removed", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("removed", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setRemoved(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element removed");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for removed ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element removed missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building running element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "running", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("running", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("running", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setRunning(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element running");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for running ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element running missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                       { 
+                    /*
+                     * building Jobs array
+                     */
+                       std::vector<AviaryCommon::JobSummary*>* arr_list =new std::vector<AviaryCommon::JobSummary*>();
+                   
+
+                     
+                     /*
+                      * building jobs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "jobs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = (is_early_node_valid?axiom_node_get_next_sibling(current_node, Environment::getEnv()):current_node); !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("jobs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobSummary* element = new AviaryCommon::JobSummary();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element jobs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for jobs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setJobs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::SubmissionSummary::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::SubmissionSummary::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::SubmissionSummary::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_4[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_5[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_6[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_7[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_8[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCompleted)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property completed");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("completed"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("completed")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing completed element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scompleted>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scompleted>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_3, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Completed);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidHeld)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property held");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("held"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("held")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing held element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sheld>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sheld>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_4, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Held);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIdle)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property idle");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("idle"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("idle")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing idle element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sidle>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sidle>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_5, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Idle);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_5, axutil_strlen(text_value_5));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidRemoved)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property removed");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("removed"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("removed")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing removed element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sremoved>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sremoved>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_6, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Removed);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_6, axutil_strlen(text_value_6));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidRunning)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property running");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("running"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("running")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing running element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%srunning>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%srunning>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_7, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Running);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_7, axutil_strlen(text_value_7));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJobs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("jobs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("jobs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Jobs array
+                      */
+                     if (property_Jobs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sjobs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sjobs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Jobs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobSummary* element = (*property_Jobs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing jobs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryCommon::SubmissionSummary::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setId(
+                    AviaryCommon::SubmissionID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::SubmissionSummary::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for completed by  Property Number 3
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty3()
+            {
+                return getCompleted();
+            }
+
+            /**
+             * getter for completed.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getCompleted()
+             {
+                return property_Completed;
+             }
+
+            /**
+             * setter for completed
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setCompleted(
+                    const int  arg_Completed)
+             {
+                
+
+                if(isValidCompleted &&
+                        arg_Completed == property_Completed)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetCompleted();
+
+                
+                        property_Completed = arg_Completed;
+                        isValidCompleted = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for completed
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetCompleted()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidCompleted = false; 
+               return true;
+           }
+
+           /**
+            * Check whether completed is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isCompletedNil()
+           {
+               return !isValidCompleted;
+           }
+
+           /**
+            * Set completed to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setCompletedNil()
+           {
+               return resetCompleted();
+           }
+
+           
+
+            /**
+             * Getter for held by  Property Number 4
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty4()
+            {
+                return getHeld();
+            }
+
+            /**
+             * getter for held.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getHeld()
+             {
+                return property_Held;
+             }
+
+            /**
+             * setter for held
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setHeld(
+                    const int  arg_Held)
+             {
+                
+
+                if(isValidHeld &&
+                        arg_Held == property_Held)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetHeld();
+
+                
+                        property_Held = arg_Held;
+                        isValidHeld = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for held
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetHeld()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidHeld = false; 
+               return true;
+           }
+
+           /**
+            * Check whether held is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isHeldNil()
+           {
+               return !isValidHeld;
+           }
+
+           /**
+            * Set held to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setHeldNil()
+           {
+               return resetHeld();
+           }
+
+           
+
+            /**
+             * Getter for idle by  Property Number 5
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty5()
+            {
+                return getIdle();
+            }
+
+            /**
+             * getter for idle.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getIdle()
+             {
+                return property_Idle;
+             }
+
+            /**
+             * setter for idle
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setIdle(
+                    const int  arg_Idle)
+             {
+                
+
+                if(isValidIdle &&
+                        arg_Idle == property_Idle)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetIdle();
+
+                
+                        property_Idle = arg_Idle;
+                        isValidIdle = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for idle
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetIdle()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidIdle = false; 
+               return true;
+           }
+
+           /**
+            * Check whether idle is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isIdleNil()
+           {
+               return !isValidIdle;
+           }
+
+           /**
+            * Set idle to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setIdleNil()
+           {
+               return resetIdle();
+           }
+
+           
+
+            /**
+             * Getter for removed by  Property Number 6
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty6()
+            {
+                return getRemoved();
+            }
+
+            /**
+             * getter for removed.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getRemoved()
+             {
+                return property_Removed;
+             }
+
+            /**
+             * setter for removed
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setRemoved(
+                    const int  arg_Removed)
+             {
+                
+
+                if(isValidRemoved &&
+                        arg_Removed == property_Removed)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetRemoved();
+
+                
+                        property_Removed = arg_Removed;
+                        isValidRemoved = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for removed
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetRemoved()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidRemoved = false; 
+               return true;
+           }
+
+           /**
+            * Check whether removed is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isRemovedNil()
+           {
+               return !isValidRemoved;
+           }
+
+           /**
+            * Set removed to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setRemovedNil()
+           {
+               return resetRemoved();
+           }
+
+           
+
+            /**
+             * Getter for running by  Property Number 7
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty7()
+            {
+                return getRunning();
+            }
+
+            /**
+             * getter for running.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getRunning()
+             {
+                return property_Running;
+             }
+
+            /**
+             * setter for running
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setRunning(
+                    const int  arg_Running)
+             {
+                
+
+                if(isValidRunning &&
+                        arg_Running == property_Running)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetRunning();
+
+                
+                        property_Running = arg_Running;
+                        isValidRunning = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for running
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetRunning()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidRunning = false; 
+               return true;
+           }
+
+           /**
+            * Check whether running is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isRunningNil()
+           {
+               return !isValidRunning;
+           }
+
+           /**
+            * Set running to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setRunningNil()
+           {
+               return resetRunning();
+           }
+
+           
+
+            /**
+             * Getter for jobs by  Property Number 8
+             */
+            std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty8()
+            {
+                return getJobs();
+            }
+
+            /**
+             * getter for jobs.
+             */
+            std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+            AviaryCommon::SubmissionSummary::getJobs()
+             {
+                return property_Jobs;
+             }
+
+            /**
+             * setter for jobs
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setJobs(
+                    std::vector<AviaryCommon::JobSummary*>*  arg_Jobs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidJobs &&
+                        arg_Jobs == property_Jobs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Jobs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Jobs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetJobs();
+
+                
+                    if(NULL == arg_Jobs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Jobs = arg_Jobs;
+                        if(non_nil_exists)
+                        {
+                            isValidJobs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of jobs.
+             */
+            AviaryCommon::JobSummary* WSF_CALL
+            AviaryCommon::SubmissionSummary::getJobsAt(int i)
+            {
+                AviaryCommon::JobSummary* ret_val;
+                if(property_Jobs == NULL)
+                {
+                    return (AviaryCommon::JobSummary*)0;
+                }
+                ret_val =   (*property_Jobs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of jobs.
+             */
+           bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setJobsAt(int i,
+                    AviaryCommon::JobSummary* arg_Jobs)
+            {
+                 AviaryCommon::JobSummary* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidJobs &&
+                    property_Jobs &&
+                  
+                    arg_Jobs == (*property_Jobs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobSummary*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Jobs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = true;
+                        (*property_Jobs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Jobs)[i] = arg_Jobs;
+                  
+
+               isValidJobs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to jobs.
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::addJobs(
+                    AviaryCommon::JobSummary* arg_Jobs)
+             {
+
+                
+                    if( NULL == arg_Jobs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobSummary*>();
+                }
+              
+               property_Jobs->push_back(arg_Jobs);
+              
+                isValidJobs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the jobs array.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::sizeofJobs()
+            {
+
+                if(property_Jobs == NULL)
+                {
+                    return 0;
+                }
+                return property_Jobs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::removeJobsAt(int i)
+            {
+                return setJobsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for jobs
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetJobs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Jobs != NULL)
+                {
+                  std::vector<AviaryCommon::JobSummary*>::iterator it =  property_Jobs->begin();
+                  for( ; it <  property_Jobs->end() ; ++it)
+                  {
+                     AviaryCommon::JobSummary* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Jobs)
+                 delete property_Jobs;
+                
+               isValidJobs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether jobs is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isJobsNil()
+           {
+               return !isValidJobs;
+           }
+
+           /**
+            * Set jobs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setJobsNil()
+           {
+               return resetJobs();
+           }
+
+           
+           /**
+            * Check whether jobs is nill at i
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isJobsNilAt(int i)
+           {
+               return (isValidJobs == false ||
+                       NULL == property_Jobs ||
+                     NULL == (*property_Jobs)[i]);
+            }
+
+           /**
+            * Set jobs to nil at i
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setJobsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Jobs == NULL ||
+                            isValidJobs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Jobs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Jobs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of jobs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Jobs == NULL)
+                {
+                    isValidJobs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobSummary* element = (*property_Jobs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = false;
+                        (*property_Jobs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Jobs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJob.cpp
new file mode 100644
index 0000000..dc4a46a
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJob.cpp
@@ -0,0 +1,717 @@
+
+
+        /**
+         * ControlJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_ControlJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = ControlJob
+                 * Namespace URI = http://job.aviary.grid.redhat.com
+                 * Namespace Prefix = ns2
+                 */
+           AviaryJob::ControlJob::ControlJob()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                    property_Reason;
+                
+            isValidReason  = false;
+        
+        }
+
+       AviaryJob::ControlJob::ControlJob(AviaryCommon::JobID* arg_Id,std::string arg_Reason)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+                 property_Reason;
+             
+            isValidReason  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Reason = arg_Reason;
+            
+        }
+        AviaryJob::ControlJob::~ControlJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::ControlJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building reason element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "reason", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("reason", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("reason", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setReason(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element reason");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setReason("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for reason ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element reason missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::ControlJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::ControlJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::ControlJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidReason)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property reason");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("reason"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("reason")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing reason element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sreason>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sreason>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Reason.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::ControlJob::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::ControlJob::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryJob::ControlJob::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for reason by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryJob::ControlJob::getProperty2()
+            {
+                return getReason();
+            }
+
+            /**
+             * getter for reason.
+             */
+            std::string WSF_CALL
+            AviaryJob::ControlJob::getReason()
+             {
+                return property_Reason;
+             }
+
+            /**
+             * setter for reason
+             */
+            bool WSF_CALL
+            AviaryJob::ControlJob::setReason(
+                    const std::string  arg_Reason)
+             {
+                
+
+                if(isValidReason &&
+                        arg_Reason == property_Reason)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Reason.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"reason is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetReason();
+
+                
+                        property_Reason = std::string(arg_Reason.c_str());
+                        isValidReason = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for reason
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::resetReason()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidReason = false; 
+               return true;
+           }
+
+           /**
+            * Check whether reason is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::isReasonNil()
+           {
+               return !isValidReason;
+           }
+
+           /**
+            * Set reason to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::setReasonNil()
+           {
+               return resetReason();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJobResponse.cpp
new file mode 100644
index 0000000..92ac909
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJobResponse.cpp
@@ -0,0 +1,412 @@
+
+
+        /**
+         * ControlJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_ControlJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = ControlJobResponse
+                 * Namespace URI = http://job.aviary.grid.redhat.com
+                 * Namespace Prefix = ns2
+                 */
+           AviaryJob::ControlJobResponse::ControlJobResponse()
+        {
+
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+        }
+
+       AviaryJob::ControlJobResponse::ControlJobResponse(AviaryCommon::Status* arg_Status)
+        {
+             
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+                    property_Status = arg_Status;
+            
+        }
+        AviaryJob::ControlJobResponse::~ControlJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::ControlJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::ControlJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::ControlJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::ControlJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for status by  Property Number 1
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryJob::ControlJobResponse::getProperty1()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryJob::ControlJobResponse::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryJob::ControlJobResponse::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJobResponse::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJobResponse::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJobResponse::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJob.cpp
new file mode 100644
index 0000000..66cd9b2
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJob.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * HoldJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_HoldJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the HoldJob|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::HoldJob::HoldJob()
+        {
+
+        
+            qname = NULL;
+        
+                property_HoldJob  = NULL;
+              
+            isValidHoldJob  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "HoldJob",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::HoldJob::HoldJob(AviaryJob::ControlJob* arg_HoldJob)
+        {
+             
+                   qname = NULL;
+             
+               property_HoldJob  = NULL;
+             
+            isValidHoldJob  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "HoldJob",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_HoldJob = arg_HoldJob;
+            
+        }
+        AviaryJob::HoldJob::~HoldJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::HoldJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for HoldJob : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building HoldJob element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "HoldJob", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJob* element = new AviaryJob::ControlJob();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element HoldJob");
+                                      }
+                                      else
+                                      {
+                                          status = setHoldJob(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for HoldJob ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element HoldJob missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::HoldJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::HoldJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::HoldJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "HoldJob", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidHoldJob)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property HoldJob");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("HoldJob"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("HoldJob")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing HoldJob element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sHoldJob",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sHoldJob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_HoldJob->serialize(current_node, parent_element,
+                                                                                 property_HoldJob->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for HoldJob by  Property Number 1
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::HoldJob::getProperty1()
+            {
+                return getHoldJob();
+            }
+
+            /**
+             * getter for HoldJob.
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::HoldJob::getHoldJob()
+             {
+                return property_HoldJob;
+             }
+
+            /**
+             * setter for HoldJob
+             */
+            bool WSF_CALL
+            AviaryJob::HoldJob::setHoldJob(
+                    AviaryJob::ControlJob*  arg_HoldJob)
+             {
+                
+
+                if(isValidHoldJob &&
+                        arg_HoldJob == property_HoldJob)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_HoldJob)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"HoldJob is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetHoldJob();
+
+                
+                    if(NULL == arg_HoldJob)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_HoldJob = arg_HoldJob;
+                        isValidHoldJob = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for HoldJob
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJob::resetHoldJob()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_HoldJob != NULL)
+                {
+                   
+                   
+                         delete  property_HoldJob;
+                     
+
+                   }
+
+                
+                
+                
+               isValidHoldJob = false; 
+               return true;
+           }
+
+           /**
+            * Check whether HoldJob is nill
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJob::isHoldJobNil()
+           {
+               return !isValidHoldJob;
+           }
+
+           /**
+            * Set HoldJob to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJob::setHoldJobNil()
+           {
+               return resetHoldJob();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJobResponse.cpp
new file mode 100644
index 0000000..1b80bc6
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJobResponse.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * HoldJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_HoldJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the HoldJobResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::HoldJobResponse::HoldJobResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_HoldJobResponse  = NULL;
+              
+            isValidHoldJobResponse  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "HoldJobResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::HoldJobResponse::HoldJobResponse(AviaryJob::ControlJobResponse* arg_HoldJobResponse)
+        {
+             
+                   qname = NULL;
+             
+               property_HoldJobResponse  = NULL;
+             
+            isValidHoldJobResponse  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "HoldJobResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_HoldJobResponse = arg_HoldJobResponse;
+            
+        }
+        AviaryJob::HoldJobResponse::~HoldJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::HoldJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for HoldJobResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building HoldJobResponse element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "HoldJobResponse", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJobResponse* element = new AviaryJob::ControlJobResponse();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element HoldJobResponse");
+                                      }
+                                      else
+                                      {
+                                          status = setHoldJobResponse(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for HoldJobResponse ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element HoldJobResponse missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::HoldJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::HoldJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::HoldJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "HoldJobResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidHoldJobResponse)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property HoldJobResponse");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("HoldJobResponse"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("HoldJobResponse")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing HoldJobResponse element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sHoldJobResponse",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sHoldJobResponse>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_HoldJobResponse->serialize(current_node, parent_element,
+                                                                                 property_HoldJobResponse->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for HoldJobResponse by  Property Number 1
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::HoldJobResponse::getProperty1()
+            {
+                return getHoldJobResponse();
+            }
+
+            /**
+             * getter for HoldJobResponse.
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::HoldJobResponse::getHoldJobResponse()
+             {
+                return property_HoldJobResponse;
+             }
+
+            /**
+             * setter for HoldJobResponse
+             */
+            bool WSF_CALL
+            AviaryJob::HoldJobResponse::setHoldJobResponse(
+                    AviaryJob::ControlJobResponse*  arg_HoldJobResponse)
+             {
+                
+
+                if(isValidHoldJobResponse &&
+                        arg_HoldJobResponse == property_HoldJobResponse)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_HoldJobResponse)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"HoldJobResponse is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetHoldJobResponse();
+
+                
+                    if(NULL == arg_HoldJobResponse)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_HoldJobResponse = arg_HoldJobResponse;
+                        isValidHoldJobResponse = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for HoldJobResponse
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJobResponse::resetHoldJobResponse()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_HoldJobResponse != NULL)
+                {
+                   
+                   
+                         delete  property_HoldJobResponse;
+                     
+
+                   }
+
+                
+                
+                
+               isValidHoldJobResponse = false; 
+               return true;
+           }
+
+           /**
+            * Check whether HoldJobResponse is nill
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJobResponse::isHoldJobResponseNil()
+           {
+               return !isValidHoldJobResponse;
+           }
+
+           /**
+            * Set HoldJobResponse to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJobResponse::setHoldJobResponseNil()
+           {
+               return resetHoldJobResponse();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJob.cpp
new file mode 100644
index 0000000..30d9977
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJob.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * ReleaseJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_ReleaseJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the ReleaseJob|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::ReleaseJob::ReleaseJob()
+        {
+
+        
+            qname = NULL;
+        
+                property_ReleaseJob  = NULL;
+              
+            isValidReleaseJob  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ReleaseJob",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::ReleaseJob::ReleaseJob(AviaryJob::ControlJob* arg_ReleaseJob)
+        {
+             
+                   qname = NULL;
+             
+               property_ReleaseJob  = NULL;
+             
+            isValidReleaseJob  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ReleaseJob",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ReleaseJob = arg_ReleaseJob;
+            
+        }
+        AviaryJob::ReleaseJob::~ReleaseJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::ReleaseJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for ReleaseJob : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building ReleaseJob element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "ReleaseJob", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJob* element = new AviaryJob::ControlJob();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element ReleaseJob");
+                                      }
+                                      else
+                                      {
+                                          status = setReleaseJob(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for ReleaseJob ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element ReleaseJob missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::ReleaseJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::ReleaseJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::ReleaseJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "ReleaseJob", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidReleaseJob)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property ReleaseJob");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ReleaseJob"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ReleaseJob")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing ReleaseJob element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sReleaseJob",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sReleaseJob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_ReleaseJob->serialize(current_node, parent_element,
+                                                                                 property_ReleaseJob->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ReleaseJob by  Property Number 1
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::ReleaseJob::getProperty1()
+            {
+                return getReleaseJob();
+            }
+
+            /**
+             * getter for ReleaseJob.
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::ReleaseJob::getReleaseJob()
+             {
+                return property_ReleaseJob;
+             }
+
+            /**
+             * setter for ReleaseJob
+             */
+            bool WSF_CALL
+            AviaryJob::ReleaseJob::setReleaseJob(
+                    AviaryJob::ControlJob*  arg_ReleaseJob)
+             {
+                
+
+                if(isValidReleaseJob &&
+                        arg_ReleaseJob == property_ReleaseJob)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_ReleaseJob)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ReleaseJob is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetReleaseJob();
+
+                
+                    if(NULL == arg_ReleaseJob)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_ReleaseJob = arg_ReleaseJob;
+                        isValidReleaseJob = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for ReleaseJob
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJob::resetReleaseJob()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_ReleaseJob != NULL)
+                {
+                   
+                   
+                         delete  property_ReleaseJob;
+                     
+
+                   }
+
+                
+                
+                
+               isValidReleaseJob = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ReleaseJob is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJob::isReleaseJobNil()
+           {
+               return !isValidReleaseJob;
+           }
+
+           /**
+            * Set ReleaseJob to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJob::setReleaseJobNil()
+           {
+               return resetReleaseJob();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJobResponse.cpp
new file mode 100644
index 0000000..dfabed5
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJobResponse.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * ReleaseJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_ReleaseJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the ReleaseJobResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::ReleaseJobResponse::ReleaseJobResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_ReleaseJobResponse  = NULL;
+              
+            isValidReleaseJobResponse  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ReleaseJobResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::ReleaseJobResponse::ReleaseJobResponse(AviaryJob::ControlJobResponse* arg_ReleaseJobResponse)
+        {
+             
+                   qname = NULL;
+             
+               property_ReleaseJobResponse  = NULL;
+             
+            isValidReleaseJobResponse  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ReleaseJobResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ReleaseJobResponse = arg_ReleaseJobResponse;
+            
+        }
+        AviaryJob::ReleaseJobResponse::~ReleaseJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::ReleaseJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for ReleaseJobResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building ReleaseJobResponse element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "ReleaseJobResponse", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJobResponse* element = new AviaryJob::ControlJobResponse();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element ReleaseJobResponse");
+                                      }
+                                      else
+                                      {
+                                          status = setReleaseJobResponse(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for ReleaseJobResponse ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element ReleaseJobResponse missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::ReleaseJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::ReleaseJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::ReleaseJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "ReleaseJobResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidReleaseJobResponse)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property ReleaseJobResponse");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ReleaseJobResponse"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ReleaseJobResponse")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing ReleaseJobResponse element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sReleaseJobResponse",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sReleaseJobResponse>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_ReleaseJobResponse->serialize(current_node, parent_element,
+                                                                                 property_ReleaseJobResponse->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ReleaseJobResponse by  Property Number 1
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::ReleaseJobResponse::getProperty1()
+            {
+                return getReleaseJobResponse();
+            }
+
+            /**
+             * getter for ReleaseJobResponse.
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::ReleaseJobResponse::getReleaseJobResponse()
+             {
+                return property_ReleaseJobResponse;
+             }
+
+            /**
+             * setter for ReleaseJobResponse
+             */
+            bool WSF_CALL
+            AviaryJob::ReleaseJobResponse::setReleaseJobResponse(
+                    AviaryJob::ControlJobResponse*  arg_ReleaseJobResponse)
+             {
+                
+
+                if(isValidReleaseJobResponse &&
+                        arg_ReleaseJobResponse == property_ReleaseJobResponse)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_ReleaseJobResponse)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ReleaseJobResponse is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetReleaseJobResponse();
+
+                
+                    if(NULL == arg_ReleaseJobResponse)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_ReleaseJobResponse = arg_ReleaseJobResponse;
+                        isValidReleaseJobResponse = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for ReleaseJobResponse
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJobResponse::resetReleaseJobResponse()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_ReleaseJobResponse != NULL)
+                {
+                   
+                   
+                         delete  property_ReleaseJobResponse;
+                     
+
+                   }
+
+                
+                
+                
+               isValidReleaseJobResponse = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ReleaseJobResponse is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJobResponse::isReleaseJobResponseNil()
+           {
+               return !isValidReleaseJobResponse;
+           }
+
+           /**
+            * Set ReleaseJobResponse to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJobResponse::setReleaseJobResponseNil()
+           {
+               return resetReleaseJobResponse();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJob.cpp
new file mode 100644
index 0000000..6b8f85e
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJob.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * RemoveJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_RemoveJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the RemoveJob|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::RemoveJob::RemoveJob()
+        {
+
+        
+            qname = NULL;
+        
+                property_RemoveJob  = NULL;
+              
+            isValidRemoveJob  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "RemoveJob",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::RemoveJob::RemoveJob(AviaryJob::ControlJob* arg_RemoveJob)
+        {
+             
+                   qname = NULL;
+             
+               property_RemoveJob  = NULL;
+             
+            isValidRemoveJob  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "RemoveJob",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_RemoveJob = arg_RemoveJob;
+            
+        }
+        AviaryJob::RemoveJob::~RemoveJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::RemoveJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for RemoveJob : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building RemoveJob element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "RemoveJob", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJob* element = new AviaryJob::ControlJob();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element RemoveJob");
+                                      }
+                                      else
+                                      {
+                                          status = setRemoveJob(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for RemoveJob ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element RemoveJob missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::RemoveJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::RemoveJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::RemoveJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "RemoveJob", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidRemoveJob)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property RemoveJob");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("RemoveJob"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("RemoveJob")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing RemoveJob element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sRemoveJob",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sRemoveJob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_RemoveJob->serialize(current_node, parent_element,
+                                                                                 property_RemoveJob->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for RemoveJob by  Property Number 1
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::RemoveJob::getProperty1()
+            {
+                return getRemoveJob();
+            }
+
+            /**
+             * getter for RemoveJob.
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::RemoveJob::getRemoveJob()
+             {
+                return property_RemoveJob;
+             }
+
+            /**
+             * setter for RemoveJob
+             */
+            bool WSF_CALL
+            AviaryJob::RemoveJob::setRemoveJob(
+                    AviaryJob::ControlJob*  arg_RemoveJob)
+             {
+                
+
+                if(isValidRemoveJob &&
+                        arg_RemoveJob == property_RemoveJob)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_RemoveJob)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"RemoveJob is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetRemoveJob();
+
+                
+                    if(NULL == arg_RemoveJob)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_RemoveJob = arg_RemoveJob;
+                        isValidRemoveJob = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for RemoveJob
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJob::resetRemoveJob()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_RemoveJob != NULL)
+                {
+                   
+                   
+                         delete  property_RemoveJob;
+                     
+
+                   }
+
+                
+                
+                
+               isValidRemoveJob = false; 
+               return true;
+           }
+
+           /**
+            * Check whether RemoveJob is nill
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJob::isRemoveJobNil()
+           {
+               return !isValidRemoveJob;
+           }
+
+           /**
+            * Set RemoveJob to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJob::setRemoveJobNil()
+           {
+               return resetRemoveJob();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJobResponse.cpp
new file mode 100644
index 0000000..952425c
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJobResponse.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * RemoveJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_RemoveJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the RemoveJobResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::RemoveJobResponse::RemoveJobResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_RemoveJobResponse  = NULL;
+              
+            isValidRemoveJobResponse  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "RemoveJobResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::RemoveJobResponse::RemoveJobResponse(AviaryJob::ControlJobResponse* arg_RemoveJobResponse)
+        {
+             
+                   qname = NULL;
+             
+               property_RemoveJobResponse  = NULL;
+             
+            isValidRemoveJobResponse  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "RemoveJobResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_RemoveJobResponse = arg_RemoveJobResponse;
+            
+        }
+        AviaryJob::RemoveJobResponse::~RemoveJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::RemoveJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for RemoveJobResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building RemoveJobResponse element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "RemoveJobResponse", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJobResponse* element = new AviaryJob::ControlJobResponse();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element RemoveJobResponse");
+                                      }
+                                      else
+                                      {
+                                          status = setRemoveJobResponse(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for RemoveJobResponse ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element RemoveJobResponse missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::RemoveJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::RemoveJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::RemoveJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "RemoveJobResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidRemoveJobResponse)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property RemoveJobResponse");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("RemoveJobResponse"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("RemoveJobResponse")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing RemoveJobResponse element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sRemoveJobResponse",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sRemoveJobResponse>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_RemoveJobResponse->serialize(current_node, parent_element,
+                                                                                 property_RemoveJobResponse->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for RemoveJobResponse by  Property Number 1
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::RemoveJobResponse::getProperty1()
+            {
+                return getRemoveJobResponse();
+            }
+
+            /**
+             * getter for RemoveJobResponse.
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::RemoveJobResponse::getRemoveJobResponse()
+             {
+                return property_RemoveJobResponse;
+             }
+
+            /**
+             * setter for RemoveJobResponse
+             */
+            bool WSF_CALL
+            AviaryJob::RemoveJobResponse::setRemoveJobResponse(
+                    AviaryJob::ControlJobResponse*  arg_RemoveJobResponse)
+             {
+                
+
+                if(isValidRemoveJobResponse &&
+                        arg_RemoveJobResponse == property_RemoveJobResponse)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_RemoveJobResponse)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"RemoveJobResponse is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetRemoveJobResponse();
+
+                
+                    if(NULL == arg_RemoveJobResponse)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_RemoveJobResponse = arg_RemoveJobResponse;
+                        isValidRemoveJobResponse = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for RemoveJobResponse
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJobResponse::resetRemoveJobResponse()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_RemoveJobResponse != NULL)
+                {
+                   
+                   
+                         delete  property_RemoveJobResponse;
+                     
+
+                   }
+
+                
+                
+                
+               isValidRemoveJobResponse = false; 
+               return true;
+           }
+
+           /**
+            * Check whether RemoveJobResponse is nill
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJobResponse::isRemoveJobResponseNil()
+           {
+               return !isValidRemoveJobResponse;
+           }
+
+           /**
+            * Set RemoveJobResponse to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJobResponse::setRemoveJobResponseNil()
+           {
+               return resetRemoveJobResponse();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttribute.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttribute.cpp
new file mode 100644
index 0000000..5efdb33
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttribute.cpp
@@ -0,0 +1,720 @@
+
+
+        /**
+         * SetJobAttribute.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_SetJobAttribute.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the SetJobAttribute|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::SetJobAttribute::SetJobAttribute()
+        {
+
+        
+            qname = NULL;
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Attribute  = NULL;
+              
+            isValidAttribute  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "SetJobAttribute",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::SetJobAttribute::SetJobAttribute(AviaryCommon::JobID* arg_Id,AviaryCommon::Attribute* arg_Attribute)
+        {
+             
+                   qname = NULL;
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Attribute  = NULL;
+             
+            isValidAttribute  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "SetJobAttribute",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Id = arg_Id;
+            
+                    property_Attribute = arg_Attribute;
+            
+        }
+        AviaryJob::SetJobAttribute::~SetJobAttribute()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::SetJobAttribute::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for SetJobAttribute : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building attribute element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "attribute", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("attribute", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("attribute", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Attribute* element = new AviaryCommon::Attribute();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element attribute");
+                                      }
+                                      else
+                                      {
+                                          status = setAttribute(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for attribute ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element attribute missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::SetJobAttribute::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::SetJobAttribute::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::SetJobAttribute::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "SetJobAttribute", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidAttribute)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property attribute");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("attribute"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("attribute")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing attribute element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sattribute",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sattribute>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Attribute->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Attribute->serialize(current_node, parent_element,
+                                                                                 property_Attribute->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Attribute->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::SetJobAttribute::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::SetJobAttribute::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryJob::SetJobAttribute::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for attribute by  Property Number 2
+             */
+            AviaryCommon::Attribute* WSF_CALL
+            AviaryJob::SetJobAttribute::getProperty2()
+            {
+                return getAttribute();
+            }
+
+            /**
+             * getter for attribute.
+             */
+            AviaryCommon::Attribute* WSF_CALL
+            AviaryJob::SetJobAttribute::getAttribute()
+             {
+                return property_Attribute;
+             }
+
+            /**
+             * setter for attribute
+             */
+            bool WSF_CALL
+            AviaryJob::SetJobAttribute::setAttribute(
+                    AviaryCommon::Attribute*  arg_Attribute)
+             {
+                
+
+                if(isValidAttribute &&
+                        arg_Attribute == property_Attribute)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Attribute)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"attribute is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetAttribute();
+
+                
+                    if(NULL == arg_Attribute)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Attribute = arg_Attribute;
+                        isValidAttribute = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for attribute
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::resetAttribute()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Attribute != NULL)
+                {
+                   
+                   
+                         delete  property_Attribute;
+                     
+
+                   }
+
+                
+                
+                
+               isValidAttribute = false; 
+               return true;
+           }
+
+           /**
+            * Check whether attribute is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::isAttributeNil()
+           {
+               return !isValidAttribute;
+           }
+
+           /**
+            * Set attribute to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::setAttributeNil()
+           {
+               return resetAttribute();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttributeResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttributeResponse.cpp
new file mode 100644
index 0000000..a8bc9e7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttributeResponse.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * SetJobAttributeResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_SetJobAttributeResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the SetJobAttributeResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::SetJobAttributeResponse::SetJobAttributeResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_SetJobAttributeResponse  = NULL;
+              
+            isValidSetJobAttributeResponse  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "SetJobAttributeResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::SetJobAttributeResponse::SetJobAttributeResponse(AviaryJob::ControlJobResponse* arg_SetJobAttributeResponse)
+        {
+             
+                   qname = NULL;
+             
+               property_SetJobAttributeResponse  = NULL;
+             
+            isValidSetJobAttributeResponse  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "SetJobAttributeResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_SetJobAttributeResponse = arg_SetJobAttributeResponse;
+            
+        }
+        AviaryJob::SetJobAttributeResponse::~SetJobAttributeResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::SetJobAttributeResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for SetJobAttributeResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building SetJobAttributeResponse element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "SetJobAttributeResponse", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJobResponse* element = new AviaryJob::ControlJobResponse();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element SetJobAttributeResponse");
+                                      }
+                                      else
+                                      {
+                                          status = setSetJobAttributeResponse(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for SetJobAttributeResponse ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element SetJobAttributeResponse missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::SetJobAttributeResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::SetJobAttributeResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::SetJobAttributeResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "SetJobAttributeResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidSetJobAttributeResponse)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property SetJobAttributeResponse");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("SetJobAttributeResponse"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("SetJobAttributeResponse")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing SetJobAttributeResponse element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sSetJobAttributeResponse",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sSetJobAttributeResponse>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_SetJobAttributeResponse->serialize(current_node, parent_element,
+                                                                                 property_SetJobAttributeResponse->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for SetJobAttributeResponse by  Property Number 1
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::SetJobAttributeResponse::getProperty1()
+            {
+                return getSetJobAttributeResponse();
+            }
+
+            /**
+             * getter for SetJobAttributeResponse.
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::SetJobAttributeResponse::getSetJobAttributeResponse()
+             {
+                return property_SetJobAttributeResponse;
+             }
+
+            /**
+             * setter for SetJobAttributeResponse
+             */
+            bool WSF_CALL
+            AviaryJob::SetJobAttributeResponse::setSetJobAttributeResponse(
+                    AviaryJob::ControlJobResponse*  arg_SetJobAttributeResponse)
+             {
+                
+
+                if(isValidSetJobAttributeResponse &&
+                        arg_SetJobAttributeResponse == property_SetJobAttributeResponse)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_SetJobAttributeResponse)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"SetJobAttributeResponse is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetSetJobAttributeResponse();
+
+                
+                    if(NULL == arg_SetJobAttributeResponse)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_SetJobAttributeResponse = arg_SetJobAttributeResponse;
+                        isValidSetJobAttributeResponse = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for SetJobAttributeResponse
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttributeResponse::resetSetJobAttributeResponse()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_SetJobAttributeResponse != NULL)
+                {
+                   
+                   
+                         delete  property_SetJobAttributeResponse;
+                     
+
+                   }
+
+                
+                
+                
+               isValidSetJobAttributeResponse = false; 
+               return true;
+           }
+
+           /**
+            * Check whether SetJobAttributeResponse is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttributeResponse::isSetJobAttributeResponseNil()
+           {
+               return !isValidSetJobAttributeResponse;
+           }
+
+           /**
+            * Set SetJobAttributeResponse to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttributeResponse::setSetJobAttributeResponseNil()
+           {
+               return resetSetJobAttributeResponse();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJob.cpp
new file mode 100644
index 0000000..2a6970f
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJob.cpp
@@ -0,0 +1,3030 @@
+
+
+        /**
+         * SubmitJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_SubmitJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the SubmitJob|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::SubmitJob::SubmitJob()
+        {
+
+        
+            qname = NULL;
+        
+                    property_Cmd;
+                
+            isValidCmd  = false;
+        
+                    property_Args;
+                
+            isValidArgs  = false;
+        
+                    property_Owner;
+                
+            isValidOwner  = false;
+        
+                    property_Iwd;
+                
+            isValidIwd  = false;
+        
+                    property_Submission_name;
+                
+            isValidSubmission_name  = false;
+        
+                property_Requirements  = NULL;
+              
+            isValidRequirements  = false;
+        
+                property_Extra  = NULL;
+              
+            isValidExtra  = false;
+        
+            isValidAllowOverrides  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "SubmitJob",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::SubmitJob::SubmitJob(std::string arg_Cmd,std::string arg_Args,std::string arg_Owner,std::string arg_Iwd,std::string arg_Submission_name,std::vector<AviaryCommon::ResourceConstraint*>* arg_Requirements,std::vector<AviaryCommon::Attribute*>* arg_Extra,bool arg_AllowOverrides)
+        {
+             
+                   qname = NULL;
+             
+                 property_Cmd;
+             
+            isValidCmd  = true;
+            
+                 property_Args;
+             
+            isValidArgs  = true;
+            
+                 property_Owner;
+             
+            isValidOwner  = true;
+            
+                 property_Iwd;
+             
+            isValidIwd  = true;
+            
+                 property_Submission_name;
+             
+            isValidSubmission_name  = true;
+            
+               property_Requirements  = NULL;
+             
+            isValidRequirements  = true;
+            
+               property_Extra  = NULL;
+             
+            isValidExtra  = true;
+            
+            isValidAllowOverrides  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "SubmitJob",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Cmd = arg_Cmd;
+            
+                    property_Args = arg_Args;
+            
+                    property_Owner = arg_Owner;
+            
+                    property_Iwd = arg_Iwd;
+            
+                    property_Submission_name = arg_Submission_name;
+            
+                    property_Requirements = arg_Requirements;
+            
+                    property_Extra = arg_Extra;
+            
+                    property_AllowOverrides = arg_AllowOverrides;
+            
+        }
+        AviaryJob::SubmitJob::~SubmitJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::SubmitJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for SubmitJob : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+
+                     
+                     /*
+                      * building cmd element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "cmd", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("cmd", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("cmd", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setCmd(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element cmd");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setCmd("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for cmd ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element cmd missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building args element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "args", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setArgs(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element args");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setArgs("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for args ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building owner element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "owner", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("owner", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("owner", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setOwner(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element owner");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setOwner("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for owner ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element owner missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building iwd element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "iwd", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("iwd", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("iwd", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setIwd(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element iwd");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setIwd("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for iwd ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element iwd missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building submission_name element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "submission_name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submission_name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submission_name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setSubmission_name(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element submission_name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setSubmission_name("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for submission_name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                       { 
+                    /*
+                     * building Requirements array
+                     */
+                       std::vector<AviaryCommon::ResourceConstraint*>* arr_list =new std::vector<AviaryCommon::ResourceConstraint*>();
+                   
+
+                     
+                     /*
+                      * building requirements element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "requirements", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = (is_early_node_valid?axiom_node_get_next_sibling(current_node, Environment::getEnv()):current_node); !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("requirements", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::ResourceConstraint* element = new AviaryCommon::ResourceConstraint();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element requirements ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for requirements ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"requirements (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setRequirements(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                       { 
+                    /*
+                     * building Extra array
+                     */
+                       std::vector<AviaryCommon::Attribute*>* arr_list =new std::vector<AviaryCommon::Attribute*>();
+                   
+
+                     
+                     /*
+                      * building extra element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "extra", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = (is_early_node_valid?axiom_node_get_next_sibling(current_node, Environment::getEnv()):current_node); !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("extra", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::Attribute* element = new AviaryCommon::Attribute();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element extra ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for extra ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"extra (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setExtra(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "allowOverrides"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "allowOverrides", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "allowOverrides");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setAllowOverrides(true);
+                           }
+                           else
+                           {
+                               setAllowOverrides(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::SubmitJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::SubmitJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::SubmitJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t *text_value_1;
+                    axis2_char_t *text_value_1_temp;
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t *text_value_4;
+                    axis2_char_t *text_value_4_temp;
+                    
+                    axis2_char_t *text_value_5;
+                    axis2_char_t *text_value_5_temp;
+                    
+                    axis2_char_t text_value_6[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_7[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_8[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "SubmitJob", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidAllowOverrides)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_AllowOverrides)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("allowOverrides")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "allowOverrides",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCmd)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property cmd");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("cmd"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("cmd")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing cmd element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scmd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scmd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_1 = (axis2_char_t*)property_Cmd.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_1_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_1, true);
+                           if (text_value_1_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1_temp, axutil_strlen(text_value_1_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_1_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1, axutil_strlen(text_value_1));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidArgs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("args"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("args")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing args element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sargs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sargs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Args.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidOwner)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property owner");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("owner"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("owner")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing owner element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sowner>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sowner>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_Owner.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIwd)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property iwd");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("iwd"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("iwd")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing iwd element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%siwd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%siwd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_4 = (axis2_char_t*)property_Iwd.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_4_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_4, true);
+                           if (text_value_4_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_4_temp, axutil_strlen(text_value_4_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_4_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidSubmission_name)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("submission_name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("submission_name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing submission_name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%ssubmission_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%ssubmission_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_5 = (axis2_char_t*)property_Submission_name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_5_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_5, true);
+                           if (text_value_5_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_5_temp, axutil_strlen(text_value_5_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_5_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_5, axutil_strlen(text_value_5));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidRequirements)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("requirements"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("requirements")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Requirements array
+                      */
+                     if (property_Requirements != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%srequirements",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%srequirements>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Requirements->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::ResourceConstraint* element = (*property_Requirements)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing requirements element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidExtra)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("extra"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("extra")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Extra array
+                      */
+                     if (property_Extra != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sextra",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sextra>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Extra->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::Attribute* element = (*property_Extra)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing extra element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidAllowOverrides)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_AllowOverrides)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "allowOverrides", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for cmd by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty1()
+            {
+                return getCmd();
+            }
+
+            /**
+             * getter for cmd.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getCmd()
+             {
+                return property_Cmd;
+             }
+
+            /**
+             * setter for cmd
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setCmd(
+                    const std::string  arg_Cmd)
+             {
+                
+
+                if(isValidCmd &&
+                        arg_Cmd == property_Cmd)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Cmd.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"cmd is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetCmd();
+
+                
+                        property_Cmd = std::string(arg_Cmd.c_str());
+                        isValidCmd = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for cmd
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetCmd()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidCmd = false; 
+               return true;
+           }
+
+           /**
+            * Check whether cmd is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isCmdNil()
+           {
+               return !isValidCmd;
+           }
+
+           /**
+            * Set cmd to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setCmdNil()
+           {
+               return resetCmd();
+           }
+
+           
+
+            /**
+             * Getter for args by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty2()
+            {
+                return getArgs();
+            }
+
+            /**
+             * getter for args.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getArgs()
+             {
+                return property_Args;
+             }
+
+            /**
+             * setter for args
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setArgs(
+                    const std::string  arg_Args)
+             {
+                
+
+                if(isValidArgs &&
+                        arg_Args == property_Args)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetArgs();
+
+                
+                        property_Args = std::string(arg_Args.c_str());
+                        isValidArgs = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for args
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetArgs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidArgs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether args is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isArgsNil()
+           {
+               return !isValidArgs;
+           }
+
+           /**
+            * Set args to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setArgsNil()
+           {
+               return resetArgs();
+           }
+
+           
+
+            /**
+             * Getter for owner by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty3()
+            {
+                return getOwner();
+            }
+
+            /**
+             * getter for owner.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getOwner()
+             {
+                return property_Owner;
+             }
+
+            /**
+             * setter for owner
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setOwner(
+                    const std::string  arg_Owner)
+             {
+                
+
+                if(isValidOwner &&
+                        arg_Owner == property_Owner)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Owner.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"owner is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetOwner();
+
+                
+                        property_Owner = std::string(arg_Owner.c_str());
+                        isValidOwner = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for owner
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetOwner()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidOwner = false; 
+               return true;
+           }
+
+           /**
+            * Check whether owner is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isOwnerNil()
+           {
+               return !isValidOwner;
+           }
+
+           /**
+            * Set owner to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setOwnerNil()
+           {
+               return resetOwner();
+           }
+
+           
+
+            /**
+             * Getter for iwd by  Property Number 4
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty4()
+            {
+                return getIwd();
+            }
+
+            /**
+             * getter for iwd.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getIwd()
+             {
+                return property_Iwd;
+             }
+
+            /**
+             * setter for iwd
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setIwd(
+                    const std::string  arg_Iwd)
+             {
+                
+
+                if(isValidIwd &&
+                        arg_Iwd == property_Iwd)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Iwd.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"iwd is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetIwd();
+
+                
+                        property_Iwd = std::string(arg_Iwd.c_str());
+                        isValidIwd = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for iwd
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetIwd()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidIwd = false; 
+               return true;
+           }
+
+           /**
+            * Check whether iwd is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isIwdNil()
+           {
+               return !isValidIwd;
+           }
+
+           /**
+            * Set iwd to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setIwdNil()
+           {
+               return resetIwd();
+           }
+
+           
+
+            /**
+             * Getter for submission_name by  Property Number 5
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty5()
+            {
+                return getSubmission_name();
+            }
+
+            /**
+             * getter for submission_name.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getSubmission_name()
+             {
+                return property_Submission_name;
+             }
+
+            /**
+             * setter for submission_name
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setSubmission_name(
+                    const std::string  arg_Submission_name)
+             {
+                
+
+                if(isValidSubmission_name &&
+                        arg_Submission_name == property_Submission_name)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetSubmission_name();
+
+                
+                        property_Submission_name = std::string(arg_Submission_name.c_str());
+                        isValidSubmission_name = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for submission_name
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetSubmission_name()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidSubmission_name = false; 
+               return true;
+           }
+
+           /**
+            * Check whether submission_name is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isSubmission_nameNil()
+           {
+               return !isValidSubmission_name;
+           }
+
+           /**
+            * Set submission_name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setSubmission_nameNil()
+           {
+               return resetSubmission_name();
+           }
+
+           
+
+            /**
+             * Getter for requirements by  Property Number 6
+             */
+            std::vector<AviaryCommon::ResourceConstraint*>* WSF_CALL
+            AviaryJob::SubmitJob::getProperty6()
+            {
+                return getRequirements();
+            }
+
+            /**
+             * getter for requirements.
+             */
+            std::vector<AviaryCommon::ResourceConstraint*>* WSF_CALL
+            AviaryJob::SubmitJob::getRequirements()
+             {
+                return property_Requirements;
+             }
+
+            /**
+             * setter for requirements
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setRequirements(
+                    std::vector<AviaryCommon::ResourceConstraint*>*  arg_Requirements)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidRequirements &&
+                        arg_Requirements == property_Requirements)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Requirements->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"requirements has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Requirements)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetRequirements();
+
+                
+                    if(NULL == arg_Requirements)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Requirements = arg_Requirements;
+                        if(non_nil_exists)
+                        {
+                            isValidRequirements = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of requirements.
+             */
+            AviaryCommon::ResourceConstraint* WSF_CALL
+            AviaryJob::SubmitJob::getRequirementsAt(int i)
+            {
+                AviaryCommon::ResourceConstraint* ret_val;
+                if(property_Requirements == NULL)
+                {
+                    return (AviaryCommon::ResourceConstraint*)0;
+                }
+                ret_val =   (*property_Requirements)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of requirements.
+             */
+           bool WSF_CALL
+            AviaryJob::SubmitJob::setRequirementsAt(int i,
+                    AviaryCommon::ResourceConstraint* arg_Requirements)
+            {
+                 AviaryCommon::ResourceConstraint* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidRequirements &&
+                    property_Requirements &&
+                  
+                    arg_Requirements == (*property_Requirements)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Requirements == NULL)
+                {
+                    property_Requirements = new std::vector<AviaryCommon::ResourceConstraint*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Requirements)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidRequirements = true;
+                        (*property_Requirements)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Requirements)[i] = arg_Requirements;
+                  
+
+               isValidRequirements = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to requirements.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::addRequirements(
+                    AviaryCommon::ResourceConstraint* arg_Requirements)
+             {
+
+                
+                    if( NULL == arg_Requirements
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Requirements == NULL)
+                {
+                    property_Requirements = new std::vector<AviaryCommon::ResourceConstraint*>();
+                }
+              
+               property_Requirements->push_back(arg_Requirements);
+              
+                isValidRequirements = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the requirements array.
+             */
+            int WSF_CALL
+            AviaryJob::SubmitJob::sizeofRequirements()
+            {
+
+                if(property_Requirements == NULL)
+                {
+                    return 0;
+                }
+                return property_Requirements->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::removeRequirementsAt(int i)
+            {
+                return setRequirementsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for requirements
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetRequirements()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Requirements != NULL)
+                {
+                  std::vector<AviaryCommon::ResourceConstraint*>::iterator it =  property_Requirements->begin();
+                  for( ; it <  property_Requirements->end() ; ++it)
+                  {
+                     AviaryCommon::ResourceConstraint* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Requirements)
+                 delete property_Requirements;
+                
+               isValidRequirements = false; 
+               return true;
+           }
+
+           /**
+            * Check whether requirements is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isRequirementsNil()
+           {
+               return !isValidRequirements;
+           }
+
+           /**
+            * Set requirements to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setRequirementsNil()
+           {
+               return resetRequirements();
+           }
+
+           
+           /**
+            * Check whether requirements is nill at i
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isRequirementsNilAt(int i)
+           {
+               return (isValidRequirements == false ||
+                       NULL == property_Requirements ||
+                     NULL == (*property_Requirements)[i]);
+            }
+
+           /**
+            * Set requirements to nil at i
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setRequirementsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Requirements == NULL ||
+                            isValidRequirements == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Requirements->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Requirements)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of requirements is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Requirements == NULL)
+                {
+                    isValidRequirements = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::ResourceConstraint* element = (*property_Requirements)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidRequirements = false;
+                        (*property_Requirements)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Requirements)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for extra by  Property Number 7
+             */
+            std::vector<AviaryCommon::Attribute*>* WSF_CALL
+            AviaryJob::SubmitJob::getProperty7()
+            {
+                return getExtra();
+            }
+
+            /**
+             * getter for extra.
+             */
+            std::vector<AviaryCommon::Attribute*>* WSF_CALL
+            AviaryJob::SubmitJob::getExtra()
+             {
+                return property_Extra;
+             }
+
+            /**
+             * setter for extra
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setExtra(
+                    std::vector<AviaryCommon::Attribute*>*  arg_Extra)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidExtra &&
+                        arg_Extra == property_Extra)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Extra->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"extra has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Extra)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetExtra();
+
+                
+                    if(NULL == arg_Extra)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Extra = arg_Extra;
+                        if(non_nil_exists)
+                        {
+                            isValidExtra = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of extra.
+             */
+            AviaryCommon::Attribute* WSF_CALL
+            AviaryJob::SubmitJob::getExtraAt(int i)
+            {
+                AviaryCommon::Attribute* ret_val;
+                if(property_Extra == NULL)
+                {
+                    return (AviaryCommon::Attribute*)0;
+                }
+                ret_val =   (*property_Extra)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of extra.
+             */
+           bool WSF_CALL
+            AviaryJob::SubmitJob::setExtraAt(int i,
+                    AviaryCommon::Attribute* arg_Extra)
+            {
+                 AviaryCommon::Attribute* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidExtra &&
+                    property_Extra &&
+                  
+                    arg_Extra == (*property_Extra)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Extra == NULL)
+                {
+                    property_Extra = new std::vector<AviaryCommon::Attribute*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Extra)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidExtra = true;
+                        (*property_Extra)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Extra)[i] = arg_Extra;
+                  
+
+               isValidExtra = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to extra.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::addExtra(
+                    AviaryCommon::Attribute* arg_Extra)
+             {
+
+                
+                    if( NULL == arg_Extra
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Extra == NULL)
+                {
+                    property_Extra = new std::vector<AviaryCommon::Attribute*>();
+                }
+              
+               property_Extra->push_back(arg_Extra);
+              
+                isValidExtra = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the extra array.
+             */
+            int WSF_CALL
+            AviaryJob::SubmitJob::sizeofExtra()
+            {
+
+                if(property_Extra == NULL)
+                {
+                    return 0;
+                }
+                return property_Extra->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::removeExtraAt(int i)
+            {
+                return setExtraNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for extra
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetExtra()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Extra != NULL)
+                {
+                  std::vector<AviaryCommon::Attribute*>::iterator it =  property_Extra->begin();
+                  for( ; it <  property_Extra->end() ; ++it)
+                  {
+                     AviaryCommon::Attribute* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Extra)
+                 delete property_Extra;
+                
+               isValidExtra = false; 
+               return true;
+           }
+
+           /**
+            * Check whether extra is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isExtraNil()
+           {
+               return !isValidExtra;
+           }
+
+           /**
+            * Set extra to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setExtraNil()
+           {
+               return resetExtra();
+           }
+
+           
+           /**
+            * Check whether extra is nill at i
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isExtraNilAt(int i)
+           {
+               return (isValidExtra == false ||
+                       NULL == property_Extra ||
+                     NULL == (*property_Extra)[i]);
+            }
+
+           /**
+            * Set extra to nil at i
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setExtraNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Extra == NULL ||
+                            isValidExtra == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Extra->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Extra)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of extra is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Extra == NULL)
+                {
+                    isValidExtra = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::Attribute* element = (*property_Extra)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidExtra = false;
+                        (*property_Extra)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Extra)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for allowOverrides by  Property Number 8
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::getProperty8()
+            {
+                return getAllowOverrides();
+            }
+
+            /**
+             * getter for allowOverrides.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::getAllowOverrides()
+             {
+                return property_AllowOverrides;
+             }
+
+            /**
+             * setter for allowOverrides
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setAllowOverrides(
+                    bool  arg_AllowOverrides)
+             {
+                
+
+                if(isValidAllowOverrides &&
+                        arg_AllowOverrides == property_AllowOverrides)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetAllowOverrides();
+
+                
+                        property_AllowOverrides = arg_AllowOverrides;
+                        isValidAllowOverrides = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for allowOverrides
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetAllowOverrides()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidAllowOverrides = false; 
+               return true;
+           }
+
+           /**
+            * Check whether allowOverrides is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isAllowOverridesNil()
+           {
+               return !isValidAllowOverrides;
+           }
+
+           /**
+            * Set allowOverrides to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setAllowOverridesNil()
+           {
+               return resetAllowOverrides();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJobResponse.cpp
new file mode 100644
index 0000000..fe0f2ed
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJobResponse.cpp
@@ -0,0 +1,701 @@
+
+
+        /**
+         * SubmitJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_SubmitJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the SubmitJobResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::SubmitJobResponse::SubmitJobResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "SubmitJobResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::SubmitJobResponse::SubmitJobResponse(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status)
+        {
+             
+                   qname = NULL;
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "SubmitJobResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+        }
+        AviaryJob::SubmitJobResponse::~SubmitJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::SubmitJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for SubmitJobResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::SubmitJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::SubmitJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::SubmitJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "SubmitJobResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::SubmitJobResponse::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::SubmitJobResponse::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJobResponse::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryJob::SubmitJobResponse::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryJob::SubmitJobResponse::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJobResponse::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobData.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobData.cpp
new file mode 100644
index 0000000..142f4b7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobData.cpp
@@ -0,0 +1,910 @@
+
+
+        /**
+         * GetJobData.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobData.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobData|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobData::GetJobData()
+        {
+
+        
+            qname = NULL;
+        
+                property_Data  = NULL;
+              
+            isValidData  = false;
+        
+            isValidMax_bytes  = false;
+        
+            isValidFrom_end  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobData",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobData::GetJobData(AviaryCommon::JobData* arg_Data,int arg_Max_bytes,bool arg_From_end)
+        {
+             
+                   qname = NULL;
+             
+               property_Data  = NULL;
+             
+            isValidData  = true;
+            
+            isValidMax_bytes  = true;
+            
+            isValidFrom_end  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobData",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Data = arg_Data;
+            
+                    property_Max_bytes = arg_Max_bytes;
+            
+                    property_From_end = arg_From_end;
+            
+        }
+        AviaryQuery::GetJobData::~GetJobData()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobData::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobData : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building data element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "data", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("data", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("data", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobData* element = new AviaryCommon::JobData();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element data");
+                                      }
+                                      else
+                                      {
+                                          status = setData(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for data ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element data missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building max_bytes element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "max_bytes", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("max_bytes", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("max_bytes", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setMax_bytes(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element max_bytes");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for max_bytes ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element max_bytes missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building from_end element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "from_end", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("from_end", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("from_end", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            if (!axutil_strcasecmp(text_value , "true"))
+                                            {
+                                                status = setFrom_end(true);
+                                            }
+                                            else
+                                            {
+                                                status = setFrom_end(false);
+                                            }
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element from_end");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for from_end ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobData::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobData::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobData::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobData", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidData)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property data");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("data"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("data")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing data element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sdata",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sdata>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Data->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Data->serialize(current_node, parent_element,
+                                                                                 property_Data->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Data->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidMax_bytes)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property max_bytes");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("max_bytes"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("max_bytes")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing max_bytes element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%smax_bytes>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%smax_bytes>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_2, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Max_bytes);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidFrom_end)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("from_end"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("from_end")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing from_end element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sfrom_end>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sfrom_end>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           strcpy(text_value_3, (property_From_end)?"true":"false");
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for data by  Property Number 1
+             */
+            AviaryCommon::JobData* WSF_CALL
+            AviaryQuery::GetJobData::getProperty1()
+            {
+                return getData();
+            }
+
+            /**
+             * getter for data.
+             */
+            AviaryCommon::JobData* WSF_CALL
+            AviaryQuery::GetJobData::getData()
+             {
+                return property_Data;
+             }
+
+            /**
+             * setter for data
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::setData(
+                    AviaryCommon::JobData*  arg_Data)
+             {
+                
+
+                if(isValidData &&
+                        arg_Data == property_Data)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Data)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"data is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetData();
+
+                
+                    if(NULL == arg_Data)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Data = arg_Data;
+                        isValidData = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for data
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::resetData()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Data != NULL)
+                {
+                   
+                   
+                         delete  property_Data;
+                     
+
+                   }
+
+                
+                
+                
+               isValidData = false; 
+               return true;
+           }
+
+           /**
+            * Check whether data is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::isDataNil()
+           {
+               return !isValidData;
+           }
+
+           /**
+            * Set data to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::setDataNil()
+           {
+               return resetData();
+           }
+
+           
+
+            /**
+             * Getter for max_bytes by  Property Number 2
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobData::getProperty2()
+            {
+                return getMax_bytes();
+            }
+
+            /**
+             * getter for max_bytes.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobData::getMax_bytes()
+             {
+                return property_Max_bytes;
+             }
+
+            /**
+             * setter for max_bytes
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::setMax_bytes(
+                    const int  arg_Max_bytes)
+             {
+                
+
+                if(isValidMax_bytes &&
+                        arg_Max_bytes == property_Max_bytes)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetMax_bytes();
+
+                
+                        property_Max_bytes = arg_Max_bytes;
+                        isValidMax_bytes = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for max_bytes
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::resetMax_bytes()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidMax_bytes = false; 
+               return true;
+           }
+
+           /**
+            * Check whether max_bytes is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::isMax_bytesNil()
+           {
+               return !isValidMax_bytes;
+           }
+
+           /**
+            * Set max_bytes to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::setMax_bytesNil()
+           {
+               return resetMax_bytes();
+           }
+
+           
+
+            /**
+             * Getter for from_end by  Property Number 3
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::getProperty3()
+            {
+                return getFrom_end();
+            }
+
+            /**
+             * getter for from_end.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::getFrom_end()
+             {
+                return property_From_end;
+             }
+
+            /**
+             * setter for from_end
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::setFrom_end(
+                    bool  arg_From_end)
+             {
+                
+
+                if(isValidFrom_end &&
+                        arg_From_end == property_From_end)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetFrom_end();
+
+                
+                        property_From_end = arg_From_end;
+                        isValidFrom_end = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for from_end
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::resetFrom_end()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidFrom_end = false; 
+               return true;
+           }
+
+           /**
+            * Check whether from_end is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::isFrom_endNil()
+           {
+               return !isValidFrom_end;
+           }
+
+           /**
+            * Set from_end to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::setFrom_endNil()
+           {
+               return resetFrom_end();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDataResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDataResponse.cpp
new file mode 100644
index 0000000..10256d7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDataResponse.cpp
@@ -0,0 +1,1511 @@
+
+
+        /**
+         * GetJobDataResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobDataResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobDataResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobDataResponse::GetJobDataResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Data  = NULL;
+              
+            isValidData  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                    property_File_name;
+                
+            isValidFile_name  = false;
+        
+            isValidFile_size  = false;
+        
+                    property_Content;
+                
+            isValidContent  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobDataResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobDataResponse::GetJobDataResponse(AviaryCommon::JobData* arg_Data,AviaryCommon::Status* arg_Status,std::string arg_File_name,int arg_File_size,std::string arg_Content)
+        {
+             
+                   qname = NULL;
+             
+               property_Data  = NULL;
+             
+            isValidData  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+                 property_File_name;
+             
+            isValidFile_name  = true;
+            
+            isValidFile_size  = true;
+            
+                 property_Content;
+             
+            isValidContent  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobDataResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Data = arg_Data;
+            
+                    property_Status = arg_Status;
+            
+                    property_File_name = arg_File_name;
+            
+                    property_File_size = arg_File_size;
+            
+                    property_Content = arg_Content;
+            
+        }
+        AviaryQuery::GetJobDataResponse::~GetJobDataResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobDataResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobDataResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building data element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "data", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("data", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("data", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobData* element = new AviaryCommon::JobData();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element data");
+                                      }
+                                      else
+                                      {
+                                          status = setData(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for data ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element data missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building file_name element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "file_name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("file_name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("file_name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setFile_name(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element file_name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setFile_name("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for file_name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building file_size element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "file_size", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("file_size", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("file_size", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setFile_size(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element file_size");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for file_size ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building content element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "content", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("content", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("content", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setContent(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element content");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setContent("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for content ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobDataResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobDataResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobDataResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t text_value_4[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_5;
+                    axis2_char_t *text_value_5_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobDataResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidData)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property data");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("data"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("data")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing data element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sdata",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sdata>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Data->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Data->serialize(current_node, parent_element,
+                                                                                 property_Data->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Data->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidFile_name)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("file_name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("file_name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing file_name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sfile_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sfile_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_File_name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidFile_size)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("file_size"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("file_size")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing file_size element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sfile_size>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sfile_size>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_4, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_File_size);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidContent)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("content"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("content")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing content element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scontent>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scontent>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_5 = (axis2_char_t*)property_Content.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_5_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_5, true);
+                           if (text_value_5_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_5_temp, axutil_strlen(text_value_5_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_5_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_5, axutil_strlen(text_value_5));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for data by  Property Number 1
+             */
+            AviaryCommon::JobData* WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty1()
+            {
+                return getData();
+            }
+
+            /**
+             * getter for data.
+             */
+            AviaryCommon::JobData* WSF_CALL
+            AviaryQuery::GetJobDataResponse::getData()
+             {
+                return property_Data;
+             }
+
+            /**
+             * setter for data
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setData(
+                    AviaryCommon::JobData*  arg_Data)
+             {
+                
+
+                if(isValidData &&
+                        arg_Data == property_Data)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Data)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"data is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetData();
+
+                
+                    if(NULL == arg_Data)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Data = arg_Data;
+                        isValidData = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for data
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetData()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Data != NULL)
+                {
+                   
+                   
+                         delete  property_Data;
+                     
+
+                   }
+
+                
+                
+                
+               isValidData = false; 
+               return true;
+           }
+
+           /**
+            * Check whether data is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isDataNil()
+           {
+               return !isValidData;
+           }
+
+           /**
+            * Set data to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setDataNil()
+           {
+               return resetData();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryQuery::GetJobDataResponse::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for file_name by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty3()
+            {
+                return getFile_name();
+            }
+
+            /**
+             * getter for file_name.
+             */
+            std::string WSF_CALL
+            AviaryQuery::GetJobDataResponse::getFile_name()
+             {
+                return property_File_name;
+             }
+
+            /**
+             * setter for file_name
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setFile_name(
+                    const std::string  arg_File_name)
+             {
+                
+
+                if(isValidFile_name &&
+                        arg_File_name == property_File_name)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetFile_name();
+
+                
+                        property_File_name = std::string(arg_File_name.c_str());
+                        isValidFile_name = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for file_name
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetFile_name()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidFile_name = false; 
+               return true;
+           }
+
+           /**
+            * Check whether file_name is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isFile_nameNil()
+           {
+               return !isValidFile_name;
+           }
+
+           /**
+            * Set file_name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setFile_nameNil()
+           {
+               return resetFile_name();
+           }
+
+           
+
+            /**
+             * Getter for file_size by  Property Number 4
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty4()
+            {
+                return getFile_size();
+            }
+
+            /**
+             * getter for file_size.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobDataResponse::getFile_size()
+             {
+                return property_File_size;
+             }
+
+            /**
+             * setter for file_size
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setFile_size(
+                    const int  arg_File_size)
+             {
+                
+
+                if(isValidFile_size &&
+                        arg_File_size == property_File_size)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetFile_size();
+
+                
+                        property_File_size = arg_File_size;
+                        isValidFile_size = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for file_size
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetFile_size()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidFile_size = false; 
+               return true;
+           }
+
+           /**
+            * Check whether file_size is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isFile_sizeNil()
+           {
+               return !isValidFile_size;
+           }
+
+           /**
+            * Set file_size to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setFile_sizeNil()
+           {
+               return resetFile_size();
+           }
+
+           
+
+            /**
+             * Getter for content by  Property Number 5
+             */
+            std::string WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty5()
+            {
+                return getContent();
+            }
+
+            /**
+             * getter for content.
+             */
+            std::string WSF_CALL
+            AviaryQuery::GetJobDataResponse::getContent()
+             {
+                return property_Content;
+             }
+
+            /**
+             * setter for content
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setContent(
+                    const std::string  arg_Content)
+             {
+                
+
+                if(isValidContent &&
+                        arg_Content == property_Content)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetContent();
+
+                
+                        property_Content = std::string(arg_Content.c_str());
+                        isValidContent = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for content
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetContent()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidContent = false; 
+               return true;
+           }
+
+           /**
+            * Check whether content is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isContentNil()
+           {
+               return !isValidContent;
+           }
+
+           /**
+            * Set content to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setContentNil()
+           {
+               return resetContent();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetails.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetails.cpp
new file mode 100644
index 0000000..e09bf50
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetails.cpp
@@ -0,0 +1,980 @@
+
+
+        /**
+         * GetJobDetails.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobDetails.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobDetails|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobDetails::GetJobDetails()
+        {
+
+        
+            qname = NULL;
+        
+                property_Ids  = NULL;
+              
+            isValidIds  = false;
+        
+            isValidPartialMatches  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobDetails",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobDetails::GetJobDetails(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches)
+        {
+             
+                   qname = NULL;
+             
+               property_Ids  = NULL;
+             
+            isValidIds  = true;
+            
+            isValidPartialMatches  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobDetails",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Ids = arg_Ids;
+            
+                    property_PartialMatches = arg_PartialMatches;
+            
+        }
+        AviaryQuery::GetJobDetails::~GetJobDetails()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobDetails::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobDetails : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                       { 
+                    /*
+                     * building Ids array
+                     */
+                       std::vector<AviaryCommon::JobID*>* arr_list =new std::vector<AviaryCommon::JobID*>();
+                   
+
+                     
+                     /*
+                      * building ids element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "ids", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("ids", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobID* element = new AviaryCommon::JobID();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element ids ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for ids ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setIds(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "partialMatches"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "partialMatches", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "partialMatches");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setPartialMatches(true);
+                           }
+                           else
+                           {
+                               setPartialMatches(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobDetails::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobDetails::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobDetails::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobDetails", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidPartialMatches)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_PartialMatches)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("partialMatches")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "partialMatches",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIds)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ids"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ids")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Ids array
+                      */
+                     if (property_Ids != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sids",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sids>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Ids->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobID* element = (*property_Ids)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing ids element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidPartialMatches)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_PartialMatches)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "partialMatches", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ids by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobDetails::getProperty1()
+            {
+                return getIds();
+            }
+
+            /**
+             * getter for ids.
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobDetails::getIds()
+             {
+                return property_Ids;
+             }
+
+            /**
+             * setter for ids
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::setIds(
+                    std::vector<AviaryCommon::JobID*>*  arg_Ids)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidIds &&
+                        arg_Ids == property_Ids)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Ids->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Ids)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetIds();
+
+                
+                    if(NULL == arg_Ids)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Ids = arg_Ids;
+                        if(non_nil_exists)
+                        {
+                            isValidIds = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of ids.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryQuery::GetJobDetails::getIdsAt(int i)
+            {
+                AviaryCommon::JobID* ret_val;
+                if(property_Ids == NULL)
+                {
+                    return (AviaryCommon::JobID*)0;
+                }
+                ret_val =   (*property_Ids)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of ids.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobDetails::setIdsAt(int i,
+                    AviaryCommon::JobID* arg_Ids)
+            {
+                 AviaryCommon::JobID* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidIds &&
+                    property_Ids &&
+                  
+                    arg_Ids == (*property_Ids)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Ids)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = true;
+                        (*property_Ids)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Ids)[i] = arg_Ids;
+                  
+
+               isValidIds = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to ids.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::addIds(
+                    AviaryCommon::JobID* arg_Ids)
+             {
+
+                
+                    if( NULL == arg_Ids
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+              
+               property_Ids->push_back(arg_Ids);
+              
+                isValidIds = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the ids array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobDetails::sizeofIds()
+            {
+
+                if(property_Ids == NULL)
+                {
+                    return 0;
+                }
+                return property_Ids->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::removeIdsAt(int i)
+            {
+                return setIdsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for ids
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::resetIds()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Ids != NULL)
+                {
+                  std::vector<AviaryCommon::JobID*>::iterator it =  property_Ids->begin();
+                  for( ; it <  property_Ids->end() ; ++it)
+                  {
+                     AviaryCommon::JobID* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Ids)
+                 delete property_Ids;
+                
+               isValidIds = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ids is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::isIdsNil()
+           {
+               return !isValidIds;
+           }
+
+           /**
+            * Set ids to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::setIdsNil()
+           {
+               return resetIds();
+           }
+
+           
+           /**
+            * Check whether ids is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::isIdsNilAt(int i)
+           {
+               return (isValidIds == false ||
+                       NULL == property_Ids ||
+                     NULL == (*property_Ids)[i]);
+            }
+
+           /**
+            * Set ids to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::setIdsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Ids == NULL ||
+                            isValidIds == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Ids->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Ids)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of ids is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Ids == NULL)
+                {
+                    isValidIds = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobID* element = (*property_Ids)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = false;
+                        (*property_Ids)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Ids)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for partialMatches by  Property Number 2
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::getProperty2()
+            {
+                return getPartialMatches();
+            }
+
+            /**
+             * getter for partialMatches.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::getPartialMatches()
+             {
+                return property_PartialMatches;
+             }
+
+            /**
+             * setter for partialMatches
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::setPartialMatches(
+                    bool  arg_PartialMatches)
+             {
+                
+
+                if(isValidPartialMatches &&
+                        arg_PartialMatches == property_PartialMatches)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPartialMatches();
+
+                
+                        property_PartialMatches = arg_PartialMatches;
+                        isValidPartialMatches = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for partialMatches
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::resetPartialMatches()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPartialMatches = false; 
+               return true;
+           }
+
+           /**
+            * Check whether partialMatches is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::isPartialMatchesNil()
+           {
+               return !isValidPartialMatches;
+           }
+
+           /**
+            * Set partialMatches to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::setPartialMatchesNil()
+           {
+               return resetPartialMatches();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetailsResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetailsResponse.cpp
new file mode 100644
index 0000000..05025b8
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetailsResponse.cpp
@@ -0,0 +1,776 @@
+
+
+        /**
+         * GetJobDetailsResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobDetailsResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobDetailsResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobDetailsResponse::GetJobDetailsResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Jobs  = NULL;
+              
+            isValidJobs  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobDetailsResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobDetailsResponse::GetJobDetailsResponse(std::vector<AviaryCommon::JobDetails*>* arg_Jobs)
+        {
+             
+                   qname = NULL;
+             
+               property_Jobs  = NULL;
+             
+            isValidJobs  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobDetailsResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Jobs = arg_Jobs;
+            
+        }
+        AviaryQuery::GetJobDetailsResponse::~GetJobDetailsResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobDetailsResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobDetailsResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                       { 
+                    /*
+                     * building Jobs array
+                     */
+                       std::vector<AviaryCommon::JobDetails*>* arr_list =new std::vector<AviaryCommon::JobDetails*>();
+                   
+
+                     
+                     /*
+                      * building jobs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "jobs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("jobs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobDetails* element = new AviaryCommon::JobDetails();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element jobs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for jobs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setJobs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobDetailsResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobDetailsResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobDetailsResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobDetailsResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJobs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("jobs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("jobs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Jobs array
+                      */
+                     if (property_Jobs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sjobs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sjobs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Jobs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobDetails* element = (*property_Jobs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing jobs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for jobs by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobDetails*>* WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::getProperty1()
+            {
+                return getJobs();
+            }
+
+            /**
+             * getter for jobs.
+             */
+            std::vector<AviaryCommon::JobDetails*>* WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::getJobs()
+             {
+                return property_Jobs;
+             }
+
+            /**
+             * setter for jobs
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::setJobs(
+                    std::vector<AviaryCommon::JobDetails*>*  arg_Jobs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidJobs &&
+                        arg_Jobs == property_Jobs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Jobs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Jobs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetJobs();
+
+                
+                    if(NULL == arg_Jobs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Jobs = arg_Jobs;
+                        if(non_nil_exists)
+                        {
+                            isValidJobs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of jobs.
+             */
+            AviaryCommon::JobDetails* WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::getJobsAt(int i)
+            {
+                AviaryCommon::JobDetails* ret_val;
+                if(property_Jobs == NULL)
+                {
+                    return (AviaryCommon::JobDetails*)0;
+                }
+                ret_val =   (*property_Jobs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of jobs.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::setJobsAt(int i,
+                    AviaryCommon::JobDetails* arg_Jobs)
+            {
+                 AviaryCommon::JobDetails* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidJobs &&
+                    property_Jobs &&
+                  
+                    arg_Jobs == (*property_Jobs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobDetails*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Jobs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = true;
+                        (*property_Jobs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Jobs)[i] = arg_Jobs;
+                  
+
+               isValidJobs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to jobs.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::addJobs(
+                    AviaryCommon::JobDetails* arg_Jobs)
+             {
+
+                
+                    if( NULL == arg_Jobs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobDetails*>();
+                }
+              
+               property_Jobs->push_back(arg_Jobs);
+              
+                isValidJobs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the jobs array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::sizeofJobs()
+            {
+
+                if(property_Jobs == NULL)
+                {
+                    return 0;
+                }
+                return property_Jobs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::removeJobsAt(int i)
+            {
+                return setJobsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for jobs
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::resetJobs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Jobs != NULL)
+                {
+                  std::vector<AviaryCommon::JobDetails*>::iterator it =  property_Jobs->begin();
+                  for( ; it <  property_Jobs->end() ; ++it)
+                  {
+                     AviaryCommon::JobDetails* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Jobs)
+                 delete property_Jobs;
+                
+               isValidJobs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether jobs is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::isJobsNil()
+           {
+               return !isValidJobs;
+           }
+
+           /**
+            * Set jobs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::setJobsNil()
+           {
+               return resetJobs();
+           }
+
+           
+           /**
+            * Check whether jobs is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::isJobsNilAt(int i)
+           {
+               return (isValidJobs == false ||
+                       NULL == property_Jobs ||
+                     NULL == (*property_Jobs)[i]);
+            }
+
+           /**
+            * Set jobs to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::setJobsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Jobs == NULL ||
+                            isValidJobs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Jobs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Jobs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of jobs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Jobs == NULL)
+                {
+                    isValidJobs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobDetails* element = (*property_Jobs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = false;
+                        (*property_Jobs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Jobs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatus.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatus.cpp
new file mode 100644
index 0000000..215973c
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatus.cpp
@@ -0,0 +1,980 @@
+
+
+        /**
+         * GetJobStatus.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobStatus.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobStatus|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobStatus::GetJobStatus()
+        {
+
+        
+            qname = NULL;
+        
+                property_Ids  = NULL;
+              
+            isValidIds  = false;
+        
+            isValidPartialMatches  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobStatus",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobStatus::GetJobStatus(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches)
+        {
+             
+                   qname = NULL;
+             
+               property_Ids  = NULL;
+             
+            isValidIds  = true;
+            
+            isValidPartialMatches  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobStatus",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Ids = arg_Ids;
+            
+                    property_PartialMatches = arg_PartialMatches;
+            
+        }
+        AviaryQuery::GetJobStatus::~GetJobStatus()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobStatus::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobStatus : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                       { 
+                    /*
+                     * building Ids array
+                     */
+                       std::vector<AviaryCommon::JobID*>* arr_list =new std::vector<AviaryCommon::JobID*>();
+                   
+
+                     
+                     /*
+                      * building ids element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "ids", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("ids", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobID* element = new AviaryCommon::JobID();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element ids ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for ids ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setIds(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "partialMatches"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "partialMatches", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "partialMatches");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setPartialMatches(true);
+                           }
+                           else
+                           {
+                               setPartialMatches(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobStatus::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobStatus::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobStatus::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobStatus", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidPartialMatches)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_PartialMatches)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("partialMatches")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "partialMatches",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIds)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ids"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ids")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Ids array
+                      */
+                     if (property_Ids != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sids",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sids>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Ids->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobID* element = (*property_Ids)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing ids element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidPartialMatches)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_PartialMatches)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "partialMatches", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ids by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobStatus::getProperty1()
+            {
+                return getIds();
+            }
+
+            /**
+             * getter for ids.
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobStatus::getIds()
+             {
+                return property_Ids;
+             }
+
+            /**
+             * setter for ids
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::setIds(
+                    std::vector<AviaryCommon::JobID*>*  arg_Ids)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidIds &&
+                        arg_Ids == property_Ids)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Ids->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Ids)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetIds();
+
+                
+                    if(NULL == arg_Ids)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Ids = arg_Ids;
+                        if(non_nil_exists)
+                        {
+                            isValidIds = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of ids.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryQuery::GetJobStatus::getIdsAt(int i)
+            {
+                AviaryCommon::JobID* ret_val;
+                if(property_Ids == NULL)
+                {
+                    return (AviaryCommon::JobID*)0;
+                }
+                ret_val =   (*property_Ids)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of ids.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobStatus::setIdsAt(int i,
+                    AviaryCommon::JobID* arg_Ids)
+            {
+                 AviaryCommon::JobID* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidIds &&
+                    property_Ids &&
+                  
+                    arg_Ids == (*property_Ids)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Ids)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = true;
+                        (*property_Ids)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Ids)[i] = arg_Ids;
+                  
+
+               isValidIds = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to ids.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::addIds(
+                    AviaryCommon::JobID* arg_Ids)
+             {
+
+                
+                    if( NULL == arg_Ids
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+              
+               property_Ids->push_back(arg_Ids);
+              
+                isValidIds = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the ids array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobStatus::sizeofIds()
+            {
+
+                if(property_Ids == NULL)
+                {
+                    return 0;
+                }
+                return property_Ids->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::removeIdsAt(int i)
+            {
+                return setIdsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for ids
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::resetIds()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Ids != NULL)
+                {
+                  std::vector<AviaryCommon::JobID*>::iterator it =  property_Ids->begin();
+                  for( ; it <  property_Ids->end() ; ++it)
+                  {
+                     AviaryCommon::JobID* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Ids)
+                 delete property_Ids;
+                
+               isValidIds = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ids is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::isIdsNil()
+           {
+               return !isValidIds;
+           }
+
+           /**
+            * Set ids to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::setIdsNil()
+           {
+               return resetIds();
+           }
+
+           
+           /**
+            * Check whether ids is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::isIdsNilAt(int i)
+           {
+               return (isValidIds == false ||
+                       NULL == property_Ids ||
+                     NULL == (*property_Ids)[i]);
+            }
+
+           /**
+            * Set ids to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::setIdsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Ids == NULL ||
+                            isValidIds == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Ids->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Ids)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of ids is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Ids == NULL)
+                {
+                    isValidIds = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobID* element = (*property_Ids)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = false;
+                        (*property_Ids)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Ids)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for partialMatches by  Property Number 2
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::getProperty2()
+            {
+                return getPartialMatches();
+            }
+
+            /**
+             * getter for partialMatches.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::getPartialMatches()
+             {
+                return property_PartialMatches;
+             }
+
+            /**
+             * setter for partialMatches
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::setPartialMatches(
+                    bool  arg_PartialMatches)
+             {
+                
+
+                if(isValidPartialMatches &&
+                        arg_PartialMatches == property_PartialMatches)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPartialMatches();
+
+                
+                        property_PartialMatches = arg_PartialMatches;
+                        isValidPartialMatches = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for partialMatches
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::resetPartialMatches()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPartialMatches = false; 
+               return true;
+           }
+
+           /**
+            * Check whether partialMatches is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::isPartialMatchesNil()
+           {
+               return !isValidPartialMatches;
+           }
+
+           /**
+            * Set partialMatches to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::setPartialMatchesNil()
+           {
+               return resetPartialMatches();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatusResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatusResponse.cpp
new file mode 100644
index 0000000..656f042
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatusResponse.cpp
@@ -0,0 +1,776 @@
+
+
+        /**
+         * GetJobStatusResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobStatusResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobStatusResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobStatusResponse::GetJobStatusResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Jobs  = NULL;
+              
+            isValidJobs  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobStatusResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobStatusResponse::GetJobStatusResponse(std::vector<AviaryCommon::JobStatus*>* arg_Jobs)
+        {
+             
+                   qname = NULL;
+             
+               property_Jobs  = NULL;
+             
+            isValidJobs  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobStatusResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Jobs = arg_Jobs;
+            
+        }
+        AviaryQuery::GetJobStatusResponse::~GetJobStatusResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobStatusResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobStatusResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                       { 
+                    /*
+                     * building Jobs array
+                     */
+                       std::vector<AviaryCommon::JobStatus*>* arr_list =new std::vector<AviaryCommon::JobStatus*>();
+                   
+
+                     
+                     /*
+                      * building jobs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "jobs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("jobs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobStatus* element = new AviaryCommon::JobStatus();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element jobs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for jobs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setJobs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobStatusResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobStatusResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobStatusResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobStatusResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJobs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("jobs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("jobs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Jobs array
+                      */
+                     if (property_Jobs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sjobs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sjobs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Jobs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobStatus* element = (*property_Jobs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing jobs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for jobs by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobStatus*>* WSF_CALL
+            AviaryQuery::GetJobStatusResponse::getProperty1()
+            {
+                return getJobs();
+            }
+
+            /**
+             * getter for jobs.
+             */
+            std::vector<AviaryCommon::JobStatus*>* WSF_CALL
+            AviaryQuery::GetJobStatusResponse::getJobs()
+             {
+                return property_Jobs;
+             }
+
+            /**
+             * setter for jobs
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatusResponse::setJobs(
+                    std::vector<AviaryCommon::JobStatus*>*  arg_Jobs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidJobs &&
+                        arg_Jobs == property_Jobs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Jobs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Jobs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetJobs();
+
+                
+                    if(NULL == arg_Jobs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Jobs = arg_Jobs;
+                        if(non_nil_exists)
+                        {
+                            isValidJobs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of jobs.
+             */
+            AviaryCommon::JobStatus* WSF_CALL
+            AviaryQuery::GetJobStatusResponse::getJobsAt(int i)
+            {
+                AviaryCommon::JobStatus* ret_val;
+                if(property_Jobs == NULL)
+                {
+                    return (AviaryCommon::JobStatus*)0;
+                }
+                ret_val =   (*property_Jobs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of jobs.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobStatusResponse::setJobsAt(int i,
+                    AviaryCommon::JobStatus* arg_Jobs)
+            {
+                 AviaryCommon::JobStatus* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidJobs &&
+                    property_Jobs &&
+                  
+                    arg_Jobs == (*property_Jobs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobStatus*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Jobs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = true;
+                        (*property_Jobs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Jobs)[i] = arg_Jobs;
+                  
+
+               isValidJobs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to jobs.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatusResponse::addJobs(
+                    AviaryCommon::JobStatus* arg_Jobs)
+             {
+
+                
+                    if( NULL == arg_Jobs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobStatus*>();
+                }
+              
+               property_Jobs->push_back(arg_Jobs);
+              
+                isValidJobs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the jobs array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobStatusResponse::sizeofJobs()
+            {
+
+                if(property_Jobs == NULL)
+                {
+                    return 0;
+                }
+                return property_Jobs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatusResponse::removeJobsAt(int i)
+            {
+                return setJobsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for jobs
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::resetJobs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Jobs != NULL)
+                {
+                  std::vector<AviaryCommon::JobStatus*>::iterator it =  property_Jobs->begin();
+                  for( ; it <  property_Jobs->end() ; ++it)
+                  {
+                     AviaryCommon::JobStatus* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Jobs)
+                 delete property_Jobs;
+                
+               isValidJobs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether jobs is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::isJobsNil()
+           {
+               return !isValidJobs;
+           }
+
+           /**
+            * Set jobs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::setJobsNil()
+           {
+               return resetJobs();
+           }
+
+           
+           /**
+            * Check whether jobs is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::isJobsNilAt(int i)
+           {
+               return (isValidJobs == false ||
+                       NULL == property_Jobs ||
+                     NULL == (*property_Jobs)[i]);
+            }
+
+           /**
+            * Set jobs to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::setJobsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Jobs == NULL ||
+                            isValidJobs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Jobs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Jobs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of jobs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Jobs == NULL)
+                {
+                    isValidJobs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobStatus* element = (*property_Jobs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = false;
+                        (*property_Jobs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Jobs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummary.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummary.cpp
new file mode 100644
index 0000000..bfbaa18
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummary.cpp
@@ -0,0 +1,980 @@
+
+
+        /**
+         * GetJobSummary.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobSummary.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobSummary|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobSummary::GetJobSummary()
+        {
+
+        
+            qname = NULL;
+        
+                property_Ids  = NULL;
+              
+            isValidIds  = false;
+        
+            isValidPartialMatches  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobSummary",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobSummary::GetJobSummary(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches)
+        {
+             
+                   qname = NULL;
+             
+               property_Ids  = NULL;
+             
+            isValidIds  = true;
+            
+            isValidPartialMatches  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobSummary",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Ids = arg_Ids;
+            
+                    property_PartialMatches = arg_PartialMatches;
+            
+        }
+        AviaryQuery::GetJobSummary::~GetJobSummary()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobSummary::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobSummary : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                       { 
+                    /*
+                     * building Ids array
+                     */
+                       std::vector<AviaryCommon::JobID*>* arr_list =new std::vector<AviaryCommon::JobID*>();
+                   
+
+                     
+                     /*
+                      * building ids element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "ids", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("ids", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobID* element = new AviaryCommon::JobID();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element ids ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for ids ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setIds(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "partialMatches"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "partialMatches", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "partialMatches");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setPartialMatches(true);
+                           }
+                           else
+                           {
+                               setPartialMatches(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobSummary::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobSummary::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobSummary::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobSummary", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidPartialMatches)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_PartialMatches)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("partialMatches")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "partialMatches",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIds)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ids"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ids")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Ids array
+                      */
+                     if (property_Ids != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sids",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sids>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Ids->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobID* element = (*property_Ids)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing ids element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidPartialMatches)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_PartialMatches)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "partialMatches", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ids by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobSummary::getProperty1()
+            {
+                return getIds();
+            }
+
+            /**
+             * getter for ids.
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobSummary::getIds()
+             {
+                return property_Ids;
+             }
+
+            /**
+             * setter for ids
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::setIds(
+                    std::vector<AviaryCommon::JobID*>*  arg_Ids)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidIds &&
+                        arg_Ids == property_Ids)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Ids->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Ids)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetIds();
+
+                
+                    if(NULL == arg_Ids)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Ids = arg_Ids;
+                        if(non_nil_exists)
+                        {
+                            isValidIds = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of ids.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryQuery::GetJobSummary::getIdsAt(int i)
+            {
+                AviaryCommon::JobID* ret_val;
+                if(property_Ids == NULL)
+                {
+                    return (AviaryCommon::JobID*)0;
+                }
+                ret_val =   (*property_Ids)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of ids.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobSummary::setIdsAt(int i,
+                    AviaryCommon::JobID* arg_Ids)
+            {
+                 AviaryCommon::JobID* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidIds &&
+                    property_Ids &&
+                  
+                    arg_Ids == (*property_Ids)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Ids)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = true;
+                        (*property_Ids)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Ids)[i] = arg_Ids;
+                  
+
+               isValidIds = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to ids.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::addIds(
+                    AviaryCommon::JobID* arg_Ids)
+             {
+
+                
+                    if( NULL == arg_Ids
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+              
+               property_Ids->push_back(arg_Ids);
+              
+                isValidIds = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the ids array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobSummary::sizeofIds()
+            {
+
+                if(property_Ids == NULL)
+                {
+                    return 0;
+                }
+                return property_Ids->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::removeIdsAt(int i)
+            {
+                return setIdsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for ids
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::resetIds()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Ids != NULL)
+                {
+                  std::vector<AviaryCommon::JobID*>::iterator it =  property_Ids->begin();
+                  for( ; it <  property_Ids->end() ; ++it)
+                  {
+                     AviaryCommon::JobID* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Ids)
+                 delete property_Ids;
+                
+               isValidIds = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ids is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::isIdsNil()
+           {
+               return !isValidIds;
+           }
+
+           /**
+            * Set ids to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::setIdsNil()
+           {
+               return resetIds();
+           }
+
+           
+           /**
+            * Check whether ids is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::isIdsNilAt(int i)
+           {
+               return (isValidIds == false ||
+                       NULL == property_Ids ||
+                     NULL == (*property_Ids)[i]);
+            }
+
+           /**
+            * Set ids to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::setIdsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Ids == NULL ||
+                            isValidIds == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Ids->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Ids)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of ids is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Ids == NULL)
+                {
+                    isValidIds = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobID* element = (*property_Ids)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = false;
+                        (*property_Ids)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Ids)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for partialMatches by  Property Number 2
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::getProperty2()
+            {
+                return getPartialMatches();
+            }
+
+            /**
+             * getter for partialMatches.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::getPartialMatches()
+             {
+                return property_PartialMatches;
+             }
+
+            /**
+             * setter for partialMatches
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::setPartialMatches(
+                    bool  arg_PartialMatches)
+             {
+                
+
+                if(isValidPartialMatches &&
+                        arg_PartialMatches == property_PartialMatches)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPartialMatches();
+
+                
+                        property_PartialMatches = arg_PartialMatches;
+                        isValidPartialMatches = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for partialMatches
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::resetPartialMatches()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPartialMatches = false; 
+               return true;
+           }
+
+           /**
+            * Check whether partialMatches is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::isPartialMatchesNil()
+           {
+               return !isValidPartialMatches;
+           }
+
+           /**
+            * Set partialMatches to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::setPartialMatchesNil()
+           {
+               return resetPartialMatches();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummaryResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummaryResponse.cpp
new file mode 100644
index 0000000..a3bdc0c
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummaryResponse.cpp
@@ -0,0 +1,776 @@
+
+
+        /**
+         * GetJobSummaryResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobSummaryResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobSummaryResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobSummaryResponse::GetJobSummaryResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Jobs  = NULL;
+              
+            isValidJobs  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobSummaryResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobSummaryResponse::GetJobSummaryResponse(std::vector<AviaryCommon::JobSummary*>* arg_Jobs)
+        {
+             
+                   qname = NULL;
+             
+               property_Jobs  = NULL;
+             
+            isValidJobs  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobSummaryResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Jobs = arg_Jobs;
+            
+        }
+        AviaryQuery::GetJobSummaryResponse::~GetJobSummaryResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobSummaryResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobSummaryResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                       { 
+                    /*
+                     * building Jobs array
+                     */
+                       std::vector<AviaryCommon::JobSummary*>* arr_list =new std::vector<AviaryCommon::JobSummary*>();
+                   
+
+                     
+                     /*
+                      * building jobs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "jobs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("jobs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobSummary* element = new AviaryCommon::JobSummary();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element jobs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for jobs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setJobs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobSummaryResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobSummaryResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobSummaryResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobSummaryResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJobs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("jobs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("jobs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Jobs array
+                      */
+                     if (property_Jobs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sjobs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sjobs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Jobs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobSummary* element = (*property_Jobs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing jobs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for jobs by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::getProperty1()
+            {
+                return getJobs();
+            }
+
+            /**
+             * getter for jobs.
+             */
+            std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::getJobs()
+             {
+                return property_Jobs;
+             }
+
+            /**
+             * setter for jobs
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::setJobs(
+                    std::vector<AviaryCommon::JobSummary*>*  arg_Jobs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidJobs &&
+                        arg_Jobs == property_Jobs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Jobs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Jobs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetJobs();
+
+                
+                    if(NULL == arg_Jobs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Jobs = arg_Jobs;
+                        if(non_nil_exists)
+                        {
+                            isValidJobs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of jobs.
+             */
+            AviaryCommon::JobSummary* WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::getJobsAt(int i)
+            {
+                AviaryCommon::JobSummary* ret_val;
+                if(property_Jobs == NULL)
+                {
+                    return (AviaryCommon::JobSummary*)0;
+                }
+                ret_val =   (*property_Jobs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of jobs.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::setJobsAt(int i,
+                    AviaryCommon::JobSummary* arg_Jobs)
+            {
+                 AviaryCommon::JobSummary* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidJobs &&
+                    property_Jobs &&
+                  
+                    arg_Jobs == (*property_Jobs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobSummary*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Jobs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = true;
+                        (*property_Jobs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Jobs)[i] = arg_Jobs;
+                  
+
+               isValidJobs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to jobs.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::addJobs(
+                    AviaryCommon::JobSummary* arg_Jobs)
+             {
+
+                
+                    if( NULL == arg_Jobs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobSummary*>();
+                }
+              
+               property_Jobs->push_back(arg_Jobs);
+              
+                isValidJobs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the jobs array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::sizeofJobs()
+            {
+
+                if(property_Jobs == NULL)
+                {
+                    return 0;
+                }
+                return property_Jobs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::removeJobsAt(int i)
+            {
+                return setJobsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for jobs
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::resetJobs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Jobs != NULL)
+                {
+                  std::vector<AviaryCommon::JobSummary*>::iterator it =  property_Jobs->begin();
+                  for( ; it <  property_Jobs->end() ; ++it)
+                  {
+                     AviaryCommon::JobSummary* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Jobs)
+                 delete property_Jobs;
+                
+               isValidJobs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether jobs is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::isJobsNil()
+           {
+               return !isValidJobs;
+           }
+
+           /**
+            * Set jobs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::setJobsNil()
+           {
+               return resetJobs();
+           }
+
+           
+           /**
+            * Check whether jobs is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::isJobsNilAt(int i)
+           {
+               return (isValidJobs == false ||
+                       NULL == property_Jobs ||
+                     NULL == (*property_Jobs)[i]);
+            }
+
+           /**
+            * Set jobs to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::setJobsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Jobs == NULL ||
+                            isValidJobs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Jobs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Jobs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of jobs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Jobs == NULL)
+                {
+                    isValidJobs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobSummary* element = (*property_Jobs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = false;
+                        (*property_Jobs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Jobs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummary.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummary.cpp
new file mode 100644
index 0000000..1f56355
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummary.cpp
@@ -0,0 +1,1163 @@
+
+
+        /**
+         * GetSubmissionSummary.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetSubmissionSummary.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetSubmissionSummary|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetSubmissionSummary::GetSubmissionSummary()
+        {
+
+        
+            qname = NULL;
+        
+                property_Ids  = NULL;
+              
+            isValidIds  = false;
+        
+            isValidPartialMatches  = false;
+        
+            isValidIncludeJobSummaries  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetSubmissionSummary",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetSubmissionSummary::GetSubmissionSummary(std::vector<AviaryCommon::SubmissionID*>* arg_Ids,bool arg_PartialMatches,bool arg_IncludeJobSummaries)
+        {
+             
+                   qname = NULL;
+             
+               property_Ids  = NULL;
+             
+            isValidIds  = true;
+            
+            isValidPartialMatches  = true;
+            
+            isValidIncludeJobSummaries  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetSubmissionSummary",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Ids = arg_Ids;
+            
+                    property_PartialMatches = arg_PartialMatches;
+            
+                    property_IncludeJobSummaries = arg_IncludeJobSummaries;
+            
+        }
+        AviaryQuery::GetSubmissionSummary::~GetSubmissionSummary()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetSubmissionSummary::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetSubmissionSummary : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                       { 
+                    /*
+                     * building Ids array
+                     */
+                       std::vector<AviaryCommon::SubmissionID*>* arr_list =new std::vector<AviaryCommon::SubmissionID*>();
+                   
+
+                     
+                     /*
+                      * building ids element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "ids", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("ids", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::SubmissionID* element = new AviaryCommon::SubmissionID();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element ids ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for ids ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setIds(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "partialMatches"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "partialMatches", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "partialMatches");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setPartialMatches(true);
+                           }
+                           else
+                           {
+                               setPartialMatches(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "includeJobSummaries"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "includeJobSummaries", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "includeJobSummaries");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setIncludeJobSummaries(true);
+                           }
+                           else
+                           {
+                               setIncludeJobSummaries(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetSubmissionSummary::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetSubmissionSummary::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetSubmissionSummary::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetSubmissionSummary", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidPartialMatches)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_PartialMatches)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("partialMatches")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "partialMatches",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+                if(isValidIncludeJobSummaries)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_IncludeJobSummaries)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("includeJobSummaries")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "includeJobSummaries",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIds)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ids"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ids")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Ids array
+                      */
+                     if (property_Ids != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sids",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sids>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Ids->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::SubmissionID* element = (*property_Ids)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing ids element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidPartialMatches)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_PartialMatches)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "partialMatches", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidIncludeJobSummaries)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_IncludeJobSummaries)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "includeJobSummaries", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ids by  Property Number 1
+             */
+            std::vector<AviaryCommon::SubmissionID*>* WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getProperty1()
+            {
+                return getIds();
+            }
+
+            /**
+             * getter for ids.
+             */
+            std::vector<AviaryCommon::SubmissionID*>* WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getIds()
+             {
+                return property_Ids;
+             }
+
+            /**
+             * setter for ids
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::setIds(
+                    std::vector<AviaryCommon::SubmissionID*>*  arg_Ids)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidIds &&
+                        arg_Ids == property_Ids)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Ids->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Ids)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetIds();
+
+                
+                    if(NULL == arg_Ids)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Ids = arg_Ids;
+                        if(non_nil_exists)
+                        {
+                            isValidIds = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of ids.
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getIdsAt(int i)
+            {
+                AviaryCommon::SubmissionID* ret_val;
+                if(property_Ids == NULL)
+                {
+                    return (AviaryCommon::SubmissionID*)0;
+                }
+                ret_val =   (*property_Ids)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of ids.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::setIdsAt(int i,
+                    AviaryCommon::SubmissionID* arg_Ids)
+            {
+                 AviaryCommon::SubmissionID* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidIds &&
+                    property_Ids &&
+                  
+                    arg_Ids == (*property_Ids)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::SubmissionID*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Ids)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = true;
+                        (*property_Ids)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Ids)[i] = arg_Ids;
+                  
+
+               isValidIds = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to ids.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::addIds(
+                    AviaryCommon::SubmissionID* arg_Ids)
+             {
+
+                
+                    if( NULL == arg_Ids
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::SubmissionID*>();
+                }
+              
+               property_Ids->push_back(arg_Ids);
+              
+                isValidIds = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the ids array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetSubmissionSummary::sizeofIds()
+            {
+
+                if(property_Ids == NULL)
+                {
+                    return 0;
+                }
+                return property_Ids->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::removeIdsAt(int i)
+            {
+                return setIdsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for ids
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::resetIds()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Ids != NULL)
+                {
+                  std::vector<AviaryCommon::SubmissionID*>::iterator it =  property_Ids->begin();
+                  for( ; it <  property_Ids->end() ; ++it)
+                  {
+                     AviaryCommon::SubmissionID* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Ids)
+                 delete property_Ids;
+                
+               isValidIds = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ids is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::isIdsNil()
+           {
+               return !isValidIds;
+           }
+
+           /**
+            * Set ids to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::setIdsNil()
+           {
+               return resetIds();
+           }
+
+           
+           /**
+            * Check whether ids is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::isIdsNilAt(int i)
+           {
+               return (isValidIds == false ||
+                       NULL == property_Ids ||
+                     NULL == (*property_Ids)[i]);
+            }
+
+           /**
+            * Set ids to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::setIdsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Ids == NULL ||
+                            isValidIds == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Ids->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Ids)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of ids is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Ids == NULL)
+                {
+                    isValidIds = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::SubmissionID* element = (*property_Ids)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = false;
+                        (*property_Ids)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Ids)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for partialMatches by  Property Number 2
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getProperty2()
+            {
+                return getPartialMatches();
+            }
+
+            /**
+             * getter for partialMatches.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getPartialMatches()
+             {
+                return property_PartialMatches;
+             }
+
+            /**
+             * setter for partialMatches
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::setPartialMatches(
+                    bool  arg_PartialMatches)
+             {
+                
+
+                if(isValidPartialMatches &&
+                        arg_PartialMatches == property_PartialMatches)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPartialMatches();
+
+                
+                        property_PartialMatches = arg_PartialMatches;
+                        isValidPartialMatches = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for partialMatches
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::resetPartialMatches()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPartialMatches = false; 
+               return true;
+           }
+
+           /**
+            * Check whether partialMatches is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::isPartialMatchesNil()
+           {
+               return !isValidPartialMatches;
+           }
+
+           /**
+            * Set partialMatches to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::setPartialMatchesNil()
+           {
+               return resetPartialMatches();
+           }
+
+           
+
+            /**
+             * Getter for includeJobSummaries by  Property Number 3
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getProperty3()
+            {
+                return getIncludeJobSummaries();
+            }
+
+            /**
+             * getter for includeJobSummaries.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getIncludeJobSummaries()
+             {
+                return property_IncludeJobSummaries;
+             }
+
+            /**
+             * setter for includeJobSummaries
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::setIncludeJobSummaries(
+                    bool  arg_IncludeJobSummaries)
+             {
+                
+
+                if(isValidIncludeJobSummaries &&
+                        arg_IncludeJobSummaries == property_IncludeJobSummaries)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetIncludeJobSummaries();
+
+                
+                        property_IncludeJobSummaries = arg_IncludeJobSummaries;
+                        isValidIncludeJobSummaries = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for includeJobSummaries
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::resetIncludeJobSummaries()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidIncludeJobSummaries = false; 
+               return true;
+           }
+
+           /**
+            * Check whether includeJobSummaries is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::isIncludeJobSummariesNil()
+           {
+               return !isValidIncludeJobSummaries;
+           }
+
+           /**
+            * Set includeJobSummaries to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::setIncludeJobSummariesNil()
+           {
+               return resetIncludeJobSummaries();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummaryResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummaryResponse.cpp
new file mode 100644
index 0000000..b780821
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummaryResponse.cpp
@@ -0,0 +1,776 @@
+
+
+        /**
+         * GetSubmissionSummaryResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetSubmissionSummaryResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetSubmissionSummaryResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetSubmissionSummaryResponse::GetSubmissionSummaryResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Submissions  = NULL;
+              
+            isValidSubmissions  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetSubmissionSummaryResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetSubmissionSummaryResponse::GetSubmissionSummaryResponse(std::vector<AviaryCommon::SubmissionSummary*>* arg_Submissions)
+        {
+             
+                   qname = NULL;
+             
+               property_Submissions  = NULL;
+             
+            isValidSubmissions  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetSubmissionSummaryResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Submissions = arg_Submissions;
+            
+        }
+        AviaryQuery::GetSubmissionSummaryResponse::~GetSubmissionSummaryResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetSubmissionSummaryResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetSubmissionSummaryResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                       { 
+                    /*
+                     * building Submissions array
+                     */
+                       std::vector<AviaryCommon::SubmissionSummary*>* arr_list =new std::vector<AviaryCommon::SubmissionSummary*>();
+                   
+
+                     
+                     /*
+                      * building submissions element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "submissions", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submissions", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::SubmissionSummary* element = new AviaryCommon::SubmissionSummary();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element submissions ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for submissions ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"submissions (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setSubmissions(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetSubmissionSummaryResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetSubmissionSummaryResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetSubmissionSummaryResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetSubmissionSummaryResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidSubmissions)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("submissions"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("submissions")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Submissions array
+                      */
+                     if (property_Submissions != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%ssubmissions",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%ssubmissions>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Submissions->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::SubmissionSummary* element = (*property_Submissions)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing submissions element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for submissions by  Property Number 1
+             */
+            std::vector<AviaryCommon::SubmissionSummary*>* WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::getProperty1()
+            {
+                return getSubmissions();
+            }
+
+            /**
+             * getter for submissions.
+             */
+            std::vector<AviaryCommon::SubmissionSummary*>* WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::getSubmissions()
+             {
+                return property_Submissions;
+             }
+
+            /**
+             * setter for submissions
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::setSubmissions(
+                    std::vector<AviaryCommon::SubmissionSummary*>*  arg_Submissions)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidSubmissions &&
+                        arg_Submissions == property_Submissions)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Submissions->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"submissions has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Submissions)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetSubmissions();
+
+                
+                    if(NULL == arg_Submissions)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Submissions = arg_Submissions;
+                        if(non_nil_exists)
+                        {
+                            isValidSubmissions = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of submissions.
+             */
+            AviaryCommon::SubmissionSummary* WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::getSubmissionsAt(int i)
+            {
+                AviaryCommon::SubmissionSummary* ret_val;
+                if(property_Submissions == NULL)
+                {
+                    return (AviaryCommon::SubmissionSummary*)0;
+                }
+                ret_val =   (*property_Submissions)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of submissions.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::setSubmissionsAt(int i,
+                    AviaryCommon::SubmissionSummary* arg_Submissions)
+            {
+                 AviaryCommon::SubmissionSummary* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidSubmissions &&
+                    property_Submissions &&
+                  
+                    arg_Submissions == (*property_Submissions)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Submissions == NULL)
+                {
+                    property_Submissions = new std::vector<AviaryCommon::SubmissionSummary*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Submissions)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidSubmissions = true;
+                        (*property_Submissions)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Submissions)[i] = arg_Submissions;
+                  
+
+               isValidSubmissions = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to submissions.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::addSubmissions(
+                    AviaryCommon::SubmissionSummary* arg_Submissions)
+             {
+
+                
+                    if( NULL == arg_Submissions
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Submissions == NULL)
+                {
+                    property_Submissions = new std::vector<AviaryCommon::SubmissionSummary*>();
+                }
+              
+               property_Submissions->push_back(arg_Submissions);
+              
+                isValidSubmissions = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the submissions array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::sizeofSubmissions()
+            {
+
+                if(property_Submissions == NULL)
+                {
+                    return 0;
+                }
+                return property_Submissions->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::removeSubmissionsAt(int i)
+            {
+                return setSubmissionsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for submissions
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::resetSubmissions()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Submissions != NULL)
+                {
+                  std::vector<AviaryCommon::SubmissionSummary*>::iterator it =  property_Submissions->begin();
+                  for( ; it <  property_Submissions->end() ; ++it)
+                  {
+                     AviaryCommon::SubmissionSummary* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Submissions)
+                 delete property_Submissions;
+                
+               isValidSubmissions = false; 
+               return true;
+           }
+
+           /**
+            * Check whether submissions is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::isSubmissionsNil()
+           {
+               return !isValidSubmissions;
+           }
+
+           /**
+            * Set submissions to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::setSubmissionsNil()
+           {
+               return resetSubmissions();
+           }
+
+           
+           /**
+            * Check whether submissions is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::isSubmissionsNilAt(int i)
+           {
+               return (isValidSubmissions == false ||
+                       NULL == property_Submissions ||
+                     NULL == (*property_Submissions)[i]);
+            }
+
+           /**
+            * Set submissions to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::setSubmissionsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Submissions == NULL ||
+                            isValidSubmissions == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Submissions->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Submissions)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of submissions is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Submissions == NULL)
+                {
+                    isValidSubmissions = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::SubmissionSummary* element = (*property_Submissions)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidSubmissions = false;
+                        (*property_Submissions)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Submissions)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_QueryRequestType.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_QueryRequestType.cpp
new file mode 100644
index 0000000..f59b227
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_QueryRequestType.cpp
@@ -0,0 +1,346 @@
+
+
+        /**
+         * QueryRequestType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_QueryRequestType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = QueryRequestType
+                 * Namespace URI = http://query.aviary.grid.redhat.com
+                 * Namespace Prefix = ns2
+                 */
+           AviaryQuery::QueryRequestType::QueryRequestType()
+        {
+
+        
+            isValidAllowPartialMatching  = false;
+        
+        }
+
+       AviaryQuery::QueryRequestType::QueryRequestType(bool arg_AllowPartialMatching)
+        {
+             
+            isValidAllowPartialMatching  = true;
+            
+                    property_AllowPartialMatching = arg_AllowPartialMatching;
+            
+        }
+        AviaryQuery::QueryRequestType::~QueryRequestType()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::QueryRequestType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "allowPartialMatching"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "allowPartialMatching", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "allowPartialMatching");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setAllowPartialMatching(true);
+                           }
+                           else
+                           {
+                               setAllowPartialMatching(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::QueryRequestType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::QueryRequestType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::QueryRequestType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidAllowPartialMatching)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_AllowPartialMatching)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("allowPartialMatching")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "allowPartialMatching",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidAllowPartialMatching)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_AllowPartialMatching)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "allowPartialMatching", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for allowPartialMatching by  Property Number 1
+             */
+            bool WSF_CALL
+            AviaryQuery::QueryRequestType::getProperty1()
+            {
+                return getAllowPartialMatching();
+            }
+
+            /**
+             * getter for allowPartialMatching.
+             */
+            bool WSF_CALL
+            AviaryQuery::QueryRequestType::getAllowPartialMatching()
+             {
+                return property_AllowPartialMatching;
+             }
+
+            /**
+             * setter for allowPartialMatching
+             */
+            bool WSF_CALL
+            AviaryQuery::QueryRequestType::setAllowPartialMatching(
+                    bool  arg_AllowPartialMatching)
+             {
+                
+
+                if(isValidAllowPartialMatching &&
+                        arg_AllowPartialMatching == property_AllowPartialMatching)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetAllowPartialMatching();
+
+                
+                        property_AllowPartialMatching = arg_AllowPartialMatching;
+                        isValidAllowPartialMatching = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for allowPartialMatching
+            */
+           bool WSF_CALL
+           AviaryQuery::QueryRequestType::resetAllowPartialMatching()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidAllowPartialMatching = false; 
+               return true;
+           }
+
+           /**
+            * Check whether allowPartialMatching is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::QueryRequestType::isAllowPartialMatchingNil()
+           {
+               return !isValidAllowPartialMatching;
+           }
+
+           /**
+            * Set allowPartialMatching to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::QueryRequestType::setAllowPartialMatchingNil()
+           {
+               return resetAllowPartialMatching();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/etc/61aviary.config b/src/condor_contrib/aviary/etc/61aviary.config
new file mode 100644
index 0000000..5fdc884
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/61aviary.config
@@ -0,0 +1,34 @@
+# Base configuration for Aviary
+#
+# Included is the Schedd plugin, AviaryScheddPlugin-plugin.so, and the aviary_query_server
+
+# The general Aviary config file for Axis2
+# axis2.xml has parameters that point to lib and services dir
+WSFCPP_HOME=/var/lib/condor/aviary/axis2.xml
+
+# Aviary Schedd plugin, provides submission and job control endpoint
+SCHEDD.PLUGINS = $(SCHEDD.PLUGINS) $(LIB)/plugins/AviaryScheddPlugin-plugin.so
+
+# Port the Aviary Schedd plugin listens on, default 9090
+#SCHEDD.HTTP_PORT = 9090
+
+# Aviary query server, provides endpoint for job and submission queries
+QUERY_SERVER = $(SBIN)/aviary_query_server
+QUERY_SERVER_ARGS = -f
+QUERY_SERVER.QUERY_SERVER_LOG = $(LOG)/QueryServerLog
+QUERY_SERVER.QUERY_SERVER_DEBUG = D_ALWAYS
+DAEMON_LIST = $(DAEMON_LIST), QUERY_SERVER
+
+# Port the QueryServer listens on, default 9091
+#QUERY_SERVER.HTTP_PORT = 9091
+
+# HISTORY_INTERVAL specifies the number of seconds between polls of the HISTORY file, default 120
+#QUERY_SERVER.HISTORY_INTERVAL = 120
+
+# If there is more than one Schedd on the system or if the Schedd and
+# QueryServer reside on different systems, it is necessary to tell the
+# QueryServer the name of the Schedd it is working with via
+# QUERY_SERVER.SCHEDD_NAME. This allows the QueryServer to provide
+# fully-qualified job ids, i.e. cluster.proc:pool:scheduler. Default
+# is constructed in the same way the Schedd constructs its name.
+#QUERY_SERVER.SCHEDD_NAME =
diff --git a/src/condor_contrib/aviary/etc/aviary-common.xsd b/src/condor_contrib/aviary/etc/aviary-common.xsd
new file mode 100644
index 0000000..30f20be
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-common.xsd
@@ -0,0 +1,203 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://common.aviary.grid.redhat.com" targetNamespace="http://common.aviary.grid.redhat.com">
+	<!-- common types should make use of simple and complex types for reuse -->
+	<xs:simpleType name="StatusCodeType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="OK"/>
+			<xs:enumeration value="FAIL"/>
+			<xs:enumeration value="NO_MATCH"/>
+			<xs:enumeration value="INVALID_OFFSET"/>
+			<xs:enumeration value="UNIMPLEMENTED"/>
+			<xs:enumeration value="UNAVAILABLE"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="Status">
+		<xs:sequence>
+			<xs:element name="code" type="tns:StatusCodeType"/>
+			<xs:element name="text" type="xs:string" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="AttributeType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="INTEGER"/>
+			<xs:enumeration value="FLOAT"/>
+			<xs:enumeration value="STRING"/>
+			<xs:enumeration value="EXPRESSION"/>
+			<xs:enumeration value="BOOLEAN"/>
+			<xs:enumeration value="UNDEFINED"/>
+			<xs:enumeration value="ERROR"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="Attribute">
+		<xs:sequence>
+			<xs:element name="name" type="xs:string"/>
+			<xs:element name="type" type="tns:AttributeType"/>
+			<xs:element name="value" type="xs:string"/>
+		</xs:sequence>
+	</xs:complexType>
+	<!-- might just want to use the following just for returning data like in getJobDetails -->
+	<xs:complexType name="Attributes">
+		<xs:sequence>
+			<xs:element name="attrs" type="tns:Attribute" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="OSType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="LINUX"/>
+			<xs:enumeration value="WINDOWS"/>
+			<!-- can expand later -->
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="ArchType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="INTEL"/>
+			<xs:enumeration value="X86_64"/>
+			<!-- can expand later -->
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="ResourceConstraintType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="OS"/>
+			<xs:enumeration value="ARCH"/>
+			<xs:enumeration value="MEMORY"/>
+			<xs:enumeration value="DISK"/>
+			<xs:enumeration value="FILESYSTEM"/>
+			<!-- when we say MEMORY or DISK we always mean at least the amount provided -->
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="ResourceConstraint">
+		<xs:sequence>
+			<xs:element name="type" type="tns:ResourceConstraintType"/>
+			<xs:element name="value" type="xs:string"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="JobConstraintType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="CMD"/>
+			<xs:enumeration value="ARGS"/>
+			<xs:enumeration value="OWNER"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="JobConstraint">
+		<xs:sequence>
+			<xs:element name="type" type="tns:JobConstraintType"/>
+			<xs:element name="value" type="xs:string"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="SubmissionID">
+		<xs:sequence>
+			<xs:element name="name" type="xs:string" minOccurs="0"/>
+			<xs:element name="owner" type="xs:string" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="JobID">
+		<xs:sequence>
+			<xs:element name="job" type="xs:string"/>
+			<xs:element name="pool" type="xs:string" minOccurs="0"/>
+			<xs:element name="scheduler" type="xs:string" minOccurs="0"/>
+			<xs:element name="submission" type="tns:SubmissionID" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="JobStatusType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="IDLE"/>
+			<xs:enumeration value="RUNNING"/>
+			<xs:enumeration value="REMOVED"/>
+			<xs:enumeration value="COMPLETED"/>
+			<xs:enumeration value="HELD"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<!-- reuse through extension not available for the following related types -->
+	<xs:complexType name="JobStatus">
+		<xs:sequence>
+			<xs:element name="id" type="tns:JobID"/>
+			<xs:element name="status" type="tns:Status"/>
+			<xs:element name="job_status" type="tns:JobStatusType" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="JobSummary">
+		<xs:sequence>
+			<xs:element name="id" type="tns:JobID"/>
+			<xs:element name="status" type="tns:Status"/>
+			<xs:element name="queued" type="xs:dateTime"/>
+			<xs:element name="last_update" type="xs:dateTime"/>
+			<xs:element name="job_status" type="tns:JobStatusType"/>
+			<xs:element name="cmd" type="xs:string"/>
+			<xs:element name="args1" type="xs:string" minOccurs="0"/>
+			<xs:element name="args2" type="xs:string" minOccurs="0"/>
+			<xs:element name="held" type="xs:string" minOccurs="0"/>
+			<xs:element name="released" type="xs:string" minOccurs="0"/>
+			<xs:element name="removed" type="xs:string" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+		<xs:complexType name="SubmissionSummary">
+		<xs:sequence>
+			<xs:element name="id" type="tns:SubmissionID"/>
+			<xs:element name="status" type="tns:Status"/>
+			<xs:element name="completed" type="xs:int"/>
+			<xs:element name="held" type="xs:int"/>
+			<xs:element name="idle" type="xs:int"/>
+			<xs:element name="removed" type="xs:int"/>
+			<xs:element name="running" type="xs:int"/>
+			<xs:element name="jobs" type="tns:JobSummary" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="JobDetails">
+		<xs:sequence>
+			<xs:element name="id" type="tns:JobID"/>
+			<xs:element name="status" type="tns:Status"/>
+			<xs:element name="details" type="tns:Attributes" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="JobDataType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="ERR"/>
+			<xs:enumeration value="LOG"/>
+			<xs:enumeration value="OUT"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="JobData">
+		<xs:sequence>
+			<xs:element name="id" type="tns:JobID"/>
+			<xs:element name="type" type="tns:JobDataType"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="ResourceType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="COLLECTOR"/>
+			<xs:enumeration value="EXECUTOR"/>
+			<xs:enumeration value="EVENT_SERVER"/>
+			<xs:enumeration value="JOB_SERVER"/>
+			<xs:enumeration value="LOW_LATENCY"/>
+			<xs:enumeration value="MASTER"/>
+			<xs:enumeration value="NEGOTIATOR"/>
+			<xs:enumeration value="SCHEDULER"/>
+			<xs:enumeration value="CUSTOM"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="ResourceID">
+		<xs:sequence>
+			<xs:element name="subsystem_type" type="tns:ResourceType"/>
+			<xs:element name="pool" type="xs:string"/>
+			<xs:element name="name" type="xs:string"/>
+			<xs:element name="custom_name" type="xs:string" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+</xs:schema>
diff --git a/src/condor_contrib/aviary/etc/aviary-job.wsdl b/src/condor_contrib/aviary/etc/aviary-job.wsdl
new file mode 100644
index 0000000..c401778
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-job.wsdl
@@ -0,0 +1,130 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://grid.redhat.com/aviary-job/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:job="http://job.aviary.grid.redhat.com" xmlns:ns="http://common.aviary.grid.redhat.com" targetNamespace="http://grid.redhat.com/aviary-job/" name="aviary-job">
+	<wsdl:types>
+		<xsd:schema targetNamespace="http://grid.redhat.com/aviary-job/">
+			<xsd:import schemaLocation="aviary-job.xsd" namespace="http://job.aviary.grid.redhat.com"/>
+		</xsd:schema>
+	</wsdl:types>
+	<wsdl:message name="SubmitJobRequest">
+		<wsdl:part name="parameters" element="job:SubmitJob"/>
+	</wsdl:message>
+	<wsdl:message name="SubmitJobResponse">
+		<wsdl:part name="parameters" element="job:SubmitJobResponse"/>
+	</wsdl:message>
+	<wsdl:message name="HoldJobRequest">
+		<wsdl:part name="parameters" element="job:HoldJob"/>
+	</wsdl:message>
+	<wsdl:message name="HoldJobResponse">
+		<wsdl:part name="parameters" element="job:HoldJobResponse"/>
+	</wsdl:message>
+	<wsdl:message name="ReleaseJobRequest">
+		<wsdl:part name="parameters" element="job:ReleaseJob"/>
+	</wsdl:message>
+	<wsdl:message name="ReleaseJobResponse">
+		<wsdl:part name="parameters" element="job:ReleaseJobResponse"/>
+	</wsdl:message>
+	<wsdl:message name="RemoveJobRequest">
+		<wsdl:part name="parameters" element="job:RemoveJob"/>
+	</wsdl:message>
+	<wsdl:message name="RemoveJobResponse">
+		<wsdl:part name="parameters" element="job:RemoveJobResponse"/>
+	</wsdl:message>
+	<wsdl:message name="SetJobAttributeRequest">
+		<wsdl:part name="parameters" element="job:SetJobAttribute"/>
+	</wsdl:message>
+	<wsdl:message name="SetJobAttributeResponse">
+		<wsdl:part name="parameters" element="job:SetJobAttributeResponse"/>
+	</wsdl:message>
+	<wsdl:portType name="AviaryJob">
+		<wsdl:operation name="submitJob">
+			<wsdl:input message="tns:SubmitJobRequest"/>
+			<wsdl:output message="tns:SubmitJobResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="holdJob">
+			<wsdl:input message="tns:HoldJobRequest"/>
+			<wsdl:output message="tns:HoldJobResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="releaseJob">
+			<wsdl:input message="tns:ReleaseJobRequest"/>
+			<wsdl:output message="tns:ReleaseJobResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="removeJob">
+			<wsdl:input message="tns:RemoveJobRequest"/>
+			<wsdl:output message="tns:RemoveJobResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="setJobAttribute">
+			<wsdl:input message="tns:SetJobAttributeRequest"/>
+			<wsdl:output message="tns:SetJobAttributeResponse"/>
+		</wsdl:operation>
+	</wsdl:portType>
+	<wsdl:binding name="AviaryJobSOAPBinding" type="tns:AviaryJob">
+		<soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
+		<wsdl:operation name="submitJob">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/submit"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="holdJob">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/hold"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="releaseJob">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/release"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="removeJob">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/remove"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="setJobAttribute">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/set-attr"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+	</wsdl:binding>
+	<wsdl:service name="AviaryJobService">
+		<wsdl:port name="AviaryJobSOAPPort" binding="tns:AviaryJobSOAPBinding">
+			<soap:address location="http://localhost"/>
+		</wsdl:port>
+	</wsdl:service>
+</wsdl:definitions>
diff --git a/src/condor_contrib/aviary/etc/aviary-job.xsd b/src/condor_contrib/aviary/etc/aviary-job.xsd
new file mode 100644
index 0000000..d00b63b
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-job.xsd
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:job="http://job.aviary.grid.redhat.com" xmlns:mrg="http://common.aviary.grid.redhat.com" targetNamespace="http://job.aviary.grid.redhat.com">
+	<xs:import namespace="http://common.aviary.grid.redhat.com" schemaLocation="aviary-common.xsd"/>
+	<!-- declare message-level elements using anonymous complex types for simpler generated types -->
+	<xs:element name="SubmitJob">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="cmd" type="xs:string"/>
+				<xs:element name="args" type="xs:string" minOccurs="0"/>
+				<xs:element name="owner" type="xs:string"/>
+				<xs:element name="iwd" type="xs:string"/>
+				<xs:element name="submission_name" type="xs:string" minOccurs="0"/>
+				<xs:element name="requirements" type="mrg:ResourceConstraint"  minOccurs="0" maxOccurs="unbounded"/>
+				<xs:element name="extra" type="mrg:Attribute" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="allowOverrides" type="xs:boolean" default="false"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="SubmitJobResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="id" type="mrg:JobID" minOccurs="0"/>
+				<xs:element name="status" type="mrg:Status"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:complexType name="ControlJob">
+		<xs:sequence>
+			<xs:element name="id" type="mrg:JobID"/>
+			<xs:element name="reason" type="xs:string"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="ControlJobResponse">
+		<xs:sequence>
+			<xs:element name="status" type="mrg:Status"/>
+		</xs:sequence>
+	</xs:complexType>
+	<!-- these all follow the same type pattern so reuse -->
+	<xs:element name="HoldJob" type="job:ControlJob"/>
+	<xs:element name="HoldJobResponse" type="job:ControlJobResponse"/>
+	<xs:element name="ReleaseJob" type="job:ControlJob"/>
+	<xs:element name="ReleaseJobResponse" type="job:ControlJobResponse"/>
+	<xs:element name="RemoveJob" type="job:ControlJob"/>
+	<xs:element name="RemoveJobResponse" type="job:ControlJobResponse"/>
+	<xs:element name="SetJobAttribute">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="id" type="mrg:JobID"/>
+				<xs:element name="attribute" type="mrg:Attribute"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="SetJobAttributeResponse" type="job:ControlJobResponse"/>
+</xs:schema>
diff --git a/src/condor_contrib/aviary/etc/aviary-query.wsdl b/src/condor_contrib/aviary/etc/aviary-query.wsdl
new file mode 100644
index 0000000..3769e05
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-query.wsdl
@@ -0,0 +1,130 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://grid.redhat.com/aviary-query/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:qry="http://query.aviary.grid.redhat.com" xmlns:ns="http://common.aviary.grid.redhat.com" targetNamespace="http://grid.redhat.com/aviary-query/" name="aviary-query">
+	<wsdl:types>
+		<xsd:schema targetNamespace="http://grid.redhat.com/aviary-query/">
+			<xsd:import schemaLocation="aviary-query.xsd" namespace="http://query.aviary.grid.redhat.com"/>
+		</xsd:schema>
+	</wsdl:types>
+	<wsdl:message name="GetJobSummaryRequest">
+		<wsdl:part name="parameters" element="qry:GetJobSummary"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobSummaryResponse">
+		<wsdl:part name="parameters" element="qry:GetJobSummaryResponse"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobStatusRequest">
+		<wsdl:part name="parameters" element="qry:GetJobStatus"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobStatusResponse">
+		<wsdl:part name="parameters" element="qry:GetJobStatusResponse"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobDetailsRequest">
+		<wsdl:part name="parameters" element="qry:GetJobDetails"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobDetailsResponse">
+		<wsdl:part name="parameters" element="qry:GetJobDetailsResponse"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobDataRequest">
+		<wsdl:part name="parameters" element="qry:GetJobData"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobDataResponse">
+		<wsdl:part name="parameters" element="qry:GetJobDataResponse"/>
+	</wsdl:message>
+	<wsdl:message name="GetSubmissionSummaryRequest">
+		<wsdl:part name="parameters" element="qry:GetSubmissionSummary"/>
+	</wsdl:message>
+	<wsdl:message name="GetSubmissionSummaryResponse">
+		<wsdl:part name="parameters" element="qry:GetSubmissionSummaryResponse"/>
+	</wsdl:message>
+	<wsdl:portType name="AviaryQuery">
+		<wsdl:operation name="getJobSummary">
+			<wsdl:input message="tns:GetJobSummaryRequest"/>
+			<wsdl:output message="tns:GetJobSummaryResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="getJobStatus">
+			<wsdl:input message="tns:GetJobStatusRequest"/>
+			<wsdl:output message="tns:GetJobStatusResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="getJobDetails">
+			<wsdl:input message="tns:GetJobDetailsRequest"/>
+			<wsdl:output message="tns:GetJobDetailsResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="getJobData">
+			<wsdl:input message="tns:GetJobDataRequest"/>
+			<wsdl:output message="tns:GetJobDataResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="getSubmissionSummary">
+			<wsdl:input message="tns:GetSubmissionSummaryRequest"/>
+			<wsdl:output message="tns:GetSubmissionSummaryResponse"/>
+		</wsdl:operation>
+	</wsdl:portType>
+	<wsdl:binding name="AviaryQuerySOAPBinding" type="tns:AviaryQuery">
+		<soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
+		<wsdl:operation name="getJobSummary">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/summary"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="getJobStatus">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/status"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="getJobDetails">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/details"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="getJobData">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/data"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="getSubmissionSummary">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/submission"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+	</wsdl:binding>
+	<wsdl:service name="AviaryQueryService">
+		<wsdl:port name="AviaryQuerySOAPPort" binding="tns:AviaryQuerySOAPBinding">
+			<soap:address location="http://localhost"/>
+		</wsdl:port>
+	</wsdl:service>
+</wsdl:definitions>
diff --git a/src/condor_contrib/aviary/etc/aviary-query.xsd b/src/condor_contrib/aviary/etc/aviary-query.xsd
new file mode 100644
index 0000000..a46ceb8
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-query.xsd
@@ -0,0 +1,106 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:qry="http://query.aviary.grid.redhat.com" xmlns:mrg="http://common.aviary.grid.redhat.com" targetNamespace="http://query.aviary.grid.redhat.com">
+	<xs:import namespace="http://common.aviary.grid.redhat.com" schemaLocation="aviary-common.xsd"/>
+
+	<!-- declare  message-level elements using anonymous complex types for simpler generated types -->
+	<!-- use of refs, inheritance into anonymous types, etc. eschewed for simplicity and interop -->
+	<xs:element name="GetJobSummary">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="ids" type="mrg:JobID" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="partialMatches" type="xs:boolean" default="true"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobSummaryResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="jobs" type="mrg:JobSummary" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobStatus">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="ids" type="mrg:JobID" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="partialMatches" type="xs:boolean" default="true"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobStatusResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="jobs" type="mrg:JobStatus" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobDetails">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="ids" type="mrg:JobID" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="partialMatches" type="xs:boolean" default="true"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobDetailsResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="jobs" type="mrg:JobDetails" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobData">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="data" type="mrg:JobData"/>
+				<xs:element name="max_bytes" type="xs:integer" default="1024"/>
+				<xs:element name="from_end" type="xs:boolean" minOccurs="0" default="false"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobDataResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="data" type="mrg:JobData"/>
+				<xs:element name="status" type="mrg:Status"/>
+				<xs:element name="file_name" type="xs:string" minOccurs="0"/>
+				<xs:element name="file_size" type="xs:integer" minOccurs="0"/>
+				<!-- string for file content...we probably want to keep line feeds, etc. TODO: need to revisit this-->
+				<xs:element name="content" type="xs:string" minOccurs="0"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetSubmissionSummary">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="ids" type="mrg:SubmissionID" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="partialMatches" type="xs:boolean" default="true"/>
+			<xs:attribute name="includeJobSummaries" type="xs:boolean" default="false"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetSubmissionSummaryResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="submissions" type="mrg:SubmissionSummary" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+</xs:schema>
diff --git a/src/condor_contrib/aviary/etc/axis2.xml.in b/src/condor_contrib/aviary/etc/axis2.xml.in
new file mode 100644
index 0000000..4e06bbd
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/axis2.xml.in
@@ -0,0 +1,102 @@
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+
+<!-- Aviary-specific axis2.xml -->
+<axisconfig name="Axis2/C">
+	<!-- ================================================= -->
+	<!-- Parameters -->
+	<!-- ================================================= -->
+	<parameter name="libDir">@WS02_LIB_ROOT@</parameter>
+	<parameter name="servicesDir">/var/lib/condor/aviary/services</parameter>
+	<parameter name="enableREST" locked="false">true</parameter>
+	<parameter name="persistOperationContext" locked="false">true</parameter>
+
+	<!-- ================================================= -->
+	<!-- Transport Ins -->
+	<!-- ================================================= -->
+	<transportReceiver name="http" class="libaxis2_http_receiver.so.0">
+		<parameter name="port" locked="false">6060</parameter>
+	</transportReceiver>
+
+    <!-- applies to Axis2/C clients only -->
+	<transportReceiver name="https" class="libaxis2_http_receiver.so.0">
+		<parameter name="port" locked="false">6060</parameter>
+	</transportReceiver>
+	<!--transportReceiver name="tcp" class="axis2_tcp_receiver"-->
+	<!--parameter name="port" locked="false">6060</parameter-->
+	<!--/transportReceiver-->
+
+	<!-- ================================================= -->
+	<!-- Transport Outs -->
+	<!-- ================================================= -->
+
+	<transportSender name="http" class="libaxis2_http_sender.so.0">
+		<parameter name="PROTOCOL" locked="false">HTTP/1.1</parameter>
+		<parameter name="xml-declaration" insert="false"/>
+		<!--parameter name="Transfer-Encoding">chunked</parameter-->
+		<!--parameter name="PROXY" proxy_host="127.0.0.1" proxy_port="8080" locked="true"/-->
+	</transportSender>
+
+    <!-- applies to Axis2/C clients only -->
+	<transportSender name="https" class="libaxis2_http_sender.so.0">
+		<parameter name="PROTOCOL" locked="false">HTTP/1.1</parameter>
+		<parameter name="xml-declaration" insert="false"/>
+	</transportSender>
+
+	<!-- ================================================= -->
+	<!-- SSL  -->
+	<!-- ================================================= -->
+	<!-- NOTE: server-side SSL support currently unavailable for aviary components -->
+	<!-- alternatives include the use of a SSL-enabled proxy server such as squid; -->
+	<!-- the following settings would apply to Axis2/C clients only if enabled -->
+	<!-- set the server's SSL certificate here -->
+	<!--parameter name="SERVER_CERT">/path/to/ca/certificate</parameter-->
+	<!-- set the client's SSL key file and passphrase here for client auth -->
+	<!--parameter name="KEY_FILE">/path/to/client/certificate/chain/file</parameter-->
+	<!--parameter name="SSL_PASSPHRASE">passphrase</parameter-->
+
+	<!-- ================================================= -->
+	<!-- Phases  -->
+	<!-- ================================================= -->
+	<phaseOrder type="inflow">
+		<!-- System pre defined phases -->
+		<phase name="Transport"/>
+		<phase name="PreDispatch"/>
+		<phase name="Dispatch"/>
+		<phase name="PostDispatch"/>
+		<!-- End system pre defined phases -->
+		<!-- After PostDispatch phase, module or service author can add any phase as required  -->
+		<!-- User defined phases could be added here -->
+		<phase name="Security"/>
+		<phase name="Rahas"/>
+	</phaseOrder>
+	<phaseOrder type="outflow">
+		<!-- User defined phases could be added here -->
+		<phase name="MessageOut"/>
+		<phase name="Security"/>
+	</phaseOrder>
+	<phaseOrder type="INfaultflow">
+		<!-- User defined phases could be added here -->
+		<!--phase name="userphase1"/-->
+	</phaseOrder>
+	<phaseOrder type="Outfaultflow">
+		<!-- User defined phases could be added here -->
+		<!--phase name="userphase1"/-->
+		<phase name="MessageOut"/>
+	</phaseOrder>
+</axisconfig>
diff --git a/src/condor_contrib/aviary/gen-xsd-cpp.sh b/src/condor_contrib/aviary/gen-xsd-cpp.sh
new file mode 100755
index 0000000..2740157
--- /dev/null
+++ b/src/condor_contrib/aviary/gen-xsd-cpp.sh
@@ -0,0 +1,51 @@
+#!/bin/sh
+
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# codegen to provide WSDL/XSD CPP headers and source
+
+WSFCPP_HOME=/usr
+if [ -z "$1" ]; then
+    echo No arg - using default
+else
+    WSFCPP_HOME=$1
+fi
+echo WSFCPP_HOME=$WSFCPP_HOME
+
+# generate our cpp types from WSDL
+WSDL2CPP.sh -uri etc/aviary-job.wsdl -or -d adb -ss -g -ns2p http://common.aviary.grid.redhat.com=AviaryCommon,http://job.aviary.grid.redhat.com=AviaryJob -o codegen/job
+WSDL2CPP.sh -uri etc/aviary-query.wsdl -or -d adb -ss -g -ns2p http://common.aviary.grid.redhat.com=AviaryCommon,http://query.aviary.grid.redhat.com=AviaryQuery -o codegen/query
+
+# get rid of the extraneous stuff that WSDL2CPP won't let us turn off
+rm -f codegen/job/*AviaryJob*Service*.{h,cpp,vcproj}
+rm -f codegen/query/*AviaryQuery*Service*.{h,cpp,vcproj}
+
+# setup our include dir
+if ! test -d include; then
+    mkdir include;
+fi
+
+# stow the headers for others steps in the build 
+mv codegen/job/src/*.h include;
+mv codegen/query/src/*.h include;
+
+# WSDLCPP should do this for us but break out common
+if ! test -d codegen/common/src; then
+    mkdir -p codegen/common/src;
+fi
+mv codegen/query/src/AviaryCommon*.cpp codegen/common/src
+rm -f codegen/job/src/AviaryCommon*.cpp
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ArchType.h b/src/condor_contrib/aviary/include/AviaryCommon_ArchType.h
new file mode 100644
index 0000000..89aa5c2
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ArchType.h
@@ -0,0 +1,245 @@
+
+
+        #ifndef AviaryCommon_ARCHTYPE_H
+        #define AviaryCommon_ARCHTYPE_H
+
+       /**
+        * ArchType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ArchType class
+        */
+
+        namespace AviaryCommon{
+            class ArchType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            ArchType_INTEL,
+            ArchType_X86_64
+        } ADBArchTypeEnum;
+        
+        
+
+        class ArchType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_ArchType;
+
+                
+                bool isValidArchType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setArchTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ArchType
+         */
+
+        ArchType();
+
+        /**
+         * Destructor ArchType
+         */
+        ~ArchType();
+
+
+       
+
+        /**
+         * Constructor for creating ArchType
+         * @param 
+         * @param ArchType std::string
+         * @return newly created ArchType object
+         */
+        ArchType(std::string arg_ArchType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ArchType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getArchType();
+
+        /**
+         * Setter for ArchType.
+         * @param arg_ArchType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setArchType(const std::string  arg_ArchType);
+
+        /**
+         * Re setter for ArchType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetArchType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for ArchType.
+            * @return ADBArchTypeEnum; -1 on failure
+            */
+            ADBArchTypeEnum WSF_CALL
+            getArchTypeEnum();
+            
+            /**
+            * Enum setter for ArchType.
+            * @param arg_ArchType ADBArchTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setArchTypeEnum(
+            const ADBArchTypeEnum arg_ArchType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ArchType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isArchTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ArchType_om_node node to serialize from
+         * @param ArchType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ArchType_om_node, axiom_element_t *ArchType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ArchType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ArchType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* ARCHTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_Attribute.h b/src/condor_contrib/aviary/include/AviaryCommon_Attribute.h
new file mode 100644
index 0000000..1f47890
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_Attribute.h
@@ -0,0 +1,307 @@
+
+
+        #ifndef AviaryCommon_ATTRIBUTE_H
+        #define AviaryCommon_ATTRIBUTE_H
+
+       /**
+        * Attribute.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  Attribute class
+        */
+
+        namespace AviaryCommon{
+            class Attribute;
+        }
+        
+
+        
+       #include "AviaryCommon_AttributeType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class Attribute {
+
+        private:
+             std::string property_Name;
+
+                
+                bool isValidName;
+            AviaryCommon::AttributeType* property_Type;
+
+                
+                bool isValidType;
+            std::string property_Value;
+
+                
+                bool isValidValue;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setNameNil();
+            
+
+        bool WSF_CALL
+        setTypeNil();
+            
+
+        bool WSF_CALL
+        setValueNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class Attribute
+         */
+
+        Attribute();
+
+        /**
+         * Destructor Attribute
+         */
+        ~Attribute();
+
+
+       
+
+        /**
+         * Constructor for creating Attribute
+         * @param 
+         * @param Name std::string
+         * @param Type AviaryCommon::AttributeType*
+         * @param Value std::string
+         * @return newly created Attribute object
+         */
+        Attribute(std::string arg_Name,AviaryCommon::AttributeType* arg_Type,std::string arg_Value);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getName();
+
+        /**
+         * Setter for name.
+         * @param arg_Name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setName(const std::string  arg_Name);
+
+        /**
+         * Re setter for name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetName();
+        
+        
+
+        /**
+         * Getter for type. 
+         * @return AviaryCommon::AttributeType*
+         */
+        WSF_EXTERN AviaryCommon::AttributeType* WSF_CALL
+        getType();
+
+        /**
+         * Setter for type.
+         * @param arg_Type AviaryCommon::AttributeType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setType(AviaryCommon::AttributeType*  arg_Type);
+
+        /**
+         * Re setter for type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetType();
+        
+        
+
+        /**
+         * Getter for value. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getValue();
+
+        /**
+         * Setter for value.
+         * @param arg_Value std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setValue(const std::string  arg_Value);
+
+        /**
+         * Re setter for value
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetValue();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isNameNil();
+
+
+        
+
+        /**
+         * Check whether type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTypeNil();
+
+
+        
+
+        /**
+         * Check whether value is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isValueNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param Attribute_om_node node to serialize from
+         * @param Attribute_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* Attribute_om_node, axiom_element_t *Attribute_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the Attribute is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for name by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for type by property number (2)
+         * @return AviaryCommon::AttributeType
+         */
+
+        AviaryCommon::AttributeType* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for value by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* ATTRIBUTE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_AttributeType.h b/src/condor_contrib/aviary/include/AviaryCommon_AttributeType.h
new file mode 100644
index 0000000..34d7c36
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_AttributeType.h
@@ -0,0 +1,250 @@
+
+
+        #ifndef AviaryCommon_ATTRIBUTETYPE_H
+        #define AviaryCommon_ATTRIBUTETYPE_H
+
+       /**
+        * AttributeType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  AttributeType class
+        */
+
+        namespace AviaryCommon{
+            class AttributeType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            AttributeType_INTEGER,
+            AttributeType_FLOAT,
+            AttributeType_STRING,
+            AttributeType_EXPRESSION,
+            AttributeType_BOOLEAN,
+            AttributeType_UNDEFINED,
+            AttributeType_ERROR
+        } ADBAttributeTypeEnum;
+        
+        
+
+        class AttributeType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_AttributeType;
+
+                
+                bool isValidAttributeType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setAttributeTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class AttributeType
+         */
+
+        AttributeType();
+
+        /**
+         * Destructor AttributeType
+         */
+        ~AttributeType();
+
+
+       
+
+        /**
+         * Constructor for creating AttributeType
+         * @param 
+         * @param AttributeType std::string
+         * @return newly created AttributeType object
+         */
+        AttributeType(std::string arg_AttributeType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for AttributeType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getAttributeType();
+
+        /**
+         * Setter for AttributeType.
+         * @param arg_AttributeType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAttributeType(const std::string  arg_AttributeType);
+
+        /**
+         * Re setter for AttributeType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAttributeType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for AttributeType.
+            * @return ADBAttributeTypeEnum; -1 on failure
+            */
+            ADBAttributeTypeEnum WSF_CALL
+            getAttributeTypeEnum();
+            
+            /**
+            * Enum setter for AttributeType.
+            * @param arg_AttributeType ADBAttributeTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setAttributeTypeEnum(
+            const ADBAttributeTypeEnum arg_AttributeType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether AttributeType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAttributeTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param AttributeType_om_node node to serialize from
+         * @param AttributeType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* AttributeType_om_node, axiom_element_t *AttributeType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the AttributeType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for AttributeType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* ATTRIBUTETYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_Attributes.h b/src/condor_contrib/aviary/include/AviaryCommon_Attributes.h
new file mode 100644
index 0000000..d3c9823
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_Attributes.h
@@ -0,0 +1,296 @@
+
+
+        #ifndef AviaryCommon_ATTRIBUTES_H
+        #define AviaryCommon_ATTRIBUTES_H
+
+       /**
+        * Attributes.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  Attributes class
+        */
+
+        namespace AviaryCommon{
+            class Attributes;
+        }
+        
+
+        
+       #include "AviaryCommon_Attribute.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class Attributes {
+
+        private:
+             std::vector<AviaryCommon::Attribute*>* property_Attrs;
+
+                
+                bool isValidAttrs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setAttrsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class Attributes
+         */
+
+        Attributes();
+
+        /**
+         * Destructor Attributes
+         */
+        ~Attributes();
+
+
+       
+
+        /**
+         * Constructor for creating Attributes
+         * @param 
+         * @param Attrs std::vector<AviaryCommon::Attribute*>*
+         * @return newly created Attributes object
+         */
+        Attributes(std::vector<AviaryCommon::Attribute*>* arg_Attrs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for attrs. Deprecated for array types, Use getAttrsAt instead
+         * @return Array of AviaryCommon::Attribute*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::Attribute*>* WSF_CALL
+        getAttrs();
+
+        /**
+         * Setter for attrs.Deprecated for array types, Use setAttrsAt
+         * or addAttrs instead.
+         * @param arg_Attrs Array of AviaryCommon::Attribute*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAttrs(std::vector<AviaryCommon::Attribute*>*  arg_Attrs);
+
+        /**
+         * Re setter for attrs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAttrs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of attrs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::Attribute* of the array
+         */
+        WSF_EXTERN AviaryCommon::Attribute* WSF_CALL
+        getAttrsAt(int i);
+
+        /**
+         * Set the ith element of attrs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Attrs element to set AviaryCommon::Attribute* to the array
+         * @return ith AviaryCommon::Attribute* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAttrsAt(int i,
+                AviaryCommon::Attribute* arg_Attrs);
+
+
+        /**
+         * Add to attrs.
+         * @param arg_Attrs element to add AviaryCommon::Attribute* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addAttrs(
+            AviaryCommon::Attribute* arg_Attrs);
+
+        /**
+         * Get the size of the attrs array.
+         * @return the size of the attrs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofAttrs();
+
+        /**
+         * Remove the ith element of attrs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeAttrsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether attrs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAttrsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether attrs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isAttrsNilAt(int i);
+ 
+       
+        /**
+         * Set attrs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setAttrsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param Attributes_om_node node to serialize from
+         * @param Attributes_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* Attributes_om_node, axiom_element_t *Attributes_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the Attributes is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for attrs by property number (1)
+         * @return Array of AviaryCommon::Attributes.
+         */
+
+        std::vector<AviaryCommon::Attribute*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* ATTRIBUTES_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobConstraint.h b/src/condor_contrib/aviary/include/AviaryCommon_JobConstraint.h
new file mode 100644
index 0000000..80f3da0
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobConstraint.h
@@ -0,0 +1,253 @@
+
+
+        #ifndef AviaryCommon_JOBCONSTRAINT_H
+        #define AviaryCommon_JOBCONSTRAINT_H
+
+       /**
+        * JobConstraint.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobConstraint class
+        */
+
+        namespace AviaryCommon{
+            class JobConstraint;
+        }
+        
+
+        
+       #include "AviaryCommon_JobConstraintType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobConstraint {
+
+        private:
+             AviaryCommon::JobConstraintType* property_Type;
+
+                
+                bool isValidType;
+            std::string property_Value;
+
+                
+                bool isValidValue;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setTypeNil();
+            
+
+        bool WSF_CALL
+        setValueNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobConstraint
+         */
+
+        JobConstraint();
+
+        /**
+         * Destructor JobConstraint
+         */
+        ~JobConstraint();
+
+
+       
+
+        /**
+         * Constructor for creating JobConstraint
+         * @param 
+         * @param Type AviaryCommon::JobConstraintType*
+         * @param Value std::string
+         * @return newly created JobConstraint object
+         */
+        JobConstraint(AviaryCommon::JobConstraintType* arg_Type,std::string arg_Value);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for type. 
+         * @return AviaryCommon::JobConstraintType*
+         */
+        WSF_EXTERN AviaryCommon::JobConstraintType* WSF_CALL
+        getType();
+
+        /**
+         * Setter for type.
+         * @param arg_Type AviaryCommon::JobConstraintType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setType(AviaryCommon::JobConstraintType*  arg_Type);
+
+        /**
+         * Re setter for type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetType();
+        
+        
+
+        /**
+         * Getter for value. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getValue();
+
+        /**
+         * Setter for value.
+         * @param arg_Value std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setValue(const std::string  arg_Value);
+
+        /**
+         * Re setter for value
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetValue();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTypeNil();
+
+
+        
+
+        /**
+         * Check whether value is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isValueNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobConstraint_om_node node to serialize from
+         * @param JobConstraint_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobConstraint_om_node, axiom_element_t *JobConstraint_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobConstraint is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for type by property number (1)
+         * @return AviaryCommon::JobConstraintType
+         */
+
+        AviaryCommon::JobConstraintType* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for value by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* JOBCONSTRAINT_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobConstraintType.h b/src/condor_contrib/aviary/include/AviaryCommon_JobConstraintType.h
new file mode 100644
index 0000000..032c481
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobConstraintType.h
@@ -0,0 +1,246 @@
+
+
+        #ifndef AviaryCommon_JOBCONSTRAINTTYPE_H
+        #define AviaryCommon_JOBCONSTRAINTTYPE_H
+
+       /**
+        * JobConstraintType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobConstraintType class
+        */
+
+        namespace AviaryCommon{
+            class JobConstraintType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            JobConstraintType_CMD,
+            JobConstraintType_ARGS,
+            JobConstraintType_OWNER
+        } ADBJobConstraintTypeEnum;
+        
+        
+
+        class JobConstraintType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_JobConstraintType;
+
+                
+                bool isValidJobConstraintType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobConstraintTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobConstraintType
+         */
+
+        JobConstraintType();
+
+        /**
+         * Destructor JobConstraintType
+         */
+        ~JobConstraintType();
+
+
+       
+
+        /**
+         * Constructor for creating JobConstraintType
+         * @param 
+         * @param JobConstraintType std::string
+         * @return newly created JobConstraintType object
+         */
+        JobConstraintType(std::string arg_JobConstraintType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for JobConstraintType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getJobConstraintType();
+
+        /**
+         * Setter for JobConstraintType.
+         * @param arg_JobConstraintType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobConstraintType(const std::string  arg_JobConstraintType);
+
+        /**
+         * Re setter for JobConstraintType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobConstraintType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for JobConstraintType.
+            * @return ADBJobConstraintTypeEnum; -1 on failure
+            */
+            ADBJobConstraintTypeEnum WSF_CALL
+            getJobConstraintTypeEnum();
+            
+            /**
+            * Enum setter for JobConstraintType.
+            * @param arg_JobConstraintType ADBJobConstraintTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setJobConstraintTypeEnum(
+            const ADBJobConstraintTypeEnum arg_JobConstraintType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether JobConstraintType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobConstraintTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobConstraintType_om_node node to serialize from
+         * @param JobConstraintType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobConstraintType_om_node, axiom_element_t *JobConstraintType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobConstraintType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for JobConstraintType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* JOBCONSTRAINTTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobData.h b/src/condor_contrib/aviary/include/AviaryCommon_JobData.h
new file mode 100644
index 0000000..970bc6c
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobData.h
@@ -0,0 +1,255 @@
+
+
+        #ifndef AviaryCommon_JOBDATA_H
+        #define AviaryCommon_JOBDATA_H
+
+       /**
+        * JobData.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobData class
+        */
+
+        namespace AviaryCommon{
+            class JobData;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_JobDataType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobData {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::JobDataType* property_Type;
+
+                
+                bool isValidType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobData
+         */
+
+        JobData();
+
+        /**
+         * Destructor JobData
+         */
+        ~JobData();
+
+
+       
+
+        /**
+         * Constructor for creating JobData
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Type AviaryCommon::JobDataType*
+         * @return newly created JobData object
+         */
+        JobData(AviaryCommon::JobID* arg_Id,AviaryCommon::JobDataType* arg_Type);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for type. 
+         * @return AviaryCommon::JobDataType*
+         */
+        WSF_EXTERN AviaryCommon::JobDataType* WSF_CALL
+        getType();
+
+        /**
+         * Setter for type.
+         * @param arg_Type AviaryCommon::JobDataType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setType(AviaryCommon::JobDataType*  arg_Type);
+
+        /**
+         * Re setter for type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetType();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobData_om_node node to serialize from
+         * @param JobData_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobData_om_node, axiom_element_t *JobData_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobData is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for type by property number (2)
+         * @return AviaryCommon::JobDataType
+         */
+
+        AviaryCommon::JobDataType* WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* JOBDATA_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobDataType.h b/src/condor_contrib/aviary/include/AviaryCommon_JobDataType.h
new file mode 100644
index 0000000..94e2873
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobDataType.h
@@ -0,0 +1,246 @@
+
+
+        #ifndef AviaryCommon_JOBDATATYPE_H
+        #define AviaryCommon_JOBDATATYPE_H
+
+       /**
+        * JobDataType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobDataType class
+        */
+
+        namespace AviaryCommon{
+            class JobDataType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            JobDataType_ERR,
+            JobDataType_LOG,
+            JobDataType_OUT
+        } ADBJobDataTypeEnum;
+        
+        
+
+        class JobDataType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_JobDataType;
+
+                
+                bool isValidJobDataType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobDataTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobDataType
+         */
+
+        JobDataType();
+
+        /**
+         * Destructor JobDataType
+         */
+        ~JobDataType();
+
+
+       
+
+        /**
+         * Constructor for creating JobDataType
+         * @param 
+         * @param JobDataType std::string
+         * @return newly created JobDataType object
+         */
+        JobDataType(std::string arg_JobDataType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for JobDataType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getJobDataType();
+
+        /**
+         * Setter for JobDataType.
+         * @param arg_JobDataType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobDataType(const std::string  arg_JobDataType);
+
+        /**
+         * Re setter for JobDataType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobDataType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for JobDataType.
+            * @return ADBJobDataTypeEnum; -1 on failure
+            */
+            ADBJobDataTypeEnum WSF_CALL
+            getJobDataTypeEnum();
+            
+            /**
+            * Enum setter for JobDataType.
+            * @param arg_JobDataType ADBJobDataTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setJobDataTypeEnum(
+            const ADBJobDataTypeEnum arg_JobDataType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether JobDataType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobDataTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobDataType_om_node node to serialize from
+         * @param JobDataType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobDataType_om_node, axiom_element_t *JobDataType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobDataType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for JobDataType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* JOBDATATYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobDetails.h b/src/condor_contrib/aviary/include/AviaryCommon_JobDetails.h
new file mode 100644
index 0000000..6012bdb
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobDetails.h
@@ -0,0 +1,311 @@
+
+
+        #ifndef AviaryCommon_JOBDETAILS_H
+        #define AviaryCommon_JOBDETAILS_H
+
+       /**
+        * JobDetails.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobDetails class
+        */
+
+        namespace AviaryCommon{
+            class JobDetails;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+       #include "AviaryCommon_Attributes.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobDetails {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            AviaryCommon::Attributes* property_Details;
+
+                
+                bool isValidDetails;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setDetailsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobDetails
+         */
+
+        JobDetails();
+
+        /**
+         * Destructor JobDetails
+         */
+        ~JobDetails();
+
+
+       
+
+        /**
+         * Constructor for creating JobDetails
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Status AviaryCommon::Status*
+         * @param Details AviaryCommon::Attributes*
+         * @return newly created JobDetails object
+         */
+        JobDetails(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,AviaryCommon::Attributes* arg_Details);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for details. 
+         * @return AviaryCommon::Attributes*
+         */
+        WSF_EXTERN AviaryCommon::Attributes* WSF_CALL
+        getDetails();
+
+        /**
+         * Setter for details.
+         * @param arg_Details AviaryCommon::Attributes*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setDetails(AviaryCommon::Attributes*  arg_Details);
+
+        /**
+         * Re setter for details
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetDetails();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether details is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isDetailsNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobDetails_om_node node to serialize from
+         * @param JobDetails_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobDetails_om_node, axiom_element_t *JobDetails_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobDetails is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for details by property number (3)
+         * @return AviaryCommon::Attributes
+         */
+
+        AviaryCommon::Attributes* WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* JOBDETAILS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobID.h b/src/condor_contrib/aviary/include/AviaryCommon_JobID.h
new file mode 100644
index 0000000..4c62c81
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobID.h
@@ -0,0 +1,361 @@
+
+
+        #ifndef AviaryCommon_JOBID_H
+        #define AviaryCommon_JOBID_H
+
+       /**
+        * JobID.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobID class
+        */
+
+        namespace AviaryCommon{
+            class JobID;
+        }
+        
+
+        
+       #include "AviaryCommon_SubmissionID.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobID {
+
+        private:
+             std::string property_Job;
+
+                
+                bool isValidJob;
+            std::string property_Pool;
+
+                
+                bool isValidPool;
+            std::string property_Scheduler;
+
+                
+                bool isValidScheduler;
+            AviaryCommon::SubmissionID* property_Submission;
+
+                
+                bool isValidSubmission;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobNil();
+            
+
+        bool WSF_CALL
+        setPoolNil();
+            
+
+        bool WSF_CALL
+        setSchedulerNil();
+            
+
+        bool WSF_CALL
+        setSubmissionNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobID
+         */
+
+        JobID();
+
+        /**
+         * Destructor JobID
+         */
+        ~JobID();
+
+
+       
+
+        /**
+         * Constructor for creating JobID
+         * @param 
+         * @param Job std::string
+         * @param Pool std::string
+         * @param Scheduler std::string
+         * @param Submission AviaryCommon::SubmissionID*
+         * @return newly created JobID object
+         */
+        JobID(std::string arg_Job,std::string arg_Pool,std::string arg_Scheduler,AviaryCommon::SubmissionID* arg_Submission);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for job. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getJob();
+
+        /**
+         * Setter for job.
+         * @param arg_Job std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJob(const std::string  arg_Job);
+
+        /**
+         * Re setter for job
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJob();
+        
+        
+
+        /**
+         * Getter for pool. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getPool();
+
+        /**
+         * Setter for pool.
+         * @param arg_Pool std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPool(const std::string  arg_Pool);
+
+        /**
+         * Re setter for pool
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPool();
+        
+        
+
+        /**
+         * Getter for scheduler. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getScheduler();
+
+        /**
+         * Setter for scheduler.
+         * @param arg_Scheduler std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setScheduler(const std::string  arg_Scheduler);
+
+        /**
+         * Re setter for scheduler
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetScheduler();
+        
+        
+
+        /**
+         * Getter for submission. 
+         * @return AviaryCommon::SubmissionID*
+         */
+        WSF_EXTERN AviaryCommon::SubmissionID* WSF_CALL
+        getSubmission();
+
+        /**
+         * Setter for submission.
+         * @param arg_Submission AviaryCommon::SubmissionID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubmission(AviaryCommon::SubmissionID*  arg_Submission);
+
+        /**
+         * Re setter for submission
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSubmission();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether job is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobNil();
+
+
+        
+
+        /**
+         * Check whether pool is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPoolNil();
+
+
+        
+
+        /**
+         * Check whether scheduler is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSchedulerNil();
+
+
+        
+
+        /**
+         * Check whether submission is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSubmissionNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobID_om_node node to serialize from
+         * @param JobID_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobID_om_node, axiom_element_t *JobID_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobID is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for job by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for pool by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for scheduler by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for submission by property number (4)
+         * @return AviaryCommon::SubmissionID
+         */
+
+        AviaryCommon::SubmissionID* WSF_CALL
+        getProperty4();
+
+    
+
+};
+
+}        
+ #endif /* JOBID_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobStatus.h b/src/condor_contrib/aviary/include/AviaryCommon_JobStatus.h
new file mode 100644
index 0000000..999d200
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobStatus.h
@@ -0,0 +1,311 @@
+
+
+        #ifndef AviaryCommon_JOBSTATUS_H
+        #define AviaryCommon_JOBSTATUS_H
+
+       /**
+        * JobStatus.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobStatus class
+        */
+
+        namespace AviaryCommon{
+            class JobStatus;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+       #include "AviaryCommon_JobStatusType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobStatus {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            AviaryCommon::JobStatusType* property_Job_status;
+
+                
+                bool isValidJob_status;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setJob_statusNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobStatus
+         */
+
+        JobStatus();
+
+        /**
+         * Destructor JobStatus
+         */
+        ~JobStatus();
+
+
+       
+
+        /**
+         * Constructor for creating JobStatus
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Status AviaryCommon::Status*
+         * @param Job_status AviaryCommon::JobStatusType*
+         * @return newly created JobStatus object
+         */
+        JobStatus(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,AviaryCommon::JobStatusType* arg_Job_status);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for job_status. 
+         * @return AviaryCommon::JobStatusType*
+         */
+        WSF_EXTERN AviaryCommon::JobStatusType* WSF_CALL
+        getJob_status();
+
+        /**
+         * Setter for job_status.
+         * @param arg_Job_status AviaryCommon::JobStatusType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJob_status(AviaryCommon::JobStatusType*  arg_Job_status);
+
+        /**
+         * Re setter for job_status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJob_status();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether job_status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJob_statusNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobStatus_om_node node to serialize from
+         * @param JobStatus_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobStatus_om_node, axiom_element_t *JobStatus_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobStatus is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for job_status by property number (3)
+         * @return AviaryCommon::JobStatusType
+         */
+
+        AviaryCommon::JobStatusType* WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* JOBSTATUS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobStatusType.h b/src/condor_contrib/aviary/include/AviaryCommon_JobStatusType.h
new file mode 100644
index 0000000..076191a
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobStatusType.h
@@ -0,0 +1,248 @@
+
+
+        #ifndef AviaryCommon_JOBSTATUSTYPE_H
+        #define AviaryCommon_JOBSTATUSTYPE_H
+
+       /**
+        * JobStatusType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobStatusType class
+        */
+
+        namespace AviaryCommon{
+            class JobStatusType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            JobStatusType_IDLE,
+            JobStatusType_RUNNING,
+            JobStatusType_REMOVED,
+            JobStatusType_COMPLETED,
+            JobStatusType_HELD
+        } ADBJobStatusTypeEnum;
+        
+        
+
+        class JobStatusType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_JobStatusType;
+
+                
+                bool isValidJobStatusType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobStatusTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobStatusType
+         */
+
+        JobStatusType();
+
+        /**
+         * Destructor JobStatusType
+         */
+        ~JobStatusType();
+
+
+       
+
+        /**
+         * Constructor for creating JobStatusType
+         * @param 
+         * @param JobStatusType std::string
+         * @return newly created JobStatusType object
+         */
+        JobStatusType(std::string arg_JobStatusType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for JobStatusType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getJobStatusType();
+
+        /**
+         * Setter for JobStatusType.
+         * @param arg_JobStatusType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobStatusType(const std::string  arg_JobStatusType);
+
+        /**
+         * Re setter for JobStatusType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobStatusType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for JobStatusType.
+            * @return ADBJobStatusTypeEnum; -1 on failure
+            */
+            ADBJobStatusTypeEnum WSF_CALL
+            getJobStatusTypeEnum();
+            
+            /**
+            * Enum setter for JobStatusType.
+            * @param arg_JobStatusType ADBJobStatusTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setJobStatusTypeEnum(
+            const ADBJobStatusTypeEnum arg_JobStatusType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether JobStatusType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobStatusTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobStatusType_om_node node to serialize from
+         * @param JobStatusType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobStatusType_om_node, axiom_element_t *JobStatusType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobStatusType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for JobStatusType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* JOBSTATUSTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobSummary.h b/src/condor_contrib/aviary/include/AviaryCommon_JobSummary.h
new file mode 100644
index 0000000..b6128a6
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobSummary.h
@@ -0,0 +1,745 @@
+
+
+        #ifndef AviaryCommon_JOBSUMMARY_H
+        #define AviaryCommon_JOBSUMMARY_H
+
+       /**
+        * JobSummary.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobSummary class
+        */
+
+        namespace AviaryCommon{
+            class JobSummary;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+       #include "AviaryCommon_JobStatusType.h"
+          
+        #include <axutil_date_time.h>
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobSummary {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            axutil_date_time_t* property_Queued;
+
+                
+                bool isValidQueued;
+            axutil_date_time_t* property_Last_update;
+
+                
+                bool isValidLast_update;
+            AviaryCommon::JobStatusType* property_Job_status;
+
+                
+                bool isValidJob_status;
+            std::string property_Cmd;
+
+                
+                bool isValidCmd;
+            std::string property_Args1;
+
+                
+                bool isValidArgs1;
+            std::string property_Args2;
+
+                
+                bool isValidArgs2;
+            std::string property_Held;
+
+                
+                bool isValidHeld;
+            std::string property_Released;
+
+                
+                bool isValidReleased;
+            std::string property_Removed;
+
+                
+                bool isValidRemoved;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setQueuedNil();
+            
+
+        bool WSF_CALL
+        setLast_updateNil();
+            
+
+        bool WSF_CALL
+        setJob_statusNil();
+            
+
+        bool WSF_CALL
+        setCmdNil();
+            
+
+        bool WSF_CALL
+        setArgs1Nil();
+            
+
+        bool WSF_CALL
+        setArgs2Nil();
+            
+
+        bool WSF_CALL
+        setHeldNil();
+            
+
+        bool WSF_CALL
+        setReleasedNil();
+            
+
+        bool WSF_CALL
+        setRemovedNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobSummary
+         */
+
+        JobSummary();
+
+        /**
+         * Destructor JobSummary
+         */
+        ~JobSummary();
+
+
+       
+
+        /**
+         * Constructor for creating JobSummary
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Status AviaryCommon::Status*
+         * @param Queued axutil_date_time_t*
+         * @param Last_update axutil_date_time_t*
+         * @param Job_status AviaryCommon::JobStatusType*
+         * @param Cmd std::string
+         * @param Args1 std::string
+         * @param Args2 std::string
+         * @param Held std::string
+         * @param Released std::string
+         * @param Removed std::string
+         * @return newly created JobSummary object
+         */
+        JobSummary(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,axutil_date_time_t* arg_Queued,axutil_date_time_t* arg_Last_update,AviaryCommon::JobStatusType* arg_Job_status,std::string arg_Cmd,std::string arg_Args1,std::string arg_Args2,std::string arg_Held,std::string arg_Released,std::string arg_Removed);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for queued. 
+         * @return axutil_date_time_t*
+         */
+        WSF_EXTERN axutil_date_time_t* WSF_CALL
+        getQueued();
+
+        /**
+         * Setter for queued.
+         * @param arg_Queued axutil_date_time_t*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setQueued(axutil_date_time_t*  arg_Queued);
+
+        /**
+         * Re setter for queued
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetQueued();
+        
+        
+
+        /**
+         * Getter for last_update. 
+         * @return axutil_date_time_t*
+         */
+        WSF_EXTERN axutil_date_time_t* WSF_CALL
+        getLast_update();
+
+        /**
+         * Setter for last_update.
+         * @param arg_Last_update axutil_date_time_t*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setLast_update(axutil_date_time_t*  arg_Last_update);
+
+        /**
+         * Re setter for last_update
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetLast_update();
+        
+        
+
+        /**
+         * Getter for job_status. 
+         * @return AviaryCommon::JobStatusType*
+         */
+        WSF_EXTERN AviaryCommon::JobStatusType* WSF_CALL
+        getJob_status();
+
+        /**
+         * Setter for job_status.
+         * @param arg_Job_status AviaryCommon::JobStatusType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJob_status(AviaryCommon::JobStatusType*  arg_Job_status);
+
+        /**
+         * Re setter for job_status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJob_status();
+        
+        
+
+        /**
+         * Getter for cmd. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getCmd();
+
+        /**
+         * Setter for cmd.
+         * @param arg_Cmd std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCmd(const std::string  arg_Cmd);
+
+        /**
+         * Re setter for cmd
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCmd();
+        
+        
+
+        /**
+         * Getter for args1. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getArgs1();
+
+        /**
+         * Setter for args1.
+         * @param arg_Args1 std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setArgs1(const std::string  arg_Args1);
+
+        /**
+         * Re setter for args1
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetArgs1();
+        
+        
+
+        /**
+         * Getter for args2. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getArgs2();
+
+        /**
+         * Setter for args2.
+         * @param arg_Args2 std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setArgs2(const std::string  arg_Args2);
+
+        /**
+         * Re setter for args2
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetArgs2();
+        
+        
+
+        /**
+         * Getter for held. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getHeld();
+
+        /**
+         * Setter for held.
+         * @param arg_Held std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setHeld(const std::string  arg_Held);
+
+        /**
+         * Re setter for held
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetHeld();
+        
+        
+
+        /**
+         * Getter for released. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getReleased();
+
+        /**
+         * Setter for released.
+         * @param arg_Released std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setReleased(const std::string  arg_Released);
+
+        /**
+         * Re setter for released
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetReleased();
+        
+        
+
+        /**
+         * Getter for removed. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getRemoved();
+
+        /**
+         * Setter for removed.
+         * @param arg_Removed std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRemoved(const std::string  arg_Removed);
+
+        /**
+         * Re setter for removed
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRemoved();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether queued is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isQueuedNil();
+
+
+        
+
+        /**
+         * Check whether last_update is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isLast_updateNil();
+
+
+        
+
+        /**
+         * Check whether job_status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJob_statusNil();
+
+
+        
+
+        /**
+         * Check whether cmd is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCmdNil();
+
+
+        
+
+        /**
+         * Check whether args1 is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isArgs1Nil();
+
+
+        
+
+        /**
+         * Check whether args2 is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isArgs2Nil();
+
+
+        
+
+        /**
+         * Check whether held is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isHeldNil();
+
+
+        
+
+        /**
+         * Check whether released is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isReleasedNil();
+
+
+        
+
+        /**
+         * Check whether removed is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRemovedNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobSummary_om_node node to serialize from
+         * @param JobSummary_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobSummary_om_node, axiom_element_t *JobSummary_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobSummary is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for queued by property number (3)
+         * @return axutil_date_time_t*
+         */
+
+        axutil_date_time_t* WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for last_update by property number (4)
+         * @return axutil_date_time_t*
+         */
+
+        axutil_date_time_t* WSF_CALL
+        getProperty4();
+
+    
+        
+
+        /**
+         * Getter for job_status by property number (5)
+         * @return AviaryCommon::JobStatusType
+         */
+
+        AviaryCommon::JobStatusType* WSF_CALL
+        getProperty5();
+
+    
+        
+
+        /**
+         * Getter for cmd by property number (6)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty6();
+
+    
+        
+
+        /**
+         * Getter for args1 by property number (7)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty7();
+
+    
+        
+
+        /**
+         * Getter for args2 by property number (8)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty8();
+
+    
+        
+
+        /**
+         * Getter for held by property number (9)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty9();
+
+    
+        
+
+        /**
+         * Getter for released by property number (10)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty10();
+
+    
+        
+
+        /**
+         * Getter for removed by property number (11)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty11();
+
+    
+
+};
+
+}        
+ #endif /* JOBSUMMARY_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_OSType.h b/src/condor_contrib/aviary/include/AviaryCommon_OSType.h
new file mode 100644
index 0000000..3322a71
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_OSType.h
@@ -0,0 +1,245 @@
+
+
+        #ifndef AviaryCommon_OSTYPE_H
+        #define AviaryCommon_OSTYPE_H
+
+       /**
+        * OSType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  OSType class
+        */
+
+        namespace AviaryCommon{
+            class OSType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            OSType_LINUX,
+            OSType_WINDOWS
+        } ADBOSTypeEnum;
+        
+        
+
+        class OSType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_OSType;
+
+                
+                bool isValidOSType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setOSTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class OSType
+         */
+
+        OSType();
+
+        /**
+         * Destructor OSType
+         */
+        ~OSType();
+
+
+       
+
+        /**
+         * Constructor for creating OSType
+         * @param 
+         * @param OSType std::string
+         * @return newly created OSType object
+         */
+        OSType(std::string arg_OSType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for OSType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getOSType();
+
+        /**
+         * Setter for OSType.
+         * @param arg_OSType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setOSType(const std::string  arg_OSType);
+
+        /**
+         * Re setter for OSType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetOSType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for OSType.
+            * @return ADBOSTypeEnum; -1 on failure
+            */
+            ADBOSTypeEnum WSF_CALL
+            getOSTypeEnum();
+            
+            /**
+            * Enum setter for OSType.
+            * @param arg_OSType ADBOSTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setOSTypeEnum(
+            const ADBOSTypeEnum arg_OSType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether OSType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isOSTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param OSType_om_node node to serialize from
+         * @param OSType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* OSType_om_node, axiom_element_t *OSType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the OSType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for OSType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* OSTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraint.h b/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraint.h
new file mode 100644
index 0000000..12557d8
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraint.h
@@ -0,0 +1,253 @@
+
+
+        #ifndef AviaryCommon_RESOURCECONSTRAINT_H
+        #define AviaryCommon_RESOURCECONSTRAINT_H
+
+       /**
+        * ResourceConstraint.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ResourceConstraint class
+        */
+
+        namespace AviaryCommon{
+            class ResourceConstraint;
+        }
+        
+
+        
+       #include "AviaryCommon_ResourceConstraintType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class ResourceConstraint {
+
+        private:
+             AviaryCommon::ResourceConstraintType* property_Type;
+
+                
+                bool isValidType;
+            std::string property_Value;
+
+                
+                bool isValidValue;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setTypeNil();
+            
+
+        bool WSF_CALL
+        setValueNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ResourceConstraint
+         */
+
+        ResourceConstraint();
+
+        /**
+         * Destructor ResourceConstraint
+         */
+        ~ResourceConstraint();
+
+
+       
+
+        /**
+         * Constructor for creating ResourceConstraint
+         * @param 
+         * @param Type AviaryCommon::ResourceConstraintType*
+         * @param Value std::string
+         * @return newly created ResourceConstraint object
+         */
+        ResourceConstraint(AviaryCommon::ResourceConstraintType* arg_Type,std::string arg_Value);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for type. 
+         * @return AviaryCommon::ResourceConstraintType*
+         */
+        WSF_EXTERN AviaryCommon::ResourceConstraintType* WSF_CALL
+        getType();
+
+        /**
+         * Setter for type.
+         * @param arg_Type AviaryCommon::ResourceConstraintType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setType(AviaryCommon::ResourceConstraintType*  arg_Type);
+
+        /**
+         * Re setter for type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetType();
+        
+        
+
+        /**
+         * Getter for value. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getValue();
+
+        /**
+         * Setter for value.
+         * @param arg_Value std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setValue(const std::string  arg_Value);
+
+        /**
+         * Re setter for value
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetValue();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTypeNil();
+
+
+        
+
+        /**
+         * Check whether value is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isValueNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ResourceConstraint_om_node node to serialize from
+         * @param ResourceConstraint_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ResourceConstraint_om_node, axiom_element_t *ResourceConstraint_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ResourceConstraint is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for type by property number (1)
+         * @return AviaryCommon::ResourceConstraintType
+         */
+
+        AviaryCommon::ResourceConstraintType* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for value by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* RESOURCECONSTRAINT_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraintType.h b/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraintType.h
new file mode 100644
index 0000000..1b90eb1
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraintType.h
@@ -0,0 +1,248 @@
+
+
+        #ifndef AviaryCommon_RESOURCECONSTRAINTTYPE_H
+        #define AviaryCommon_RESOURCECONSTRAINTTYPE_H
+
+       /**
+        * ResourceConstraintType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ResourceConstraintType class
+        */
+
+        namespace AviaryCommon{
+            class ResourceConstraintType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            ResourceConstraintType_OS,
+            ResourceConstraintType_ARCH,
+            ResourceConstraintType_MEMORY,
+            ResourceConstraintType_DISK,
+            ResourceConstraintType_FILESYSTEM
+        } ADBResourceConstraintTypeEnum;
+        
+        
+
+        class ResourceConstraintType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_ResourceConstraintType;
+
+                
+                bool isValidResourceConstraintType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setResourceConstraintTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ResourceConstraintType
+         */
+
+        ResourceConstraintType();
+
+        /**
+         * Destructor ResourceConstraintType
+         */
+        ~ResourceConstraintType();
+
+
+       
+
+        /**
+         * Constructor for creating ResourceConstraintType
+         * @param 
+         * @param ResourceConstraintType std::string
+         * @return newly created ResourceConstraintType object
+         */
+        ResourceConstraintType(std::string arg_ResourceConstraintType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ResourceConstraintType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getResourceConstraintType();
+
+        /**
+         * Setter for ResourceConstraintType.
+         * @param arg_ResourceConstraintType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setResourceConstraintType(const std::string  arg_ResourceConstraintType);
+
+        /**
+         * Re setter for ResourceConstraintType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetResourceConstraintType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for ResourceConstraintType.
+            * @return ADBResourceConstraintTypeEnum; -1 on failure
+            */
+            ADBResourceConstraintTypeEnum WSF_CALL
+            getResourceConstraintTypeEnum();
+            
+            /**
+            * Enum setter for ResourceConstraintType.
+            * @param arg_ResourceConstraintType ADBResourceConstraintTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setResourceConstraintTypeEnum(
+            const ADBResourceConstraintTypeEnum arg_ResourceConstraintType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ResourceConstraintType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isResourceConstraintTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ResourceConstraintType_om_node node to serialize from
+         * @param ResourceConstraintType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ResourceConstraintType_om_node, axiom_element_t *ResourceConstraintType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ResourceConstraintType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ResourceConstraintType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* RESOURCECONSTRAINTTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ResourceID.h b/src/condor_contrib/aviary/include/AviaryCommon_ResourceID.h
new file mode 100644
index 0000000..c900d7b
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ResourceID.h
@@ -0,0 +1,361 @@
+
+
+        #ifndef AviaryCommon_RESOURCEID_H
+        #define AviaryCommon_RESOURCEID_H
+
+       /**
+        * ResourceID.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ResourceID class
+        */
+
+        namespace AviaryCommon{
+            class ResourceID;
+        }
+        
+
+        
+       #include "AviaryCommon_ResourceType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class ResourceID {
+
+        private:
+             AviaryCommon::ResourceType* property_Subsystem_type;
+
+                
+                bool isValidSubsystem_type;
+            std::string property_Pool;
+
+                
+                bool isValidPool;
+            std::string property_Name;
+
+                
+                bool isValidName;
+            std::string property_Custom_name;
+
+                
+                bool isValidCustom_name;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setSubsystem_typeNil();
+            
+
+        bool WSF_CALL
+        setPoolNil();
+            
+
+        bool WSF_CALL
+        setNameNil();
+            
+
+        bool WSF_CALL
+        setCustom_nameNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ResourceID
+         */
+
+        ResourceID();
+
+        /**
+         * Destructor ResourceID
+         */
+        ~ResourceID();
+
+
+       
+
+        /**
+         * Constructor for creating ResourceID
+         * @param 
+         * @param Subsystem_type AviaryCommon::ResourceType*
+         * @param Pool std::string
+         * @param Name std::string
+         * @param Custom_name std::string
+         * @return newly created ResourceID object
+         */
+        ResourceID(AviaryCommon::ResourceType* arg_Subsystem_type,std::string arg_Pool,std::string arg_Name,std::string arg_Custom_name);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for subsystem_type. 
+         * @return AviaryCommon::ResourceType*
+         */
+        WSF_EXTERN AviaryCommon::ResourceType* WSF_CALL
+        getSubsystem_type();
+
+        /**
+         * Setter for subsystem_type.
+         * @param arg_Subsystem_type AviaryCommon::ResourceType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubsystem_type(AviaryCommon::ResourceType*  arg_Subsystem_type);
+
+        /**
+         * Re setter for subsystem_type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSubsystem_type();
+        
+        
+
+        /**
+         * Getter for pool. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getPool();
+
+        /**
+         * Setter for pool.
+         * @param arg_Pool std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPool(const std::string  arg_Pool);
+
+        /**
+         * Re setter for pool
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPool();
+        
+        
+
+        /**
+         * Getter for name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getName();
+
+        /**
+         * Setter for name.
+         * @param arg_Name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setName(const std::string  arg_Name);
+
+        /**
+         * Re setter for name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetName();
+        
+        
+
+        /**
+         * Getter for custom_name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getCustom_name();
+
+        /**
+         * Setter for custom_name.
+         * @param arg_Custom_name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCustom_name(const std::string  arg_Custom_name);
+
+        /**
+         * Re setter for custom_name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCustom_name();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether subsystem_type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSubsystem_typeNil();
+
+
+        
+
+        /**
+         * Check whether pool is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPoolNil();
+
+
+        
+
+        /**
+         * Check whether name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isNameNil();
+
+
+        
+
+        /**
+         * Check whether custom_name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCustom_nameNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ResourceID_om_node node to serialize from
+         * @param ResourceID_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ResourceID_om_node, axiom_element_t *ResourceID_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ResourceID is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for subsystem_type by property number (1)
+         * @return AviaryCommon::ResourceType
+         */
+
+        AviaryCommon::ResourceType* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for pool by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for name by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for custom_name by property number (4)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty4();
+
+    
+
+};
+
+}        
+ #endif /* RESOURCEID_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ResourceType.h b/src/condor_contrib/aviary/include/AviaryCommon_ResourceType.h
new file mode 100644
index 0000000..dd42777
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ResourceType.h
@@ -0,0 +1,252 @@
+
+
+        #ifndef AviaryCommon_RESOURCETYPE_H
+        #define AviaryCommon_RESOURCETYPE_H
+
+       /**
+        * ResourceType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ResourceType class
+        */
+
+        namespace AviaryCommon{
+            class ResourceType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            ResourceType_COLLECTOR,
+            ResourceType_EXECUTOR,
+            ResourceType_EVENT_SERVER,
+            ResourceType_JOB_SERVER,
+            ResourceType_LOW_LATENCY,
+            ResourceType_MASTER,
+            ResourceType_NEGOTIATOR,
+            ResourceType_SCHEDULER,
+            ResourceType_CUSTOM
+        } ADBResourceTypeEnum;
+        
+        
+
+        class ResourceType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_ResourceType;
+
+                
+                bool isValidResourceType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setResourceTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ResourceType
+         */
+
+        ResourceType();
+
+        /**
+         * Destructor ResourceType
+         */
+        ~ResourceType();
+
+
+       
+
+        /**
+         * Constructor for creating ResourceType
+         * @param 
+         * @param ResourceType std::string
+         * @return newly created ResourceType object
+         */
+        ResourceType(std::string arg_ResourceType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ResourceType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getResourceType();
+
+        /**
+         * Setter for ResourceType.
+         * @param arg_ResourceType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setResourceType(const std::string  arg_ResourceType);
+
+        /**
+         * Re setter for ResourceType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetResourceType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for ResourceType.
+            * @return ADBResourceTypeEnum; -1 on failure
+            */
+            ADBResourceTypeEnum WSF_CALL
+            getResourceTypeEnum();
+            
+            /**
+            * Enum setter for ResourceType.
+            * @param arg_ResourceType ADBResourceTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setResourceTypeEnum(
+            const ADBResourceTypeEnum arg_ResourceType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ResourceType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isResourceTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ResourceType_om_node node to serialize from
+         * @param ResourceType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ResourceType_om_node, axiom_element_t *ResourceType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ResourceType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ResourceType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* RESOURCETYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_Status.h b/src/condor_contrib/aviary/include/AviaryCommon_Status.h
new file mode 100644
index 0000000..6c72d49
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_Status.h
@@ -0,0 +1,253 @@
+
+
+        #ifndef AviaryCommon_STATUS_H
+        #define AviaryCommon_STATUS_H
+
+       /**
+        * Status.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  Status class
+        */
+
+        namespace AviaryCommon{
+            class Status;
+        }
+        
+
+        
+       #include "AviaryCommon_StatusCodeType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class Status {
+
+        private:
+             AviaryCommon::StatusCodeType* property_Code;
+
+                
+                bool isValidCode;
+            std::string property_Text;
+
+                
+                bool isValidText;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setCodeNil();
+            
+
+        bool WSF_CALL
+        setTextNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class Status
+         */
+
+        Status();
+
+        /**
+         * Destructor Status
+         */
+        ~Status();
+
+
+       
+
+        /**
+         * Constructor for creating Status
+         * @param 
+         * @param Code AviaryCommon::StatusCodeType*
+         * @param Text std::string
+         * @return newly created Status object
+         */
+        Status(AviaryCommon::StatusCodeType* arg_Code,std::string arg_Text);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for code. 
+         * @return AviaryCommon::StatusCodeType*
+         */
+        WSF_EXTERN AviaryCommon::StatusCodeType* WSF_CALL
+        getCode();
+
+        /**
+         * Setter for code.
+         * @param arg_Code AviaryCommon::StatusCodeType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCode(AviaryCommon::StatusCodeType*  arg_Code);
+
+        /**
+         * Re setter for code
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCode();
+        
+        
+
+        /**
+         * Getter for text. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getText();
+
+        /**
+         * Setter for text.
+         * @param arg_Text std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setText(const std::string  arg_Text);
+
+        /**
+         * Re setter for text
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetText();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether code is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCodeNil();
+
+
+        
+
+        /**
+         * Check whether text is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTextNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param Status_om_node node to serialize from
+         * @param Status_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* Status_om_node, axiom_element_t *Status_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the Status is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for code by property number (1)
+         * @return AviaryCommon::StatusCodeType
+         */
+
+        AviaryCommon::StatusCodeType* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for text by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* STATUS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_StatusCodeType.h b/src/condor_contrib/aviary/include/AviaryCommon_StatusCodeType.h
new file mode 100644
index 0000000..bb71f9b
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_StatusCodeType.h
@@ -0,0 +1,249 @@
+
+
+        #ifndef AviaryCommon_STATUSCODETYPE_H
+        #define AviaryCommon_STATUSCODETYPE_H
+
+       /**
+        * StatusCodeType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  StatusCodeType class
+        */
+
+        namespace AviaryCommon{
+            class StatusCodeType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            StatusCodeType_OK,
+            StatusCodeType_FAIL,
+            StatusCodeType_NO_MATCH,
+            StatusCodeType_INVALID_OFFSET,
+            StatusCodeType_UNIMPLEMENTED,
+            StatusCodeType_UNAVAILABLE
+        } ADBStatusCodeTypeEnum;
+        
+        
+
+        class StatusCodeType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_StatusCodeType;
+
+                
+                bool isValidStatusCodeType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setStatusCodeTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class StatusCodeType
+         */
+
+        StatusCodeType();
+
+        /**
+         * Destructor StatusCodeType
+         */
+        ~StatusCodeType();
+
+
+       
+
+        /**
+         * Constructor for creating StatusCodeType
+         * @param 
+         * @param StatusCodeType std::string
+         * @return newly created StatusCodeType object
+         */
+        StatusCodeType(std::string arg_StatusCodeType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for StatusCodeType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getStatusCodeType();
+
+        /**
+         * Setter for StatusCodeType.
+         * @param arg_StatusCodeType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatusCodeType(const std::string  arg_StatusCodeType);
+
+        /**
+         * Re setter for StatusCodeType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatusCodeType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for StatusCodeType.
+            * @return ADBStatusCodeTypeEnum; -1 on failure
+            */
+            ADBStatusCodeTypeEnum WSF_CALL
+            getStatusCodeTypeEnum();
+            
+            /**
+            * Enum setter for StatusCodeType.
+            * @param arg_StatusCodeType ADBStatusCodeTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setStatusCodeTypeEnum(
+            const ADBStatusCodeTypeEnum arg_StatusCodeType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether StatusCodeType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusCodeTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param StatusCodeType_om_node node to serialize from
+         * @param StatusCodeType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* StatusCodeType_om_node, axiom_element_t *StatusCodeType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the StatusCodeType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for StatusCodeType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* STATUSCODETYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_SubmissionID.h b/src/condor_contrib/aviary/include/AviaryCommon_SubmissionID.h
new file mode 100644
index 0000000..f4abae2
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_SubmissionID.h
@@ -0,0 +1,251 @@
+
+
+        #ifndef AviaryCommon_SUBMISSIONID_H
+        #define AviaryCommon_SUBMISSIONID_H
+
+       /**
+        * SubmissionID.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SubmissionID class
+        */
+
+        namespace AviaryCommon{
+            class SubmissionID;
+        }
+        
+
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class SubmissionID {
+
+        private:
+             std::string property_Name;
+
+                
+                bool isValidName;
+            std::string property_Owner;
+
+                
+                bool isValidOwner;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setNameNil();
+            
+
+        bool WSF_CALL
+        setOwnerNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SubmissionID
+         */
+
+        SubmissionID();
+
+        /**
+         * Destructor SubmissionID
+         */
+        ~SubmissionID();
+
+
+       
+
+        /**
+         * Constructor for creating SubmissionID
+         * @param 
+         * @param Name std::string
+         * @param Owner std::string
+         * @return newly created SubmissionID object
+         */
+        SubmissionID(std::string arg_Name,std::string arg_Owner);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getName();
+
+        /**
+         * Setter for name.
+         * @param arg_Name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setName(const std::string  arg_Name);
+
+        /**
+         * Re setter for name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetName();
+        
+        
+
+        /**
+         * Getter for owner. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getOwner();
+
+        /**
+         * Setter for owner.
+         * @param arg_Owner std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setOwner(const std::string  arg_Owner);
+
+        /**
+         * Re setter for owner
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetOwner();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isNameNil();
+
+
+        
+
+        /**
+         * Check whether owner is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isOwnerNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SubmissionID_om_node node to serialize from
+         * @param SubmissionID_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SubmissionID_om_node, axiom_element_t *SubmissionID_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SubmissionID is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for name by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for owner by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* SUBMISSIONID_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_SubmissionSummary.h b/src/condor_contrib/aviary/include/AviaryCommon_SubmissionSummary.h
new file mode 100644
index 0000000..f72562e
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_SubmissionSummary.h
@@ -0,0 +1,678 @@
+
+
+        #ifndef AviaryCommon_SUBMISSIONSUMMARY_H
+        #define AviaryCommon_SUBMISSIONSUMMARY_H
+
+       /**
+        * SubmissionSummary.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SubmissionSummary class
+        */
+
+        namespace AviaryCommon{
+            class SubmissionSummary;
+        }
+        
+
+        
+       #include "AviaryCommon_SubmissionID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+       #include "AviaryCommon_JobSummary.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class SubmissionSummary {
+
+        private:
+             AviaryCommon::SubmissionID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            int property_Completed;
+
+                
+                bool isValidCompleted;
+            int property_Held;
+
+                
+                bool isValidHeld;
+            int property_Idle;
+
+                
+                bool isValidIdle;
+            int property_Removed;
+
+                
+                bool isValidRemoved;
+            int property_Running;
+
+                
+                bool isValidRunning;
+            std::vector<AviaryCommon::JobSummary*>* property_Jobs;
+
+                
+                bool isValidJobs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setCompletedNil();
+            
+
+        bool WSF_CALL
+        setHeldNil();
+            
+
+        bool WSF_CALL
+        setIdleNil();
+            
+
+        bool WSF_CALL
+        setRemovedNil();
+            
+
+        bool WSF_CALL
+        setRunningNil();
+            
+
+        bool WSF_CALL
+        setJobsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SubmissionSummary
+         */
+
+        SubmissionSummary();
+
+        /**
+         * Destructor SubmissionSummary
+         */
+        ~SubmissionSummary();
+
+
+       
+
+        /**
+         * Constructor for creating SubmissionSummary
+         * @param 
+         * @param Id AviaryCommon::SubmissionID*
+         * @param Status AviaryCommon::Status*
+         * @param Completed int
+         * @param Held int
+         * @param Idle int
+         * @param Removed int
+         * @param Running int
+         * @param Jobs std::vector<AviaryCommon::JobSummary*>*
+         * @return newly created SubmissionSummary object
+         */
+        SubmissionSummary(AviaryCommon::SubmissionID* arg_Id,AviaryCommon::Status* arg_Status,int arg_Completed,int arg_Held,int arg_Idle,int arg_Removed,int arg_Running,std::vector<AviaryCommon::JobSummary*>* arg_Jobs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::SubmissionID*
+         */
+        WSF_EXTERN AviaryCommon::SubmissionID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::SubmissionID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::SubmissionID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for completed. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getCompleted();
+
+        /**
+         * Setter for completed.
+         * @param arg_Completed int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCompleted(const int  arg_Completed);
+
+        /**
+         * Re setter for completed
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCompleted();
+        
+        
+
+        /**
+         * Getter for held. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getHeld();
+
+        /**
+         * Setter for held.
+         * @param arg_Held int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setHeld(const int  arg_Held);
+
+        /**
+         * Re setter for held
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetHeld();
+        
+        
+
+        /**
+         * Getter for idle. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getIdle();
+
+        /**
+         * Setter for idle.
+         * @param arg_Idle int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdle(const int  arg_Idle);
+
+        /**
+         * Re setter for idle
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIdle();
+        
+        
+
+        /**
+         * Getter for removed. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getRemoved();
+
+        /**
+         * Setter for removed.
+         * @param arg_Removed int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRemoved(const int  arg_Removed);
+
+        /**
+         * Re setter for removed
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRemoved();
+        
+        
+
+        /**
+         * Getter for running. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getRunning();
+
+        /**
+         * Setter for running.
+         * @param arg_Running int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRunning(const int  arg_Running);
+
+        /**
+         * Re setter for running
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRunning();
+        
+        
+
+        /**
+         * Getter for jobs. Deprecated for array types, Use getJobsAt instead
+         * @return Array of AviaryCommon::JobSummary*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+        getJobs();
+
+        /**
+         * Setter for jobs.Deprecated for array types, Use setJobsAt
+         * or addJobs instead.
+         * @param arg_Jobs Array of AviaryCommon::JobSummary*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobs(std::vector<AviaryCommon::JobSummary*>*  arg_Jobs);
+
+        /**
+         * Re setter for jobs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of jobs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobSummary* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobSummary* WSF_CALL
+        getJobsAt(int i);
+
+        /**
+         * Set the ith element of jobs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Jobs element to set AviaryCommon::JobSummary* to the array
+         * @return ith AviaryCommon::JobSummary* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobsAt(int i,
+                AviaryCommon::JobSummary* arg_Jobs);
+
+
+        /**
+         * Add to jobs.
+         * @param arg_Jobs element to add AviaryCommon::JobSummary* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addJobs(
+            AviaryCommon::JobSummary* arg_Jobs);
+
+        /**
+         * Get the size of the jobs array.
+         * @return the size of the jobs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofJobs();
+
+        /**
+         * Remove the ith element of jobs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeJobsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether completed is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCompletedNil();
+
+
+        
+
+        /**
+         * Check whether held is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isHeldNil();
+
+
+        
+
+        /**
+         * Check whether idle is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdleNil();
+
+
+        
+
+        /**
+         * Check whether removed is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRemovedNil();
+
+
+        
+
+        /**
+         * Check whether running is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRunningNil();
+
+
+        
+
+        /**
+         * Check whether jobs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether jobs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNilAt(int i);
+ 
+       
+        /**
+         * Set jobs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setJobsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SubmissionSummary_om_node node to serialize from
+         * @param SubmissionSummary_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SubmissionSummary_om_node, axiom_element_t *SubmissionSummary_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SubmissionSummary is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::SubmissionID
+         */
+
+        AviaryCommon::SubmissionID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for completed by property number (3)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for held by property number (4)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty4();
+
+    
+        
+
+        /**
+         * Getter for idle by property number (5)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty5();
+
+    
+        
+
+        /**
+         * Getter for removed by property number (6)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty6();
+
+    
+        
+
+        /**
+         * Getter for running by property number (7)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty7();
+
+    
+        
+
+        /**
+         * Getter for jobs by property number (8)
+         * @return Array of AviaryCommon::JobSummarys.
+         */
+
+        std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+        getProperty8();
+
+    
+
+};
+
+}        
+ #endif /* SUBMISSIONSUMMARY_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_ControlJob.h b/src/condor_contrib/aviary/include/AviaryJob_ControlJob.h
new file mode 100644
index 0000000..381e631
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_ControlJob.h
@@ -0,0 +1,253 @@
+
+
+        #ifndef AviaryJob_CONTROLJOB_H
+        #define AviaryJob_CONTROLJOB_H
+
+       /**
+        * ControlJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ControlJob class
+        */
+
+        namespace AviaryJob{
+            class ControlJob;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class ControlJob {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            std::string property_Reason;
+
+                
+                bool isValidReason;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setReasonNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ControlJob
+         */
+
+        ControlJob();
+
+        /**
+         * Destructor ControlJob
+         */
+        ~ControlJob();
+
+
+       
+
+        /**
+         * Constructor for creating ControlJob
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Reason std::string
+         * @return newly created ControlJob object
+         */
+        ControlJob(AviaryCommon::JobID* arg_Id,std::string arg_Reason);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for reason. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getReason();
+
+        /**
+         * Setter for reason.
+         * @param arg_Reason std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setReason(const std::string  arg_Reason);
+
+        /**
+         * Re setter for reason
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetReason();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether reason is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isReasonNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ControlJob_om_node node to serialize from
+         * @param ControlJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ControlJob_om_node, axiom_element_t *ControlJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ControlJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for reason by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* CONTROLJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_ControlJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_ControlJobResponse.h
new file mode 100644
index 0000000..cf03407
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_ControlJobResponse.h
@@ -0,0 +1,199 @@
+
+
+        #ifndef AviaryJob_CONTROLJOBRESPONSE_H
+        #define AviaryJob_CONTROLJOBRESPONSE_H
+
+       /**
+        * ControlJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ControlJobResponse class
+        */
+
+        namespace AviaryJob{
+            class ControlJobResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_Status.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class ControlJobResponse {
+
+        private:
+             AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ControlJobResponse
+         */
+
+        ControlJobResponse();
+
+        /**
+         * Destructor ControlJobResponse
+         */
+        ~ControlJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating ControlJobResponse
+         * @param 
+         * @param Status AviaryCommon::Status*
+         * @return newly created ControlJobResponse object
+         */
+        ControlJobResponse(AviaryCommon::Status* arg_Status);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ControlJobResponse_om_node node to serialize from
+         * @param ControlJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ControlJobResponse_om_node, axiom_element_t *ControlJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ControlJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for status by property number (1)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* CONTROLJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_HoldJob.h b/src/condor_contrib/aviary/include/AviaryJob_HoldJob.h
new file mode 100644
index 0000000..119d76f
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_HoldJob.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_HOLDJOB_H
+        #define AviaryJob_HOLDJOB_H
+
+       /**
+        * HoldJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  HoldJob class
+        */
+
+        namespace AviaryJob{
+            class HoldJob;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJob.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class HoldJob {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJob* property_HoldJob;
+
+                
+                bool isValidHoldJob;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setHoldJobNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class HoldJob
+         */
+
+        HoldJob();
+
+        /**
+         * Destructor HoldJob
+         */
+        ~HoldJob();
+
+
+       
+
+        /**
+         * Constructor for creating HoldJob
+         * @param 
+         * @param HoldJob AviaryJob::ControlJob*
+         * @return newly created HoldJob object
+         */
+        HoldJob(AviaryJob::ControlJob* arg_HoldJob);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for HoldJob. 
+         * @return AviaryJob::ControlJob*
+         */
+        WSF_EXTERN AviaryJob::ControlJob* WSF_CALL
+        getHoldJob();
+
+        /**
+         * Setter for HoldJob.
+         * @param arg_HoldJob AviaryJob::ControlJob*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setHoldJob(AviaryJob::ControlJob*  arg_HoldJob);
+
+        /**
+         * Re setter for HoldJob
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetHoldJob();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether HoldJob is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isHoldJobNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param HoldJob_om_node node to serialize from
+         * @param HoldJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* HoldJob_om_node, axiom_element_t *HoldJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the HoldJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for HoldJob by property number (1)
+         * @return AviaryJob::ControlJob
+         */
+
+        AviaryJob::ControlJob* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* HOLDJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_HoldJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_HoldJobResponse.h
new file mode 100644
index 0000000..3b8d1da
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_HoldJobResponse.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_HOLDJOBRESPONSE_H
+        #define AviaryJob_HOLDJOBRESPONSE_H
+
+       /**
+        * HoldJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  HoldJobResponse class
+        */
+
+        namespace AviaryJob{
+            class HoldJobResponse;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJobResponse.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class HoldJobResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJobResponse* property_HoldJobResponse;
+
+                
+                bool isValidHoldJobResponse;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setHoldJobResponseNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class HoldJobResponse
+         */
+
+        HoldJobResponse();
+
+        /**
+         * Destructor HoldJobResponse
+         */
+        ~HoldJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating HoldJobResponse
+         * @param 
+         * @param HoldJobResponse AviaryJob::ControlJobResponse*
+         * @return newly created HoldJobResponse object
+         */
+        HoldJobResponse(AviaryJob::ControlJobResponse* arg_HoldJobResponse);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for HoldJobResponse. 
+         * @return AviaryJob::ControlJobResponse*
+         */
+        WSF_EXTERN AviaryJob::ControlJobResponse* WSF_CALL
+        getHoldJobResponse();
+
+        /**
+         * Setter for HoldJobResponse.
+         * @param arg_HoldJobResponse AviaryJob::ControlJobResponse*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setHoldJobResponse(AviaryJob::ControlJobResponse*  arg_HoldJobResponse);
+
+        /**
+         * Re setter for HoldJobResponse
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetHoldJobResponse();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether HoldJobResponse is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isHoldJobResponseNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param HoldJobResponse_om_node node to serialize from
+         * @param HoldJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* HoldJobResponse_om_node, axiom_element_t *HoldJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the HoldJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for HoldJobResponse by property number (1)
+         * @return AviaryJob::ControlJobResponse
+         */
+
+        AviaryJob::ControlJobResponse* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* HOLDJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_ReleaseJob.h b/src/condor_contrib/aviary/include/AviaryJob_ReleaseJob.h
new file mode 100644
index 0000000..9fc3c14
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_ReleaseJob.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_RELEASEJOB_H
+        #define AviaryJob_RELEASEJOB_H
+
+       /**
+        * ReleaseJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ReleaseJob class
+        */
+
+        namespace AviaryJob{
+            class ReleaseJob;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJob.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class ReleaseJob {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJob* property_ReleaseJob;
+
+                
+                bool isValidReleaseJob;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setReleaseJobNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ReleaseJob
+         */
+
+        ReleaseJob();
+
+        /**
+         * Destructor ReleaseJob
+         */
+        ~ReleaseJob();
+
+
+       
+
+        /**
+         * Constructor for creating ReleaseJob
+         * @param 
+         * @param ReleaseJob AviaryJob::ControlJob*
+         * @return newly created ReleaseJob object
+         */
+        ReleaseJob(AviaryJob::ControlJob* arg_ReleaseJob);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ReleaseJob. 
+         * @return AviaryJob::ControlJob*
+         */
+        WSF_EXTERN AviaryJob::ControlJob* WSF_CALL
+        getReleaseJob();
+
+        /**
+         * Setter for ReleaseJob.
+         * @param arg_ReleaseJob AviaryJob::ControlJob*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setReleaseJob(AviaryJob::ControlJob*  arg_ReleaseJob);
+
+        /**
+         * Re setter for ReleaseJob
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetReleaseJob();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ReleaseJob is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isReleaseJobNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ReleaseJob_om_node node to serialize from
+         * @param ReleaseJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ReleaseJob_om_node, axiom_element_t *ReleaseJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ReleaseJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ReleaseJob by property number (1)
+         * @return AviaryJob::ControlJob
+         */
+
+        AviaryJob::ControlJob* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* RELEASEJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_ReleaseJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_ReleaseJobResponse.h
new file mode 100644
index 0000000..6247516
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_ReleaseJobResponse.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_RELEASEJOBRESPONSE_H
+        #define AviaryJob_RELEASEJOBRESPONSE_H
+
+       /**
+        * ReleaseJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ReleaseJobResponse class
+        */
+
+        namespace AviaryJob{
+            class ReleaseJobResponse;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJobResponse.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class ReleaseJobResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJobResponse* property_ReleaseJobResponse;
+
+                
+                bool isValidReleaseJobResponse;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setReleaseJobResponseNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ReleaseJobResponse
+         */
+
+        ReleaseJobResponse();
+
+        /**
+         * Destructor ReleaseJobResponse
+         */
+        ~ReleaseJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating ReleaseJobResponse
+         * @param 
+         * @param ReleaseJobResponse AviaryJob::ControlJobResponse*
+         * @return newly created ReleaseJobResponse object
+         */
+        ReleaseJobResponse(AviaryJob::ControlJobResponse* arg_ReleaseJobResponse);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ReleaseJobResponse. 
+         * @return AviaryJob::ControlJobResponse*
+         */
+        WSF_EXTERN AviaryJob::ControlJobResponse* WSF_CALL
+        getReleaseJobResponse();
+
+        /**
+         * Setter for ReleaseJobResponse.
+         * @param arg_ReleaseJobResponse AviaryJob::ControlJobResponse*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setReleaseJobResponse(AviaryJob::ControlJobResponse*  arg_ReleaseJobResponse);
+
+        /**
+         * Re setter for ReleaseJobResponse
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetReleaseJobResponse();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ReleaseJobResponse is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isReleaseJobResponseNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ReleaseJobResponse_om_node node to serialize from
+         * @param ReleaseJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ReleaseJobResponse_om_node, axiom_element_t *ReleaseJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ReleaseJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ReleaseJobResponse by property number (1)
+         * @return AviaryJob::ControlJobResponse
+         */
+
+        AviaryJob::ControlJobResponse* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* RELEASEJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_RemoveJob.h b/src/condor_contrib/aviary/include/AviaryJob_RemoveJob.h
new file mode 100644
index 0000000..7d66ddc
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_RemoveJob.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_REMOVEJOB_H
+        #define AviaryJob_REMOVEJOB_H
+
+       /**
+        * RemoveJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  RemoveJob class
+        */
+
+        namespace AviaryJob{
+            class RemoveJob;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJob.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class RemoveJob {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJob* property_RemoveJob;
+
+                
+                bool isValidRemoveJob;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setRemoveJobNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class RemoveJob
+         */
+
+        RemoveJob();
+
+        /**
+         * Destructor RemoveJob
+         */
+        ~RemoveJob();
+
+
+       
+
+        /**
+         * Constructor for creating RemoveJob
+         * @param 
+         * @param RemoveJob AviaryJob::ControlJob*
+         * @return newly created RemoveJob object
+         */
+        RemoveJob(AviaryJob::ControlJob* arg_RemoveJob);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for RemoveJob. 
+         * @return AviaryJob::ControlJob*
+         */
+        WSF_EXTERN AviaryJob::ControlJob* WSF_CALL
+        getRemoveJob();
+
+        /**
+         * Setter for RemoveJob.
+         * @param arg_RemoveJob AviaryJob::ControlJob*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRemoveJob(AviaryJob::ControlJob*  arg_RemoveJob);
+
+        /**
+         * Re setter for RemoveJob
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRemoveJob();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether RemoveJob is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRemoveJobNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param RemoveJob_om_node node to serialize from
+         * @param RemoveJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* RemoveJob_om_node, axiom_element_t *RemoveJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the RemoveJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for RemoveJob by property number (1)
+         * @return AviaryJob::ControlJob
+         */
+
+        AviaryJob::ControlJob* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* REMOVEJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_RemoveJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_RemoveJobResponse.h
new file mode 100644
index 0000000..eb67b57
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_RemoveJobResponse.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_REMOVEJOBRESPONSE_H
+        #define AviaryJob_REMOVEJOBRESPONSE_H
+
+       /**
+        * RemoveJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  RemoveJobResponse class
+        */
+
+        namespace AviaryJob{
+            class RemoveJobResponse;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJobResponse.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class RemoveJobResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJobResponse* property_RemoveJobResponse;
+
+                
+                bool isValidRemoveJobResponse;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setRemoveJobResponseNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class RemoveJobResponse
+         */
+
+        RemoveJobResponse();
+
+        /**
+         * Destructor RemoveJobResponse
+         */
+        ~RemoveJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating RemoveJobResponse
+         * @param 
+         * @param RemoveJobResponse AviaryJob::ControlJobResponse*
+         * @return newly created RemoveJobResponse object
+         */
+        RemoveJobResponse(AviaryJob::ControlJobResponse* arg_RemoveJobResponse);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for RemoveJobResponse. 
+         * @return AviaryJob::ControlJobResponse*
+         */
+        WSF_EXTERN AviaryJob::ControlJobResponse* WSF_CALL
+        getRemoveJobResponse();
+
+        /**
+         * Setter for RemoveJobResponse.
+         * @param arg_RemoveJobResponse AviaryJob::ControlJobResponse*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRemoveJobResponse(AviaryJob::ControlJobResponse*  arg_RemoveJobResponse);
+
+        /**
+         * Re setter for RemoveJobResponse
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRemoveJobResponse();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether RemoveJobResponse is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRemoveJobResponseNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param RemoveJobResponse_om_node node to serialize from
+         * @param RemoveJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* RemoveJobResponse_om_node, axiom_element_t *RemoveJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the RemoveJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for RemoveJobResponse by property number (1)
+         * @return AviaryJob::ControlJobResponse
+         */
+
+        AviaryJob::ControlJobResponse* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* REMOVEJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_SetJobAttribute.h b/src/condor_contrib/aviary/include/AviaryJob_SetJobAttribute.h
new file mode 100644
index 0000000..a046279
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_SetJobAttribute.h
@@ -0,0 +1,259 @@
+
+
+        #ifndef AviaryJob_SETJOBATTRIBUTE_H
+        #define AviaryJob_SETJOBATTRIBUTE_H
+
+       /**
+        * SetJobAttribute.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SetJobAttribute class
+        */
+
+        namespace AviaryJob{
+            class SetJobAttribute;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Attribute.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class SetJobAttribute {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Attribute* property_Attribute;
+
+                
+                bool isValidAttribute;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setAttributeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SetJobAttribute
+         */
+
+        SetJobAttribute();
+
+        /**
+         * Destructor SetJobAttribute
+         */
+        ~SetJobAttribute();
+
+
+       
+
+        /**
+         * Constructor for creating SetJobAttribute
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Attribute AviaryCommon::Attribute*
+         * @return newly created SetJobAttribute object
+         */
+        SetJobAttribute(AviaryCommon::JobID* arg_Id,AviaryCommon::Attribute* arg_Attribute);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for attribute. 
+         * @return AviaryCommon::Attribute*
+         */
+        WSF_EXTERN AviaryCommon::Attribute* WSF_CALL
+        getAttribute();
+
+        /**
+         * Setter for attribute.
+         * @param arg_Attribute AviaryCommon::Attribute*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAttribute(AviaryCommon::Attribute*  arg_Attribute);
+
+        /**
+         * Re setter for attribute
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAttribute();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether attribute is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAttributeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SetJobAttribute_om_node node to serialize from
+         * @param SetJobAttribute_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SetJobAttribute_om_node, axiom_element_t *SetJobAttribute_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SetJobAttribute is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for attribute by property number (2)
+         * @return AviaryCommon::Attribute
+         */
+
+        AviaryCommon::Attribute* WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* SETJOBATTRIBUTE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_SetJobAttributeResponse.h b/src/condor_contrib/aviary/include/AviaryJob_SetJobAttributeResponse.h
new file mode 100644
index 0000000..8d39178
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_SetJobAttributeResponse.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_SETJOBATTRIBUTERESPONSE_H
+        #define AviaryJob_SETJOBATTRIBUTERESPONSE_H
+
+       /**
+        * SetJobAttributeResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SetJobAttributeResponse class
+        */
+
+        namespace AviaryJob{
+            class SetJobAttributeResponse;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJobResponse.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class SetJobAttributeResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJobResponse* property_SetJobAttributeResponse;
+
+                
+                bool isValidSetJobAttributeResponse;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setSetJobAttributeResponseNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SetJobAttributeResponse
+         */
+
+        SetJobAttributeResponse();
+
+        /**
+         * Destructor SetJobAttributeResponse
+         */
+        ~SetJobAttributeResponse();
+
+
+       
+
+        /**
+         * Constructor for creating SetJobAttributeResponse
+         * @param 
+         * @param SetJobAttributeResponse AviaryJob::ControlJobResponse*
+         * @return newly created SetJobAttributeResponse object
+         */
+        SetJobAttributeResponse(AviaryJob::ControlJobResponse* arg_SetJobAttributeResponse);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for SetJobAttributeResponse. 
+         * @return AviaryJob::ControlJobResponse*
+         */
+        WSF_EXTERN AviaryJob::ControlJobResponse* WSF_CALL
+        getSetJobAttributeResponse();
+
+        /**
+         * Setter for SetJobAttributeResponse.
+         * @param arg_SetJobAttributeResponse AviaryJob::ControlJobResponse*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSetJobAttributeResponse(AviaryJob::ControlJobResponse*  arg_SetJobAttributeResponse);
+
+        /**
+         * Re setter for SetJobAttributeResponse
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSetJobAttributeResponse();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether SetJobAttributeResponse is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSetJobAttributeResponseNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SetJobAttributeResponse_om_node node to serialize from
+         * @param SetJobAttributeResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SetJobAttributeResponse_om_node, axiom_element_t *SetJobAttributeResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SetJobAttributeResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for SetJobAttributeResponse by property number (1)
+         * @return AviaryJob::ControlJobResponse
+         */
+
+        AviaryJob::ControlJobResponse* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* SETJOBATTRIBUTERESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_SubmitJob.h b/src/condor_contrib/aviary/include/AviaryJob_SubmitJob.h
new file mode 100644
index 0000000..e26d8ed
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_SubmitJob.h
@@ -0,0 +1,747 @@
+
+
+        #ifndef AviaryJob_SUBMITJOB_H
+        #define AviaryJob_SUBMITJOB_H
+
+       /**
+        * SubmitJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SubmitJob class
+        */
+
+        namespace AviaryJob{
+            class SubmitJob;
+        }
+        
+
+        
+       #include "AviaryCommon_ResourceConstraint.h"
+          
+       #include "AviaryCommon_Attribute.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class SubmitJob {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_Cmd;
+
+                
+                bool isValidCmd;
+            std::string property_Args;
+
+                
+                bool isValidArgs;
+            std::string property_Owner;
+
+                
+                bool isValidOwner;
+            std::string property_Iwd;
+
+                
+                bool isValidIwd;
+            std::string property_Submission_name;
+
+                
+                bool isValidSubmission_name;
+            std::vector<AviaryCommon::ResourceConstraint*>* property_Requirements;
+
+                
+                bool isValidRequirements;
+            std::vector<AviaryCommon::Attribute*>* property_Extra;
+
+                
+                bool isValidExtra;
+            bool property_AllowOverrides;
+
+                
+                bool isValidAllowOverrides;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setCmdNil();
+            
+
+        bool WSF_CALL
+        setArgsNil();
+            
+
+        bool WSF_CALL
+        setOwnerNil();
+            
+
+        bool WSF_CALL
+        setIwdNil();
+            
+
+        bool WSF_CALL
+        setSubmission_nameNil();
+            
+
+        bool WSF_CALL
+        setRequirementsNil();
+            
+
+        bool WSF_CALL
+        setExtraNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SubmitJob
+         */
+
+        SubmitJob();
+
+        /**
+         * Destructor SubmitJob
+         */
+        ~SubmitJob();
+
+
+       
+
+        /**
+         * Constructor for creating SubmitJob
+         * @param 
+         * @param Cmd std::string
+         * @param Args std::string
+         * @param Owner std::string
+         * @param Iwd std::string
+         * @param Submission_name std::string
+         * @param Requirements std::vector<AviaryCommon::ResourceConstraint*>*
+         * @param Extra std::vector<AviaryCommon::Attribute*>*
+         * @param AllowOverrides bool
+         * @return newly created SubmitJob object
+         */
+        SubmitJob(std::string arg_Cmd,std::string arg_Args,std::string arg_Owner,std::string arg_Iwd,std::string arg_Submission_name,std::vector<AviaryCommon::ResourceConstraint*>* arg_Requirements,std::vector<AviaryCommon::Attribute*>* arg_Extra,bool arg_AllowOverrides);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for cmd. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getCmd();
+
+        /**
+         * Setter for cmd.
+         * @param arg_Cmd std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCmd(const std::string  arg_Cmd);
+
+        /**
+         * Re setter for cmd
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCmd();
+        
+        
+
+        /**
+         * Getter for args. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getArgs();
+
+        /**
+         * Setter for args.
+         * @param arg_Args std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setArgs(const std::string  arg_Args);
+
+        /**
+         * Re setter for args
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetArgs();
+        
+        
+
+        /**
+         * Getter for owner. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getOwner();
+
+        /**
+         * Setter for owner.
+         * @param arg_Owner std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setOwner(const std::string  arg_Owner);
+
+        /**
+         * Re setter for owner
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetOwner();
+        
+        
+
+        /**
+         * Getter for iwd. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getIwd();
+
+        /**
+         * Setter for iwd.
+         * @param arg_Iwd std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIwd(const std::string  arg_Iwd);
+
+        /**
+         * Re setter for iwd
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIwd();
+        
+        
+
+        /**
+         * Getter for submission_name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getSubmission_name();
+
+        /**
+         * Setter for submission_name.
+         * @param arg_Submission_name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubmission_name(const std::string  arg_Submission_name);
+
+        /**
+         * Re setter for submission_name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSubmission_name();
+        
+        
+
+        /**
+         * Getter for requirements. Deprecated for array types, Use getRequirementsAt instead
+         * @return Array of AviaryCommon::ResourceConstraint*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::ResourceConstraint*>* WSF_CALL
+        getRequirements();
+
+        /**
+         * Setter for requirements.Deprecated for array types, Use setRequirementsAt
+         * or addRequirements instead.
+         * @param arg_Requirements Array of AviaryCommon::ResourceConstraint*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRequirements(std::vector<AviaryCommon::ResourceConstraint*>*  arg_Requirements);
+
+        /**
+         * Re setter for requirements
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRequirements();
+        
+        
+
+        /**
+         * Getter for extra. Deprecated for array types, Use getExtraAt instead
+         * @return Array of AviaryCommon::Attribute*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::Attribute*>* WSF_CALL
+        getExtra();
+
+        /**
+         * Setter for extra.Deprecated for array types, Use setExtraAt
+         * or addExtra instead.
+         * @param arg_Extra Array of AviaryCommon::Attribute*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setExtra(std::vector<AviaryCommon::Attribute*>*  arg_Extra);
+
+        /**
+         * Re setter for extra
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetExtra();
+        
+        
+
+        /**
+         * Getter for allowOverrides. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getAllowOverrides();
+
+        /**
+         * Setter for allowOverrides.
+         * @param arg_AllowOverrides bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAllowOverrides(bool  arg_AllowOverrides);
+
+        /**
+         * Re setter for allowOverrides
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAllowOverrides();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of requirements.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::ResourceConstraint* of the array
+         */
+        WSF_EXTERN AviaryCommon::ResourceConstraint* WSF_CALL
+        getRequirementsAt(int i);
+
+        /**
+         * Set the ith element of requirements. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Requirements element to set AviaryCommon::ResourceConstraint* to the array
+         * @return ith AviaryCommon::ResourceConstraint* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRequirementsAt(int i,
+                AviaryCommon::ResourceConstraint* arg_Requirements);
+
+
+        /**
+         * Add to requirements.
+         * @param arg_Requirements element to add AviaryCommon::ResourceConstraint* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addRequirements(
+            AviaryCommon::ResourceConstraint* arg_Requirements);
+
+        /**
+         * Get the size of the requirements array.
+         * @return the size of the requirements array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofRequirements();
+
+        /**
+         * Remove the ith element of requirements.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeRequirementsAt(int i);
+
+        
+        
+        /**
+         * Get the ith element of extra.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::Attribute* of the array
+         */
+        WSF_EXTERN AviaryCommon::Attribute* WSF_CALL
+        getExtraAt(int i);
+
+        /**
+         * Set the ith element of extra. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Extra element to set AviaryCommon::Attribute* to the array
+         * @return ith AviaryCommon::Attribute* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setExtraAt(int i,
+                AviaryCommon::Attribute* arg_Extra);
+
+
+        /**
+         * Add to extra.
+         * @param arg_Extra element to add AviaryCommon::Attribute* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addExtra(
+            AviaryCommon::Attribute* arg_Extra);
+
+        /**
+         * Get the size of the extra array.
+         * @return the size of the extra array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofExtra();
+
+        /**
+         * Remove the ith element of extra.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeExtraAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether cmd is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCmdNil();
+
+
+        
+
+        /**
+         * Check whether args is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isArgsNil();
+
+
+        
+
+        /**
+         * Check whether owner is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isOwnerNil();
+
+
+        
+
+        /**
+         * Check whether iwd is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIwdNil();
+
+
+        
+
+        /**
+         * Check whether submission_name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSubmission_nameNil();
+
+
+        
+
+        /**
+         * Check whether requirements is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRequirementsNil();
+
+
+        
+
+        /**
+         * Check whether extra is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isExtraNil();
+
+
+        
+
+        /**
+         * Check whether allowOverrides is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAllowOverridesNil();
+
+
+        
+        /**
+         * Set allowOverrides to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setAllowOverridesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether requirements is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isRequirementsNilAt(int i);
+ 
+       
+        /**
+         * Set requirements to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setRequirementsNilAt(int i);
+
+        
+        /**
+         * Check whether extra is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isExtraNilAt(int i);
+ 
+       
+        /**
+         * Set extra to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setExtraNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SubmitJob_om_node node to serialize from
+         * @param SubmitJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SubmitJob_om_node, axiom_element_t *SubmitJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SubmitJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for cmd by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for args by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for owner by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for iwd by property number (4)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty4();
+
+    
+        
+
+        /**
+         * Getter for submission_name by property number (5)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty5();
+
+    
+        
+
+        /**
+         * Getter for requirements by property number (6)
+         * @return Array of AviaryCommon::ResourceConstraints.
+         */
+
+        std::vector<AviaryCommon::ResourceConstraint*>* WSF_CALL
+        getProperty6();
+
+    
+        
+
+        /**
+         * Getter for extra by property number (7)
+         * @return Array of AviaryCommon::Attributes.
+         */
+
+        std::vector<AviaryCommon::Attribute*>* WSF_CALL
+        getProperty7();
+
+    
+        
+
+        /**
+         * Getter for allowOverrides by property number (8)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty8();
+
+    
+
+};
+
+}        
+ #endif /* SUBMITJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_SubmitJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_SubmitJobResponse.h
new file mode 100644
index 0000000..42b32fd
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_SubmitJobResponse.h
@@ -0,0 +1,259 @@
+
+
+        #ifndef AviaryJob_SUBMITJOBRESPONSE_H
+        #define AviaryJob_SUBMITJOBRESPONSE_H
+
+       /**
+        * SubmitJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SubmitJobResponse class
+        */
+
+        namespace AviaryJob{
+            class SubmitJobResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class SubmitJobResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SubmitJobResponse
+         */
+
+        SubmitJobResponse();
+
+        /**
+         * Destructor SubmitJobResponse
+         */
+        ~SubmitJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating SubmitJobResponse
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Status AviaryCommon::Status*
+         * @return newly created SubmitJobResponse object
+         */
+        SubmitJobResponse(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SubmitJobResponse_om_node node to serialize from
+         * @param SubmitJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SubmitJobResponse_om_node, axiom_element_t *SubmitJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SubmitJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* SUBMITJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobData.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobData.h
new file mode 100644
index 0000000..9439d0a
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobData.h
@@ -0,0 +1,311 @@
+
+
+        #ifndef AviaryQuery_GETJOBDATA_H
+        #define AviaryQuery_GETJOBDATA_H
+
+       /**
+        * GetJobData.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobData class
+        */
+
+        namespace AviaryQuery{
+            class GetJobData;
+        }
+        
+
+        
+       #include "AviaryCommon_JobData.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobData {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryCommon::JobData* property_Data;
+
+                
+                bool isValidData;
+            int property_Max_bytes;
+
+                
+                bool isValidMax_bytes;
+            bool property_From_end;
+
+                
+                bool isValidFrom_end;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setDataNil();
+            
+
+        bool WSF_CALL
+        setMax_bytesNil();
+            
+
+        bool WSF_CALL
+        setFrom_endNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobData
+         */
+
+        GetJobData();
+
+        /**
+         * Destructor GetJobData
+         */
+        ~GetJobData();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobData
+         * @param 
+         * @param Data AviaryCommon::JobData*
+         * @param Max_bytes int
+         * @param From_end bool
+         * @return newly created GetJobData object
+         */
+        GetJobData(AviaryCommon::JobData* arg_Data,int arg_Max_bytes,bool arg_From_end);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for data. 
+         * @return AviaryCommon::JobData*
+         */
+        WSF_EXTERN AviaryCommon::JobData* WSF_CALL
+        getData();
+
+        /**
+         * Setter for data.
+         * @param arg_Data AviaryCommon::JobData*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setData(AviaryCommon::JobData*  arg_Data);
+
+        /**
+         * Re setter for data
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetData();
+        
+        
+
+        /**
+         * Getter for max_bytes. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getMax_bytes();
+
+        /**
+         * Setter for max_bytes.
+         * @param arg_Max_bytes int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setMax_bytes(const int  arg_Max_bytes);
+
+        /**
+         * Re setter for max_bytes
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetMax_bytes();
+        
+        
+
+        /**
+         * Getter for from_end. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getFrom_end();
+
+        /**
+         * Setter for from_end.
+         * @param arg_From_end bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setFrom_end(bool  arg_From_end);
+
+        /**
+         * Re setter for from_end
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetFrom_end();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether data is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isDataNil();
+
+
+        
+
+        /**
+         * Check whether max_bytes is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isMax_bytesNil();
+
+
+        
+
+        /**
+         * Check whether from_end is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isFrom_endNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobData_om_node node to serialize from
+         * @param GetJobData_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobData_om_node, axiom_element_t *GetJobData_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobData is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for data by property number (1)
+         * @return AviaryCommon::JobData
+         */
+
+        AviaryCommon::JobData* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for max_bytes by property number (2)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for from_end by property number (3)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBDATA_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobDataResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDataResponse.h
new file mode 100644
index 0000000..6acae59
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDataResponse.h
@@ -0,0 +1,421 @@
+
+
+        #ifndef AviaryQuery_GETJOBDATARESPONSE_H
+        #define AviaryQuery_GETJOBDATARESPONSE_H
+
+       /**
+        * GetJobDataResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobDataResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetJobDataResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobData.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobDataResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryCommon::JobData* property_Data;
+
+                
+                bool isValidData;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            std::string property_File_name;
+
+                
+                bool isValidFile_name;
+            int property_File_size;
+
+                
+                bool isValidFile_size;
+            std::string property_Content;
+
+                
+                bool isValidContent;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setDataNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setFile_nameNil();
+            
+
+        bool WSF_CALL
+        setFile_sizeNil();
+            
+
+        bool WSF_CALL
+        setContentNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobDataResponse
+         */
+
+        GetJobDataResponse();
+
+        /**
+         * Destructor GetJobDataResponse
+         */
+        ~GetJobDataResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobDataResponse
+         * @param 
+         * @param Data AviaryCommon::JobData*
+         * @param Status AviaryCommon::Status*
+         * @param File_name std::string
+         * @param File_size int
+         * @param Content std::string
+         * @return newly created GetJobDataResponse object
+         */
+        GetJobDataResponse(AviaryCommon::JobData* arg_Data,AviaryCommon::Status* arg_Status,std::string arg_File_name,int arg_File_size,std::string arg_Content);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for data. 
+         * @return AviaryCommon::JobData*
+         */
+        WSF_EXTERN AviaryCommon::JobData* WSF_CALL
+        getData();
+
+        /**
+         * Setter for data.
+         * @param arg_Data AviaryCommon::JobData*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setData(AviaryCommon::JobData*  arg_Data);
+
+        /**
+         * Re setter for data
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetData();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for file_name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getFile_name();
+
+        /**
+         * Setter for file_name.
+         * @param arg_File_name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setFile_name(const std::string  arg_File_name);
+
+        /**
+         * Re setter for file_name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetFile_name();
+        
+        
+
+        /**
+         * Getter for file_size. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getFile_size();
+
+        /**
+         * Setter for file_size.
+         * @param arg_File_size int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setFile_size(const int  arg_File_size);
+
+        /**
+         * Re setter for file_size
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetFile_size();
+        
+        
+
+        /**
+         * Getter for content. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getContent();
+
+        /**
+         * Setter for content.
+         * @param arg_Content std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setContent(const std::string  arg_Content);
+
+        /**
+         * Re setter for content
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetContent();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether data is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isDataNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether file_name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isFile_nameNil();
+
+
+        
+
+        /**
+         * Check whether file_size is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isFile_sizeNil();
+
+
+        
+
+        /**
+         * Check whether content is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isContentNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobDataResponse_om_node node to serialize from
+         * @param GetJobDataResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobDataResponse_om_node, axiom_element_t *GetJobDataResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobDataResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for data by property number (1)
+         * @return AviaryCommon::JobData
+         */
+
+        AviaryCommon::JobData* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for file_name by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for file_size by property number (4)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty4();
+
+    
+        
+
+        /**
+         * Getter for content by property number (5)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty5();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBDATARESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetails.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetails.h
new file mode 100644
index 0000000..adcb87a
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetails.h
@@ -0,0 +1,357 @@
+
+
+        #ifndef AviaryQuery_GETJOBDETAILS_H
+        #define AviaryQuery_GETJOBDETAILS_H
+
+       /**
+        * GetJobDetails.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobDetails class
+        */
+
+        namespace AviaryQuery{
+            class GetJobDetails;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobDetails {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobID*>* property_Ids;
+
+                
+                bool isValidIds;
+            bool property_PartialMatches;
+
+                
+                bool isValidPartialMatches;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobDetails
+         */
+
+        GetJobDetails();
+
+        /**
+         * Destructor GetJobDetails
+         */
+        ~GetJobDetails();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobDetails
+         * @param 
+         * @param Ids std::vector<AviaryCommon::JobID*>*
+         * @param PartialMatches bool
+         * @return newly created GetJobDetails object
+         */
+        GetJobDetails(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for ids. Deprecated for array types, Use getIdsAt instead
+         * @return Array of AviaryCommon::JobID*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getIds();
+
+        /**
+         * Setter for ids.Deprecated for array types, Use setIdsAt
+         * or addIds instead.
+         * @param arg_Ids Array of AviaryCommon::JobID*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIds(std::vector<AviaryCommon::JobID*>*  arg_Ids);
+
+        /**
+         * Re setter for ids
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIds();
+        
+        
+
+        /**
+         * Getter for partialMatches. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getPartialMatches();
+
+        /**
+         * Setter for partialMatches.
+         * @param arg_PartialMatches bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPartialMatches(bool  arg_PartialMatches);
+
+        /**
+         * Re setter for partialMatches
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPartialMatches();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of ids.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getIdsAt(int i);
+
+        /**
+         * Set the ith element of ids. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Ids element to set AviaryCommon::JobID* to the array
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdsAt(int i,
+                AviaryCommon::JobID* arg_Ids);
+
+
+        /**
+         * Add to ids.
+         * @param arg_Ids element to add AviaryCommon::JobID* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addIds(
+            AviaryCommon::JobID* arg_Ids);
+
+        /**
+         * Get the size of the ids array.
+         * @return the size of the ids array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofIds();
+
+        /**
+         * Remove the ith element of ids.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeIdsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ids is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNil();
+
+
+        
+
+        /**
+         * Check whether partialMatches is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPartialMatchesNil();
+
+
+        
+        /**
+         * Set partialMatches to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setPartialMatchesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether ids is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNilAt(int i);
+ 
+       
+        /**
+         * Set ids to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIdsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobDetails_om_node node to serialize from
+         * @param GetJobDetails_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobDetails_om_node, axiom_element_t *GetJobDetails_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobDetails is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ids by property number (1)
+         * @return Array of AviaryCommon::JobIDs.
+         */
+
+        std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for partialMatches by property number (2)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBDETAILS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetailsResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetailsResponse.h
new file mode 100644
index 0000000..d8bfb23
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetailsResponse.h
@@ -0,0 +1,300 @@
+
+
+        #ifndef AviaryQuery_GETJOBDETAILSRESPONSE_H
+        #define AviaryQuery_GETJOBDETAILSRESPONSE_H
+
+       /**
+        * GetJobDetailsResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobDetailsResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetJobDetailsResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobDetails.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobDetailsResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobDetails*>* property_Jobs;
+
+                
+                bool isValidJobs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobDetailsResponse
+         */
+
+        GetJobDetailsResponse();
+
+        /**
+         * Destructor GetJobDetailsResponse
+         */
+        ~GetJobDetailsResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobDetailsResponse
+         * @param 
+         * @param Jobs std::vector<AviaryCommon::JobDetails*>*
+         * @return newly created GetJobDetailsResponse object
+         */
+        GetJobDetailsResponse(std::vector<AviaryCommon::JobDetails*>* arg_Jobs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for jobs. Deprecated for array types, Use getJobsAt instead
+         * @return Array of AviaryCommon::JobDetails*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobDetails*>* WSF_CALL
+        getJobs();
+
+        /**
+         * Setter for jobs.Deprecated for array types, Use setJobsAt
+         * or addJobs instead.
+         * @param arg_Jobs Array of AviaryCommon::JobDetails*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobs(std::vector<AviaryCommon::JobDetails*>*  arg_Jobs);
+
+        /**
+         * Re setter for jobs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of jobs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobDetails* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobDetails* WSF_CALL
+        getJobsAt(int i);
+
+        /**
+         * Set the ith element of jobs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Jobs element to set AviaryCommon::JobDetails* to the array
+         * @return ith AviaryCommon::JobDetails* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobsAt(int i,
+                AviaryCommon::JobDetails* arg_Jobs);
+
+
+        /**
+         * Add to jobs.
+         * @param arg_Jobs element to add AviaryCommon::JobDetails* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addJobs(
+            AviaryCommon::JobDetails* arg_Jobs);
+
+        /**
+         * Get the size of the jobs array.
+         * @return the size of the jobs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofJobs();
+
+        /**
+         * Remove the ith element of jobs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeJobsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether jobs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether jobs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNilAt(int i);
+ 
+       
+        /**
+         * Set jobs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setJobsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobDetailsResponse_om_node node to serialize from
+         * @param GetJobDetailsResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobDetailsResponse_om_node, axiom_element_t *GetJobDetailsResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobDetailsResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for jobs by property number (1)
+         * @return Array of AviaryCommon::JobDetailss.
+         */
+
+        std::vector<AviaryCommon::JobDetails*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBDETAILSRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatus.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatus.h
new file mode 100644
index 0000000..aa9142f
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatus.h
@@ -0,0 +1,357 @@
+
+
+        #ifndef AviaryQuery_GETJOBSTATUS_H
+        #define AviaryQuery_GETJOBSTATUS_H
+
+       /**
+        * GetJobStatus.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobStatus class
+        */
+
+        namespace AviaryQuery{
+            class GetJobStatus;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobStatus {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobID*>* property_Ids;
+
+                
+                bool isValidIds;
+            bool property_PartialMatches;
+
+                
+                bool isValidPartialMatches;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobStatus
+         */
+
+        GetJobStatus();
+
+        /**
+         * Destructor GetJobStatus
+         */
+        ~GetJobStatus();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobStatus
+         * @param 
+         * @param Ids std::vector<AviaryCommon::JobID*>*
+         * @param PartialMatches bool
+         * @return newly created GetJobStatus object
+         */
+        GetJobStatus(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for ids. Deprecated for array types, Use getIdsAt instead
+         * @return Array of AviaryCommon::JobID*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getIds();
+
+        /**
+         * Setter for ids.Deprecated for array types, Use setIdsAt
+         * or addIds instead.
+         * @param arg_Ids Array of AviaryCommon::JobID*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIds(std::vector<AviaryCommon::JobID*>*  arg_Ids);
+
+        /**
+         * Re setter for ids
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIds();
+        
+        
+
+        /**
+         * Getter for partialMatches. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getPartialMatches();
+
+        /**
+         * Setter for partialMatches.
+         * @param arg_PartialMatches bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPartialMatches(bool  arg_PartialMatches);
+
+        /**
+         * Re setter for partialMatches
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPartialMatches();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of ids.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getIdsAt(int i);
+
+        /**
+         * Set the ith element of ids. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Ids element to set AviaryCommon::JobID* to the array
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdsAt(int i,
+                AviaryCommon::JobID* arg_Ids);
+
+
+        /**
+         * Add to ids.
+         * @param arg_Ids element to add AviaryCommon::JobID* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addIds(
+            AviaryCommon::JobID* arg_Ids);
+
+        /**
+         * Get the size of the ids array.
+         * @return the size of the ids array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofIds();
+
+        /**
+         * Remove the ith element of ids.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeIdsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ids is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNil();
+
+
+        
+
+        /**
+         * Check whether partialMatches is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPartialMatchesNil();
+
+
+        
+        /**
+         * Set partialMatches to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setPartialMatchesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether ids is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNilAt(int i);
+ 
+       
+        /**
+         * Set ids to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIdsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobStatus_om_node node to serialize from
+         * @param GetJobStatus_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobStatus_om_node, axiom_element_t *GetJobStatus_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobStatus is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ids by property number (1)
+         * @return Array of AviaryCommon::JobIDs.
+         */
+
+        std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for partialMatches by property number (2)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBSTATUS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatusResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatusResponse.h
new file mode 100644
index 0000000..d75adb5
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatusResponse.h
@@ -0,0 +1,300 @@
+
+
+        #ifndef AviaryQuery_GETJOBSTATUSRESPONSE_H
+        #define AviaryQuery_GETJOBSTATUSRESPONSE_H
+
+       /**
+        * GetJobStatusResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobStatusResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetJobStatusResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobStatus.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobStatusResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobStatus*>* property_Jobs;
+
+                
+                bool isValidJobs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobStatusResponse
+         */
+
+        GetJobStatusResponse();
+
+        /**
+         * Destructor GetJobStatusResponse
+         */
+        ~GetJobStatusResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobStatusResponse
+         * @param 
+         * @param Jobs std::vector<AviaryCommon::JobStatus*>*
+         * @return newly created GetJobStatusResponse object
+         */
+        GetJobStatusResponse(std::vector<AviaryCommon::JobStatus*>* arg_Jobs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for jobs. Deprecated for array types, Use getJobsAt instead
+         * @return Array of AviaryCommon::JobStatus*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobStatus*>* WSF_CALL
+        getJobs();
+
+        /**
+         * Setter for jobs.Deprecated for array types, Use setJobsAt
+         * or addJobs instead.
+         * @param arg_Jobs Array of AviaryCommon::JobStatus*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobs(std::vector<AviaryCommon::JobStatus*>*  arg_Jobs);
+
+        /**
+         * Re setter for jobs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of jobs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobStatus* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobStatus* WSF_CALL
+        getJobsAt(int i);
+
+        /**
+         * Set the ith element of jobs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Jobs element to set AviaryCommon::JobStatus* to the array
+         * @return ith AviaryCommon::JobStatus* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobsAt(int i,
+                AviaryCommon::JobStatus* arg_Jobs);
+
+
+        /**
+         * Add to jobs.
+         * @param arg_Jobs element to add AviaryCommon::JobStatus* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addJobs(
+            AviaryCommon::JobStatus* arg_Jobs);
+
+        /**
+         * Get the size of the jobs array.
+         * @return the size of the jobs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofJobs();
+
+        /**
+         * Remove the ith element of jobs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeJobsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether jobs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether jobs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNilAt(int i);
+ 
+       
+        /**
+         * Set jobs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setJobsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobStatusResponse_om_node node to serialize from
+         * @param GetJobStatusResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobStatusResponse_om_node, axiom_element_t *GetJobStatusResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobStatusResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for jobs by property number (1)
+         * @return Array of AviaryCommon::JobStatuss.
+         */
+
+        std::vector<AviaryCommon::JobStatus*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBSTATUSRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummary.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummary.h
new file mode 100644
index 0000000..9751a88
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummary.h
@@ -0,0 +1,357 @@
+
+
+        #ifndef AviaryQuery_GETJOBSUMMARY_H
+        #define AviaryQuery_GETJOBSUMMARY_H
+
+       /**
+        * GetJobSummary.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobSummary class
+        */
+
+        namespace AviaryQuery{
+            class GetJobSummary;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobSummary {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobID*>* property_Ids;
+
+                
+                bool isValidIds;
+            bool property_PartialMatches;
+
+                
+                bool isValidPartialMatches;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobSummary
+         */
+
+        GetJobSummary();
+
+        /**
+         * Destructor GetJobSummary
+         */
+        ~GetJobSummary();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobSummary
+         * @param 
+         * @param Ids std::vector<AviaryCommon::JobID*>*
+         * @param PartialMatches bool
+         * @return newly created GetJobSummary object
+         */
+        GetJobSummary(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for ids. Deprecated for array types, Use getIdsAt instead
+         * @return Array of AviaryCommon::JobID*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getIds();
+
+        /**
+         * Setter for ids.Deprecated for array types, Use setIdsAt
+         * or addIds instead.
+         * @param arg_Ids Array of AviaryCommon::JobID*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIds(std::vector<AviaryCommon::JobID*>*  arg_Ids);
+
+        /**
+         * Re setter for ids
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIds();
+        
+        
+
+        /**
+         * Getter for partialMatches. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getPartialMatches();
+
+        /**
+         * Setter for partialMatches.
+         * @param arg_PartialMatches bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPartialMatches(bool  arg_PartialMatches);
+
+        /**
+         * Re setter for partialMatches
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPartialMatches();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of ids.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getIdsAt(int i);
+
+        /**
+         * Set the ith element of ids. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Ids element to set AviaryCommon::JobID* to the array
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdsAt(int i,
+                AviaryCommon::JobID* arg_Ids);
+
+
+        /**
+         * Add to ids.
+         * @param arg_Ids element to add AviaryCommon::JobID* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addIds(
+            AviaryCommon::JobID* arg_Ids);
+
+        /**
+         * Get the size of the ids array.
+         * @return the size of the ids array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofIds();
+
+        /**
+         * Remove the ith element of ids.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeIdsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ids is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNil();
+
+
+        
+
+        /**
+         * Check whether partialMatches is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPartialMatchesNil();
+
+
+        
+        /**
+         * Set partialMatches to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setPartialMatchesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether ids is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNilAt(int i);
+ 
+       
+        /**
+         * Set ids to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIdsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobSummary_om_node node to serialize from
+         * @param GetJobSummary_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobSummary_om_node, axiom_element_t *GetJobSummary_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobSummary is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ids by property number (1)
+         * @return Array of AviaryCommon::JobIDs.
+         */
+
+        std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for partialMatches by property number (2)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBSUMMARY_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummaryResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummaryResponse.h
new file mode 100644
index 0000000..5946d52
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummaryResponse.h
@@ -0,0 +1,300 @@
+
+
+        #ifndef AviaryQuery_GETJOBSUMMARYRESPONSE_H
+        #define AviaryQuery_GETJOBSUMMARYRESPONSE_H
+
+       /**
+        * GetJobSummaryResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobSummaryResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetJobSummaryResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobSummary.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobSummaryResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobSummary*>* property_Jobs;
+
+                
+                bool isValidJobs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobSummaryResponse
+         */
+
+        GetJobSummaryResponse();
+
+        /**
+         * Destructor GetJobSummaryResponse
+         */
+        ~GetJobSummaryResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobSummaryResponse
+         * @param 
+         * @param Jobs std::vector<AviaryCommon::JobSummary*>*
+         * @return newly created GetJobSummaryResponse object
+         */
+        GetJobSummaryResponse(std::vector<AviaryCommon::JobSummary*>* arg_Jobs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for jobs. Deprecated for array types, Use getJobsAt instead
+         * @return Array of AviaryCommon::JobSummary*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+        getJobs();
+
+        /**
+         * Setter for jobs.Deprecated for array types, Use setJobsAt
+         * or addJobs instead.
+         * @param arg_Jobs Array of AviaryCommon::JobSummary*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobs(std::vector<AviaryCommon::JobSummary*>*  arg_Jobs);
+
+        /**
+         * Re setter for jobs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of jobs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobSummary* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobSummary* WSF_CALL
+        getJobsAt(int i);
+
+        /**
+         * Set the ith element of jobs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Jobs element to set AviaryCommon::JobSummary* to the array
+         * @return ith AviaryCommon::JobSummary* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobsAt(int i,
+                AviaryCommon::JobSummary* arg_Jobs);
+
+
+        /**
+         * Add to jobs.
+         * @param arg_Jobs element to add AviaryCommon::JobSummary* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addJobs(
+            AviaryCommon::JobSummary* arg_Jobs);
+
+        /**
+         * Get the size of the jobs array.
+         * @return the size of the jobs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofJobs();
+
+        /**
+         * Remove the ith element of jobs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeJobsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether jobs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether jobs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNilAt(int i);
+ 
+       
+        /**
+         * Set jobs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setJobsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobSummaryResponse_om_node node to serialize from
+         * @param GetJobSummaryResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobSummaryResponse_om_node, axiom_element_t *GetJobSummaryResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobSummaryResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for jobs by property number (1)
+         * @return Array of AviaryCommon::JobSummarys.
+         */
+
+        std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBSUMMARYRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummary.h b/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummary.h
new file mode 100644
index 0000000..0085561
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummary.h
@@ -0,0 +1,414 @@
+
+
+        #ifndef AviaryQuery_GETSUBMISSIONSUMMARY_H
+        #define AviaryQuery_GETSUBMISSIONSUMMARY_H
+
+       /**
+        * GetSubmissionSummary.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetSubmissionSummary class
+        */
+
+        namespace AviaryQuery{
+            class GetSubmissionSummary;
+        }
+        
+
+        
+       #include "AviaryCommon_SubmissionID.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetSubmissionSummary {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::SubmissionID*>* property_Ids;
+
+                
+                bool isValidIds;
+            bool property_PartialMatches;
+
+                
+                bool isValidPartialMatches;
+            bool property_IncludeJobSummaries;
+
+                
+                bool isValidIncludeJobSummaries;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetSubmissionSummary
+         */
+
+        GetSubmissionSummary();
+
+        /**
+         * Destructor GetSubmissionSummary
+         */
+        ~GetSubmissionSummary();
+
+
+       
+
+        /**
+         * Constructor for creating GetSubmissionSummary
+         * @param 
+         * @param Ids std::vector<AviaryCommon::SubmissionID*>*
+         * @param PartialMatches bool
+         * @param IncludeJobSummaries bool
+         * @return newly created GetSubmissionSummary object
+         */
+        GetSubmissionSummary(std::vector<AviaryCommon::SubmissionID*>* arg_Ids,bool arg_PartialMatches,bool arg_IncludeJobSummaries);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for ids. Deprecated for array types, Use getIdsAt instead
+         * @return Array of AviaryCommon::SubmissionID*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::SubmissionID*>* WSF_CALL
+        getIds();
+
+        /**
+         * Setter for ids.Deprecated for array types, Use setIdsAt
+         * or addIds instead.
+         * @param arg_Ids Array of AviaryCommon::SubmissionID*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIds(std::vector<AviaryCommon::SubmissionID*>*  arg_Ids);
+
+        /**
+         * Re setter for ids
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIds();
+        
+        
+
+        /**
+         * Getter for partialMatches. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getPartialMatches();
+
+        /**
+         * Setter for partialMatches.
+         * @param arg_PartialMatches bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPartialMatches(bool  arg_PartialMatches);
+
+        /**
+         * Re setter for partialMatches
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPartialMatches();
+        
+        
+
+        /**
+         * Getter for includeJobSummaries. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getIncludeJobSummaries();
+
+        /**
+         * Setter for includeJobSummaries.
+         * @param arg_IncludeJobSummaries bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIncludeJobSummaries(bool  arg_IncludeJobSummaries);
+
+        /**
+         * Re setter for includeJobSummaries
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIncludeJobSummaries();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of ids.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::SubmissionID* of the array
+         */
+        WSF_EXTERN AviaryCommon::SubmissionID* WSF_CALL
+        getIdsAt(int i);
+
+        /**
+         * Set the ith element of ids. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Ids element to set AviaryCommon::SubmissionID* to the array
+         * @return ith AviaryCommon::SubmissionID* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdsAt(int i,
+                AviaryCommon::SubmissionID* arg_Ids);
+
+
+        /**
+         * Add to ids.
+         * @param arg_Ids element to add AviaryCommon::SubmissionID* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addIds(
+            AviaryCommon::SubmissionID* arg_Ids);
+
+        /**
+         * Get the size of the ids array.
+         * @return the size of the ids array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofIds();
+
+        /**
+         * Remove the ith element of ids.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeIdsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ids is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNil();
+
+
+        
+
+        /**
+         * Check whether partialMatches is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPartialMatchesNil();
+
+
+        
+        /**
+         * Set partialMatches to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setPartialMatchesNil();
+        
+
+        /**
+         * Check whether includeJobSummaries is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIncludeJobSummariesNil();
+
+
+        
+        /**
+         * Set includeJobSummaries to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIncludeJobSummariesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether ids is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNilAt(int i);
+ 
+       
+        /**
+         * Set ids to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIdsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetSubmissionSummary_om_node node to serialize from
+         * @param GetSubmissionSummary_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetSubmissionSummary_om_node, axiom_element_t *GetSubmissionSummary_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetSubmissionSummary is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ids by property number (1)
+         * @return Array of AviaryCommon::SubmissionIDs.
+         */
+
+        std::vector<AviaryCommon::SubmissionID*>* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for partialMatches by property number (2)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for includeJobSummaries by property number (3)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* GETSUBMISSIONSUMMARY_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummaryResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummaryResponse.h
new file mode 100644
index 0000000..36b5a9e
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummaryResponse.h
@@ -0,0 +1,300 @@
+
+
+        #ifndef AviaryQuery_GETSUBMISSIONSUMMARYRESPONSE_H
+        #define AviaryQuery_GETSUBMISSIONSUMMARYRESPONSE_H
+
+       /**
+        * GetSubmissionSummaryResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetSubmissionSummaryResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetSubmissionSummaryResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_SubmissionSummary.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetSubmissionSummaryResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::SubmissionSummary*>* property_Submissions;
+
+                
+                bool isValidSubmissions;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setSubmissionsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetSubmissionSummaryResponse
+         */
+
+        GetSubmissionSummaryResponse();
+
+        /**
+         * Destructor GetSubmissionSummaryResponse
+         */
+        ~GetSubmissionSummaryResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetSubmissionSummaryResponse
+         * @param 
+         * @param Submissions std::vector<AviaryCommon::SubmissionSummary*>*
+         * @return newly created GetSubmissionSummaryResponse object
+         */
+        GetSubmissionSummaryResponse(std::vector<AviaryCommon::SubmissionSummary*>* arg_Submissions);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for submissions. Deprecated for array types, Use getSubmissionsAt instead
+         * @return Array of AviaryCommon::SubmissionSummary*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::SubmissionSummary*>* WSF_CALL
+        getSubmissions();
+
+        /**
+         * Setter for submissions.Deprecated for array types, Use setSubmissionsAt
+         * or addSubmissions instead.
+         * @param arg_Submissions Array of AviaryCommon::SubmissionSummary*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubmissions(std::vector<AviaryCommon::SubmissionSummary*>*  arg_Submissions);
+
+        /**
+         * Re setter for submissions
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSubmissions();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of submissions.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::SubmissionSummary* of the array
+         */
+        WSF_EXTERN AviaryCommon::SubmissionSummary* WSF_CALL
+        getSubmissionsAt(int i);
+
+        /**
+         * Set the ith element of submissions. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Submissions element to set AviaryCommon::SubmissionSummary* to the array
+         * @return ith AviaryCommon::SubmissionSummary* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubmissionsAt(int i,
+                AviaryCommon::SubmissionSummary* arg_Submissions);
+
+
+        /**
+         * Add to submissions.
+         * @param arg_Submissions element to add AviaryCommon::SubmissionSummary* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addSubmissions(
+            AviaryCommon::SubmissionSummary* arg_Submissions);
+
+        /**
+         * Get the size of the submissions array.
+         * @return the size of the submissions array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofSubmissions();
+
+        /**
+         * Remove the ith element of submissions.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeSubmissionsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether submissions is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSubmissionsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether submissions is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isSubmissionsNilAt(int i);
+ 
+       
+        /**
+         * Set submissions to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setSubmissionsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetSubmissionSummaryResponse_om_node node to serialize from
+         * @param GetSubmissionSummaryResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetSubmissionSummaryResponse_om_node, axiom_element_t *GetSubmissionSummaryResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetSubmissionSummaryResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for submissions by property number (1)
+         * @return Array of AviaryCommon::SubmissionSummarys.
+         */
+
+        std::vector<AviaryCommon::SubmissionSummary*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* GETSUBMISSIONSUMMARYRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_QueryRequestType.h b/src/condor_contrib/aviary/include/AviaryQuery_QueryRequestType.h
new file mode 100644
index 0000000..40de943
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_QueryRequestType.h
@@ -0,0 +1,200 @@
+
+
+        #ifndef AviaryQuery_QUERYREQUESTTYPE_H
+        #define AviaryQuery_QUERYREQUESTTYPE_H
+
+       /**
+        * QueryRequestType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  QueryRequestType class
+        */
+
+        namespace AviaryQuery{
+            class QueryRequestType;
+        }
+        
+
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class QueryRequestType {
+
+        private:
+             bool property_AllowPartialMatching;
+
+                
+                bool isValidAllowPartialMatching;
+            
+
+        /*** Private methods ***/
+          
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class QueryRequestType
+         */
+
+        QueryRequestType();
+
+        /**
+         * Destructor QueryRequestType
+         */
+        ~QueryRequestType();
+
+
+       
+
+        /**
+         * Constructor for creating QueryRequestType
+         * @param 
+         * @param AllowPartialMatching bool
+         * @return newly created QueryRequestType object
+         */
+        QueryRequestType(bool arg_AllowPartialMatching);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for allowPartialMatching. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getAllowPartialMatching();
+
+        /**
+         * Setter for allowPartialMatching.
+         * @param arg_AllowPartialMatching bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAllowPartialMatching(bool  arg_AllowPartialMatching);
+
+        /**
+         * Re setter for allowPartialMatching
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAllowPartialMatching();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether allowPartialMatching is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAllowPartialMatchingNil();
+
+
+        
+        /**
+         * Set allowPartialMatching to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setAllowPartialMatchingNil();
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param QueryRequestType_om_node node to serialize from
+         * @param QueryRequestType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* QueryRequestType_om_node, axiom_element_t *QueryRequestType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the QueryRequestType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for allowPartialMatching by property number (1)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* QUERYREQUESTTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/license.txt b/src/condor_contrib/aviary/license.txt
new file mode 100644
index 0000000..046ad71
--- /dev/null
+++ b/src/condor_contrib/aviary/license.txt
@@ -0,0 +1,14 @@
+Copyright 2009-2011 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
diff --git a/src/condor_contrib/aviary/services/job/services.xml b/src/condor_contrib/aviary/services/job/services.xml
new file mode 100644
index 0000000..ab94581
--- /dev/null
+++ b/src/condor_contrib/aviary/services/job/services.xml
@@ -0,0 +1,26 @@
+<!-- This file was auto-generated from WSDL -->
+<!-- by the Apache Axis2 version: 1.0  Built on : Jan 09, 2011 (11:40:28 EST) -->
+<service name="AviaryJobService">
+<parameter name="ServiceClass" locked="xsd:false">aviary_job_axis</parameter>
+<description>AviaryJobServiceService</description>
+<operation name="submitJob" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#submit</parameter>
+</operation>
+<operation name="holdJob" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#hold</parameter>
+</operation>
+<operation name="releaseJob" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#release</parameter>
+</operation>
+<operation name="removeJob" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#remove</parameter>
+</operation>
+<operation name="setJobAttribute" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#setattr</parameter>
+</operation>
+</service>
diff --git a/src/condor_contrib/aviary/services/query/services.xml b/src/condor_contrib/aviary/services/query/services.xml
new file mode 100644
index 0000000..b516976a
--- /dev/null
+++ b/src/condor_contrib/aviary/services/query/services.xml
@@ -0,0 +1,26 @@
+<!-- This file was auto-generated from WSDL -->
+<!-- by the Apache Axis2 version: 1.0  Built on : Mar 02, 2011 (11:53:41 EST) -->
+<service name="AviaryQueryService">
+<parameter name="ServiceClass" locked="xsd:false">aviary_query_axis</parameter>
+<description>AviaryQueryServiceService</description>
+<operation name="getJobSummary" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#summary</parameter>
+</operation>
+<operation name="getJobStatus" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#status</parameter>
+</operation>
+<operation name="getJobDetails" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#details</parameter>
+</operation>
+<operation name="getJobData" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#data</parameter>
+</operation>
+<operation name="getSubmissionSummary" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#submission</parameter>
+</operation>
+</service>
diff --git a/src/condor_contrib/aviary/src/AviaryConversionMacros.h b/src/condor_contrib/aviary/src/AviaryConversionMacros.h
new file mode 100644
index 0000000..f809e75
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryConversionMacros.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVIARY_CONVERSION_MACROS_H
+#define AVIARY_CONVERSION_MACROS_H
+
+#define MGMT_DECLARATIONS	\
+ExprTree *expr;				\
+int num;					\
+float flt;					\
+char *str;					\
+(void)expr;(void)num;(void)flt;(void)str;
+
+
+#define BASE(attr,type,lookup_var,set_var,extra)					\
+if (ad.Lookup##type(#attr, lookup_var)) {							\
+	m_stats.attr = ((set_var) extra);						\
+} else {															\
+	dprintf(D_FULLDEBUG, "Warning: Could not find " #attr "\n");		\
+}
+
+#define OPT_BASE(attr,type,lookup_var,set_var,extra)				\
+if (ad.Lookup##type(#attr, lookup_var)) {							\
+	m_stats.attr = ((set_var) extra);						\
+} else {															\
+	m_stats.attr = "";										\
+}
+
+#define STRING(attr)												\
+if (ad.LookupString(#attr, &str)) {									\
+	m_stats.attr = str;									\
+	free(str);														\
+} else {															\
+	dprintf(D_FULLDEBUG, "Warning: Could not find " #attr "\n");		\
+}
+
+#define OPT_STRING(attr)												\
+if (ad.LookupString(#attr, &str)) {									\
+	m_stats.attr = str;									\
+	free(str);														\
+} else {															\
+	m_stats.attr = "";										\
+}
+
+#define INTEGER(attr) BASE(attr,Integer,num,(uint32_t) num,)
+#define OPT_INTEGER(attr) OPT_BASE(attr,Integer,num,(uint32_t) num,)
+#define DOUBLE(attr) BASE(attr,Float,flt,(double) flt,)
+#define OPT_DOUBLE(attr) OPT_BASE(attr,Float,flt,(double) flt,)
+#define TIME_INTEGER(attr) BASE(attr,Integer,num,(uint64_t) num,* 1000000000)
+#define OPT_TIME_INTEGER(attr) OPT_BASE(attr,Integer,num,(uint64_t) num,* 1000000000)
+
+#define EXPR(attr)													\
+	EXPR_BASE(attr,													\
+			  dprintf(D_FULLDEBUG, "Warning: " #attr " not found\n"))
+
+#define OPT_EXPR(attr)											 	\
+	EXPR_BASE(attr,													\
+			  m_stats.attr = "")
+
+#define EXPR_BASE(attr,else_action)									\
+expr = ad.Lookup(#attr);											\
+if (expr) {                                                         \
+      str = const_cast<char*>(ExprTreeToString(expr));              \
+      m_stats.attr = str;                             \
+} else {                                                         \
+      dprintf(D_FULLDEBUG, "Warning: " #attr " has no value\n");    	\
+}
+
+#endif /* AVIARY_CONVERSION_MACROS_H */
diff --git a/src/condor_contrib/aviary/src/AviaryJobService.cpp b/src/condor_contrib/aviary/src/AviaryJobService.cpp
new file mode 100644
index 0000000..ee80c5e
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobService.cpp
@@ -0,0 +1,356 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+        #include "AviaryJobServiceSkeleton.h"
+        #include "AviaryJobService.h"  
+        #include <ServiceSkeleton.h>
+        #include <stdio.h>
+        #include <axis2_svc.h>
+        #include <Environment.h>
+        #include <axiom_soap.h>
+
+
+        using namespace wso2wsf;
+        
+        using namespace AviaryJob;
+        
+
+        /** Load the service into axis2 engine */
+        WSF_SERVICE_INIT(AviaryJobService)
+
+          
+         /**
+          * function to free any soap input headers
+          */
+         AviaryJobService::AviaryJobService()
+	{
+          skel = wsfGetAviaryJobServiceSkeleton();
+    }
+
+
+	void WSF_CALL
+	AviaryJobService::init()
+	{
+
+      return;
+	}
+
+
+	AviaryJobService::~AviaryJobService()
+	{
+    }
+
+
+     
+
+     
+
+
+
+
+	/*
+	 * This method invokes the right service method
+	 */
+	OMElement* WSF_CALL
+	AviaryJobService::invoke(OMElement *omEle, MessageContext *msgCtx)
+	{
+         /* Using the function name, invoke the corresponding method
+          */
+
+          axis2_op_ctx_t *operation_ctx = NULL;
+          axis2_op_t *operation = NULL;
+          axutil_qname_t *op_qname = NULL;
+          axis2_char_t *op_name = NULL;
+          axis2_msg_ctx_t *in_msg_ctx = NULL;
+          
+          axiom_soap_envelope_t *req_soap_env = NULL;
+          axiom_soap_header_t *req_soap_header = NULL;
+          axiom_soap_envelope_t *res_soap_env = NULL;
+          axiom_soap_header_t *res_soap_header = NULL;
+
+          axiom_node_t *ret_node = NULL;
+          axiom_node_t *input_header = NULL;
+          axiom_node_t *output_header = NULL;
+          axiom_node_t *header_base_node = NULL;
+          axis2_msg_ctx_t *msg_ctx = NULL;
+          axiom_node_t* content_node = omEle->getAxiomNode();
+
+          
+            AviaryJob::RemoveJobResponse* ret_val1;
+            AviaryJob::RemoveJob* input_val1;
+            
+            AviaryJob::ReleaseJobResponse* ret_val2;
+            AviaryJob::ReleaseJob* input_val2;
+            
+            AviaryJob::SubmitJobResponse* ret_val3;
+            AviaryJob::SubmitJob* input_val3;
+            
+            AviaryJob::HoldJobResponse* ret_val4;
+            AviaryJob::HoldJob* input_val4;
+            
+            AviaryJob::SetJobAttributeResponse* ret_val5;
+            AviaryJob::SetJobAttribute* input_val5;
+            
+       
+          msg_ctx = msgCtx->getAxis2MessageContext();
+          operation_ctx = axis2_msg_ctx_get_op_ctx(msg_ctx, Environment::getEnv());
+          operation = axis2_op_ctx_get_op(operation_ctx, Environment::getEnv());
+          op_qname = (axutil_qname_t *)axis2_op_get_qname(operation, Environment::getEnv());
+          op_name = axutil_qname_get_localpart(op_qname, Environment::getEnv());
+
+          if (op_name)
+          {
+               
+
+                if ( axutil_strcmp(op_name, "removeJob") == 0 )
+                {
+
+                    
+                    input_val1 =
+                        
+                        new AviaryJob::RemoveJob();
+                        if( AXIS2_FAILURE ==  input_val1->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::RemoveJob_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val1 =  skel->removeJob(msgCtx ,input_val1);
+                    
+                        if ( NULL == ret_val1 )
+                        {
+                            
+                                delete input_val1;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val1->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val1;
+                                        
+                                            delete input_val1;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "releaseJob") == 0 )
+                {
+
+                    
+                    input_val2 =
+                        
+                        new AviaryJob::ReleaseJob();
+                        if( AXIS2_FAILURE ==  input_val2->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::ReleaseJob_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val2 =  skel->releaseJob(msgCtx ,input_val2);
+                    
+                        if ( NULL == ret_val2 )
+                        {
+                            
+                                delete input_val2;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val2->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val2;
+                                        
+                                            delete input_val2;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "submitJob") == 0 )
+                {
+
+                    
+                    input_val3 =
+                        
+                        new AviaryJob::SubmitJob();
+                        if( AXIS2_FAILURE ==  input_val3->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::SubmitJob_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val3 =  skel->submitJob(msgCtx ,input_val3);
+                    
+                        if ( NULL == ret_val3 )
+                        {
+                            
+                                delete input_val3;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val3->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val3;
+                                        
+                                            delete input_val3;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "holdJob") == 0 )
+                {
+
+                    
+                    input_val4 =
+                        
+                        new AviaryJob::HoldJob();
+                        if( AXIS2_FAILURE ==  input_val4->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::HoldJob_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val4 =  skel->holdJob(msgCtx ,input_val4);
+                    
+                        if ( NULL == ret_val4 )
+                        {
+                            
+                                delete input_val4;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val4->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val4;
+                                        
+                                            delete input_val4;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "setJobAttribute") == 0 )
+                {
+
+                    
+                    input_val5 =
+                        
+                        new AviaryJob::SetJobAttribute();
+                        if( AXIS2_FAILURE ==  input_val5->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::SetJobAttribute_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val5 =  skel->setJobAttribute(msgCtx ,input_val5);
+                    
+                        if ( NULL == ret_val5 )
+                        {
+                            
+                                delete input_val5;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val5->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val5;
+                                        
+                                            delete input_val5;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+             }
+            
+          AXIS2_LOG_ERROR(Environment::getEnv()->log, AXIS2_LOG_SI, "AviaryJobService service ERROR: invalid OM parameters in request\n");
+          return NULL;
+    }
+
+    OMElement* WSF_CALL
+    AviaryJobService::onFault(OMElement* omEle)
+	{
+		axiom_node_t *error_node = NULL;
+		axiom_element_t *error_ele = NULL;
+        axutil_error_codes_t error_code;
+        axiom_node_t *node = omEle->getAxiomNode();
+        error_code = (axutil_error_codes_t)Environment::getEnv()->error->error_number;
+
+        if(error_code <= AVIARYJOBSERVICESKELETON_ERROR_NONE ||
+                error_code >= AVIARYJOBSERVICESKELETON_ERROR_LAST )
+        {
+            error_ele = axiom_element_create(Environment::getEnv(), node, "fault", NULL,
+                            &error_node);
+            axiom_element_set_text(error_ele, Environment::getEnv(), "AviaryJobService|http://grid.redhat.com/aviary-job/ failed",
+                            error_node);
+        }
+        
+
+		return new OMElement(NULL,error_node);
+	}
+
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryJobService.h b/src/condor_contrib/aviary/src/AviaryJobService.h
new file mode 100644
index 0000000..7e0be8b
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobService.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+          #ifndef AVIARYJOBSERVICE_H
+          #define AVIARYJOBSERVICE_H
+
+#include <ServiceSkeleton.h>
+#include <stdio.h>
+#include <axis2_svc.h>
+
+using namespace wso2wsf;
+
+
+using namespace AviaryJob;
+
+
+
+#define WSF_SERVICE_SKEL_INIT(class_name) \
+AviaryJobServiceSkeleton* wsfGetAviaryJobServiceSkeleton(){ return new class_name(); }
+
+AviaryJobServiceSkeleton* wsfGetAviaryJobServiceSkeleton(); 
+
+
+
+        class AviaryJobService : public ServiceSkeleton
+        {
+            private:
+                AviaryJobServiceSkeleton *skel;
+
+            public:
+
+               union {
+                     
+               } fault;
+
+
+              WSF_EXTERN WSF_CALL AviaryJobService();
+
+              OMElement* WSF_CALL invoke(OMElement *message, MessageContext *msgCtx);
+
+              OMElement* WSF_CALL onFault(OMElement *message);
+
+              void WSF_CALL init();
+
+              ~AviaryJobService(); 
+      };
+
+
+
+#endif    //     AVIARYJOBSERVICE_H
+
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryJobServiceMacro.cpp b/src/condor_contrib/aviary/src/AviaryJobServiceMacro.cpp
new file mode 100644
index 0000000..76fc6cb
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobServiceMacro.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include "AviaryJobServiceSkeleton.h"
+#include "AviaryJobService.h"
+#include <ServiceSkeleton.h>
+#include <stdio.h>
+#include <axis2_svc.h>
+#include <Environment.h>
+
+using namespace wso2wsf;
+
+using namespace AviaryJob;
+
+
+
+/** Load the service into engine
+Note:- If you are extending from the Generated Skeleton class,you need is to change the argument provided to the
+macro to your derived class name.
+Example
+If your service is Calculator, you will have the business logic implementation class as CalculatorSkeleton.
+If the extended class is CalculatorSkeletonImpl, then you change the argument to the macro WSF_SERVICE_SKEL_INIT as
+WSF_SERVICE_SKEL_INIT(CalculatorSkeletonImpl). Also include the header file of the derived class, in this case CalculatorSkeletonImpl.h
+
+*/
+
+WSF_SERVICE_SKEL_INIT(AviaryJobServiceSkeleton)
+
+
+
diff --git a/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.cpp b/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.cpp
new file mode 100644
index 0000000..3b768d8
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.cpp
@@ -0,0 +1,361 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// the implementation class for AviaryJob methods
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_attributes.h"
+
+extern bool qmgmt_all_users_trusted;
+
+// local includes
+#include "AviaryJobServiceSkeleton.h"
+#include <AviaryJob_RemoveJob.h>
+#include <AviaryJob_RemoveJobResponse.h>
+#include <AviaryJob_ReleaseJob.h>
+#include <AviaryJob_ReleaseJobResponse.h>
+#include <AviaryJob_SubmitJob.h>
+#include <AviaryJob_SubmitJobResponse.h>
+#include <AviaryJob_HoldJob.h>
+#include <AviaryJob_HoldJobResponse.h>
+#include <AviaryJob_SetJobAttribute.h>
+#include <AviaryJob_SetJobAttributeResponse.h>
+#include "Codec.h"
+#include "SchedulerObject.h"
+#include "stl_string_utils.h"
+
+using namespace std;
+using namespace AviaryJob;
+using namespace AviaryCommon;
+using namespace aviary::codec;
+using namespace aviary::job;
+using namespace compat_classad;
+
+const char* BASIC_REQ_FORMAT = 
+"\
+( TARGET.Arch %s ) && \
+( %s ) && \
+( TARGET.Disk %s ) && \
+( ( TARGET.Memory * 1024 ) %s ) && \
+( TARGET.FileSystemDomain %s )";
+
+const char* BASIC_OS_FORMAT = "TARGET.OpSys == \"%s\"";
+const char* BASIC_WINOS_FORMAT = "TARGET.OpSys==\"WINNT51\" || TARGET.OpSys==\"WINNT52\" || TARGET.OpSys==\"WINNT60\"";
+const char* REQ_UNDEFINED = " =!= undefined ";
+const char* REQ_GTE_ZERO = " >= 0 ";
+
+//
+// Utility methods START
+//
+
+typedef vector<AviaryCommon::Attribute*> CommonAttributeCollection;
+
+void
+checkForSchedulerID(AviaryCommon::JobID* _jobId, string& _text)
+{
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+	if (!(_jobId->getPool() == schedulerObj->getPool()) ||
+		!(_jobId->getScheduler() == schedulerObj->getName())) {
+	_text = "WARNING: the pool and scheduler names of the requested jobid were empty or did not match this scheduler!";
+	}
+}
+
+void
+buildBasicRequirements(ResourceConstraintVectorType* _constraints, string& _reqs) {
+	// scan through these and build TARGET.<constraint> like string
+	string arch = REQ_UNDEFINED;
+	string opsys = REQ_UNDEFINED;
+	string disk = REQ_GTE_ZERO;
+	string memory = REQ_GTE_ZERO;
+	string filesystem = REQ_UNDEFINED;
+	for ( ResourceConstraintVectorType::const_iterator it = _constraints->begin(); it != _constraints->end();
+		 it++ ) {
+		ResourceConstraint* rc = *it;
+		ADBResourceConstraintTypeEnum rct = rc->getType()->getResourceConstraintTypeEnum();
+		switch (rct) {
+			case ResourceConstraintType_ARCH:
+				arch = " == \"" + rc->getValue() + "\"";
+				break;
+			case ResourceConstraintType_OS:
+				if (rc->getValue() == "WINDOWS") {
+					opsys = BASIC_WINOS_FORMAT;
+				}
+				else {
+					sprintf(opsys,BASIC_OS_FORMAT,rc->getValue().c_str());
+				}
+				break;
+            case ResourceConstraintType_DISK:
+				disk = " >= " + rc->getValue();
+				break;
+			case ResourceConstraintType_MEMORY:
+				memory = " >= " + rc->getValue();
+				break;
+            case ResourceConstraintType_FILESYSTEM:
+				filesystem = " == \"" + rc->getValue() + "\"";
+				break;
+			default:
+				dprintf(D_ALWAYS,"Ignoring unknown resource constraint submitted: %s:%s\n",
+						rc->getType()->getResourceConstraintType().c_str(),rc->getValue().c_str());
+		}
+	}
+	// order is important! see BASIC_REQ_FORMAT above
+	sprintf(_reqs, BASIC_REQ_FORMAT, arch.c_str(), opsys.c_str(), disk.c_str(), memory.c_str(), filesystem.c_str());
+}
+
+bool
+isBasicAttribute(const string& attr_name) {
+	return (
+		attr_name == ATTR_JOB_CMD ||
+		attr_name == ATTR_REQUIREMENTS ||
+		attr_name == ATTR_OWNER ||
+		attr_name == ATTR_JOB_IWD ||
+		attr_name == ATTR_JOB_ARGUMENTS1
+	);
+}
+
+void
+addExtraAttributes(const CommonAttributeCollection* extra_attrs, AttributeMapType& attr_map, bool override_basic) {
+	// add in the extras
+	for (CommonAttributeCollection::const_iterator i = extra_attrs->begin();i < extra_attrs->end();i++) {
+		AviaryCommon::Attribute* attr = *i;
+		const string& attr_key = attr->getName();
+
+		// Are we overriding our basic attributes?
+		if (!override_basic && isBasicAttribute(attr_key)) {
+			// exclude this attribute from the submission map
+			continue;
+		}
+
+		const char* attr_value = attr->getValue().c_str();
+		switch (attr->getType()->getAttributeTypeEnum()) {
+			case AviaryCommon::AttributeType_INTEGER:
+				attr_map[attr_key.c_str()] =
+					new AviaryAttribute(AviaryAttribute::INTEGER_TYPE,attr_value);
+			break;
+			case AviaryCommon::AttributeType_FLOAT:
+				attr_map[attr_key.c_str()] =
+					new AviaryAttribute(AviaryAttribute::FLOAT_TYPE,attr_value);
+			break;
+			case AviaryCommon::AttributeType_STRING:
+				attr_map[attr_key.c_str()] =
+					new AviaryAttribute(AviaryAttribute::STRING_TYPE,attr_value);
+			break;
+			case AviaryCommon::AttributeType_BOOLEAN:
+			case AviaryCommon::AttributeType_EXPRESSION:
+				attr_map[attr_key.c_str()] =
+					new AviaryAttribute(AviaryAttribute::EXPR_TYPE,attr_value);
+			break;
+			// probably shouldn't get here unless axis2 fails us
+			case AviaryCommon::AttributeType_ERROR:
+			case AviaryCommon::AttributeType_UNDEFINED:
+			default:
+				dprintf(D_FULLDEBUG,"Unknown type supplied for attribute '%s=%s'\n",
+						attr_key.c_str(),attr_value);
+		}
+	}
+}
+
+//
+// Utility methods END
+//
+
+//
+// Interface implementation START
+//
+
+
+AviaryJob::SubmitJobResponse*
+AviaryJobServiceSkeleton::submitJob(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::SubmitJob* _submitJob)
+{
+    AviaryJob::SubmitJobResponse* submitJobResponse = new AviaryJob::SubmitJobResponse();
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    AttributeMapType reqsMap, attrMap;
+	const char* submissionName = NULL;
+
+    // add the simple stuff first
+    attrMap[ATTR_JOB_CMD] = new AviaryAttribute(AviaryAttribute::STRING_TYPE, _submitJob->getCmd().c_str());
+    if (!(_submitJob->isArgsNil() || _submitJob->getArgs().empty())) {
+        attrMap[ATTR_JOB_ARGUMENTS1] = new AviaryAttribute(AviaryAttribute::STRING_TYPE, _submitJob->getArgs().c_str());
+    }
+    attrMap[ATTR_OWNER] = new AviaryAttribute(AviaryAttribute::STRING_TYPE, _submitJob->getOwner().c_str());
+    attrMap[ATTR_JOB_IWD] = new AviaryAttribute(AviaryAttribute::STRING_TYPE, _submitJob->getIwd().c_str());
+	if (!(_submitJob->isSubmission_nameNil() || _submitJob->getSubmission_name().empty())) {
+		submissionName = _submitJob->getSubmission_name().c_str();
+        attrMap[ATTR_JOB_SUBMISSION] = new AviaryAttribute(AviaryAttribute::STRING_TYPE,submissionName);
+    }
+
+    // build a requirements string and add to it
+    string reqBuilder;
+    if (!(_submitJob->isRequirementsNil() || _submitJob->getRequirements()->empty())) {
+        // build from resource constraints
+		buildBasicRequirements(_submitJob->getRequirements(), reqBuilder);
+    }
+    else {
+        // default
+        reqBuilder = "TRUE";
+    }
+    attrMap[ATTR_REQUIREMENTS] = new AviaryAttribute(AviaryAttribute::EXPR_TYPE, reqBuilder.c_str());
+
+    // need to add extras attrs also
+	// wso2 doesn't seem to make true nil checking easy
+	// might remove the Attributes element
+	CommonAttributeCollection* attrs = NULL;
+	if (!_submitJob->isExtraNil()) {
+		attrs = _submitJob->getExtra();
+		if (attrs && !attrs->empty()) {			
+			if (attrs && !attrs->empty()) {
+				addExtraAttributes(attrs, attrMap,_submitJob->getAllowOverrides());
+			}
+		}
+	}
+	
+    // invoke submit
+    string jobId, error;
+    // we need this since we don't have a trusted socket to the schedd,
+    // without it basically the schedd won't accept whatever we claim
+    // is Owner and the job will be pseudo-pruned
+    qmgmt_all_users_trusted = true;
+    if (!schedulerObj->submit(attrMap,jobId, error)) {
+        submitJobResponse->setStatus(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+    }
+    else {
+        string submissionId;
+        if (submissionName) {
+			submissionId = submissionName;
+		}
+		else {
+			submissionId = schedulerObj->getName();
+			submissionId.append("#");
+			submissionId.append(jobId);
+		}
+        submitJobResponse->setId(new AviaryCommon::JobID(
+				jobId,schedulerObj->getPool(),schedulerObj->getName(),
+				new AviaryCommon::SubmissionID(submissionId,_submitJob->getOwner().c_str())));
+        submitJobResponse->setStatus(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),""));
+    }
+    qmgmt_all_users_trusted = false;
+
+    return submitJobResponse;
+}
+
+
+// TODO: would be nice to template these next 3
+AviaryJob::HoldJobResponse*
+AviaryJobServiceSkeleton::holdJob(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::HoldJob* _holdJob)
+{
+	AviaryJob::HoldJobResponse* holdJobResponse = new HoldJobResponse;
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    string error;
+
+	AviaryCommon::JobID* jobId = _holdJob->getHoldJob()->getId();
+	string reason = _holdJob->getHoldJob()->getReason();
+	string cluster_proc = jobId->getJob();
+	ControlJobResponse* controlJobResponse = NULL;
+
+	checkForSchedulerID(jobId, error);
+	if (!schedulerObj->hold(cluster_proc,reason,error)) {
+		dprintf(D_FULLDEBUG, "SchedulerObject Hold failed: %s\n", error.c_str());
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+	}
+	else {
+		// in this case, error may hve been the result of the pool/schedd check
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),error));
+	}
+
+	holdJobResponse->setHoldJobResponse(controlJobResponse);
+    return holdJobResponse;
+}
+
+
+AviaryJob::ReleaseJobResponse*
+AviaryJobServiceSkeleton::releaseJob(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::ReleaseJob* _releaseJob)
+{
+	AviaryJob::ReleaseJobResponse* releaseJobResponse = new ReleaseJobResponse;
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    string error;
+
+	AviaryCommon::JobID* jobId = _releaseJob->getReleaseJob()->getId();
+	string reason = _releaseJob->getReleaseJob()->getReason();
+	string cluster_proc = jobId->getJob();
+	ControlJobResponse* controlJobResponse = NULL;
+
+	checkForSchedulerID(jobId, error);
+	if (!schedulerObj->release(cluster_proc,reason,error)) {
+		dprintf(D_FULLDEBUG, "SchedulerObject Release failed: %s\n", error.c_str());
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+	}
+	else {
+		// in this case, error may hve been the result of the pool/schedd check
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),error));
+	}
+
+	releaseJobResponse->setReleaseJobResponse(controlJobResponse);
+    return releaseJobResponse;
+}
+
+AviaryJob::RemoveJobResponse*
+AviaryJobServiceSkeleton::removeJob(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::RemoveJob* _removeJob)
+{
+	AviaryJob::RemoveJobResponse* removeJobResponse = new RemoveJobResponse;
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    string error;
+
+	AviaryCommon::JobID* jobId = _removeJob->getRemoveJob()->getId();
+	string reason = _removeJob->getRemoveJob()->getReason();
+	string cluster_proc = jobId->getJob();
+	ControlJobResponse* controlJobResponse = NULL;
+
+	checkForSchedulerID(jobId, error);
+	if (!schedulerObj->remove(cluster_proc,reason,error)) {
+		dprintf(D_FULLDEBUG, "SchedulerObject Remove failed: %s\n", error.c_str());
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+	}
+	else {
+		// in this case, error may hve been the result of the pool/schedd check
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),error));
+	}
+
+	removeJobResponse->setRemoveJobResponse(controlJobResponse);
+    return removeJobResponse;
+}
+
+AviaryJob::SetJobAttributeResponse*
+AviaryJobServiceSkeleton::setJobAttribute(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::SetJobAttribute* _setJobAttribute)
+{
+	AviaryJob::SetJobAttributeResponse* setAttrResponse = new SetJobAttributeResponse;
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    string error;
+
+	AviaryCommon::JobID* jobId = _setJobAttribute->getId();
+	AviaryCommon::Attribute* attr = _setJobAttribute->getAttribute();
+	string cluster_proc = jobId->getJob();
+	ControlJobResponse* controlJobResponse = NULL;
+
+	checkForSchedulerID(jobId, error);
+	if (!schedulerObj->setAttribute(cluster_proc,attr->getName(),attr->getValue(),error)) {
+		dprintf(D_FULLDEBUG, "SchedulerObject SetAttribute failed: %s\n", error.c_str());
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+	}
+	else {
+		// in this case, error may hve been the result of the pool/schedd check
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),error));
+	}
+
+	setAttrResponse->setSetJobAttributeResponse(controlJobResponse);
+    return setAttrResponse;
+}
diff --git a/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.h b/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.h
new file mode 100644
index 0000000..12bddc3
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.h
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVIARYJOBSERVICESKELETON_H
+#define AVIARYJOBSERVICESKELETON_H
+
+    #include <OMElement.h>
+    #include <MessageContext.h>
+   
+     #include <AviaryJob_RemoveJob.h>
+    
+     #include <AviaryJob_RemoveJobResponse.h>
+    
+     #include <AviaryJob_ReleaseJob.h>
+    
+     #include <AviaryJob_ReleaseJobResponse.h>
+    
+     #include <AviaryJob_SubmitJob.h>
+    
+     #include <AviaryJob_SubmitJobResponse.h>
+    
+     #include <AviaryJob_HoldJob.h>
+    
+     #include <AviaryJob_HoldJobResponse.h>
+    
+     #include <AviaryJob_SetJobAttribute.h>
+    
+     #include <AviaryJob_SetJobAttributeResponse.h>
+
+typedef std::vector<AviaryCommon::ResourceConstraint*> ResourceConstraintVectorType;
+    
+namespace AviaryJob {
+    
+
+   /** we have to reserve some error codes for adb and for custom messages */
+    #define AVIARYJOBSERVICESKELETON_ERROR_CODES_START (AXIS2_ERROR_LAST + 2500)
+
+    typedef enum
+    {
+        AVIARYJOBSERVICESKELETON_ERROR_NONE = AVIARYJOBSERVICESKELETON_ERROR_CODES_START,
+
+        AVIARYJOBSERVICESKELETON_ERROR_LAST
+    } AviaryJobServiceSkeleton_error_codes;
+
+    
+
+
+class AviaryJobServiceSkeleton
+{
+
+        public:
+            AviaryJobServiceSkeleton(){}
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "removeJob|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _removeJob of the AviaryJob::RemoveJob
+         *
+         * @return AviaryJob::RemoveJobResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::RemoveJobResponse* removeJob(wso2wsf::MessageContext *outCtx ,AviaryJob::RemoveJob* _removeJob);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "releaseJob|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _releaseJob of the AviaryJob::ReleaseJob
+         *
+         * @return AviaryJob::ReleaseJobResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::ReleaseJobResponse* releaseJob(wso2wsf::MessageContext *outCtx ,AviaryJob::ReleaseJob* _releaseJob);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "submitJob|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _submitJob of the AviaryJob::SubmitJob
+         *
+         * @return AviaryJob::SubmitJobResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::SubmitJobResponse* submitJob(wso2wsf::MessageContext *outCtx ,AviaryJob::SubmitJob* _submitJob);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "holdJob|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _holdJob of the AviaryJob::HoldJob
+         *
+         * @return AviaryJob::HoldJobResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::HoldJobResponse* holdJob(wso2wsf::MessageContext *outCtx ,AviaryJob::HoldJob* _holdJob);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "setJobAttribute|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _setJobAttribute of the AviaryJob::SetJobAttribute
+         *
+         * @return AviaryJob::SetJobAttributeResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::SetJobAttributeResponse* setJobAttribute(wso2wsf::MessageContext *outCtx ,AviaryJob::SetJobAttribute* _setJobAttribute);
+
+
+     
+
+
+
+};
+
+
+}
+
+
+
+        
+#endif // AVIARYJOBSERVICESKELETON_H
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryService.cpp b/src/condor_contrib/aviary/src/AviaryQueryService.cpp
new file mode 100644
index 0000000..242c4e0
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryService.cpp
@@ -0,0 +1,358 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+        #include "AviaryQueryServiceSkeleton.h"
+        #include "AviaryQueryService.h"  
+        #include <ServiceSkeleton.h>
+        #include <stdio.h>
+        #include <axis2_svc.h>
+        #include <Environment.h>
+        #include <axiom_soap.h>
+
+
+        using namespace wso2wsf;
+        
+        using namespace AviaryQuery;
+        
+
+        /** Load the service into axis2 engine */
+        WSF_SERVICE_INIT(AviaryQueryService)
+
+          
+         /**
+          * function to free any soap input headers
+          */
+         AviaryQueryService::AviaryQueryService()
+	{
+          skel = wsfGetAviaryQueryServiceSkeleton();
+    }
+
+
+	void WSF_CALL
+	AviaryQueryService::init()
+	{
+
+      return;
+	}
+
+
+	AviaryQueryService::~AviaryQueryService()
+	{
+    }
+
+
+     
+
+     
+
+
+
+
+	/*
+	 * This method invokes the right service method
+	 */
+	OMElement* WSF_CALL
+	AviaryQueryService::invoke(OMElement *omEle, MessageContext *msgCtx)
+	{
+         /* Using the function name, invoke the corresponding method
+          */
+
+          axis2_op_ctx_t *operation_ctx = NULL;
+          axis2_op_t *operation = NULL;
+          axutil_qname_t *op_qname = NULL;
+          axis2_char_t *op_name = NULL;
+          axis2_msg_ctx_t *in_msg_ctx = NULL;
+          
+          axiom_soap_envelope_t *req_soap_env = NULL;
+          axiom_soap_header_t *req_soap_header = NULL;
+          axiom_soap_envelope_t *res_soap_env = NULL;
+          axiom_soap_header_t *res_soap_header = NULL;
+
+          axiom_node_t *ret_node = NULL;
+          axiom_node_t *input_header = NULL;
+          axiom_node_t *output_header = NULL;
+          axiom_node_t *header_base_node = NULL;
+          axis2_msg_ctx_t *msg_ctx = NULL;
+          axiom_node_t* content_node = omEle->getAxiomNode();
+
+          
+            AviaryQuery::GetJobDataResponse* ret_val1;
+            AviaryQuery::GetJobData* input_val1;
+            
+            AviaryQuery::GetJobStatusResponse* ret_val2;
+            AviaryQuery::GetJobStatus* input_val2;
+            
+            AviaryQuery::GetSubmissionSummaryResponse* ret_val3;
+            AviaryQuery::GetSubmissionSummary* input_val3;
+            
+            AviaryQuery::GetJobDetailsResponse* ret_val4;
+            AviaryQuery::GetJobDetails* input_val4;
+
+			AviaryQuery::GetJobSummaryResponse* ret_val5;
+            AviaryQuery::GetJobSummary* input_val5;
+            
+            
+       
+          msg_ctx = msgCtx->getAxis2MessageContext();
+          operation_ctx = axis2_msg_ctx_get_op_ctx(msg_ctx, Environment::getEnv());
+          operation = axis2_op_ctx_get_op(operation_ctx, Environment::getEnv());
+          op_qname = (axutil_qname_t *)axis2_op_get_qname(operation, Environment::getEnv());
+          op_name = axutil_qname_get_localpart(op_qname, Environment::getEnv());
+
+          if (op_name)
+          {
+               
+
+                if ( axutil_strcmp(op_name, "getJobData") == 0 )
+                {
+
+                    
+                    input_val1 =
+                        
+                        new AviaryQuery::GetJobData();
+                        if( AXIS2_FAILURE ==  input_val1->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetJobData_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val1 =  skel->getJobData(msgCtx ,input_val1);
+                    
+                        if ( NULL == ret_val1 )
+                        {
+                            
+                                delete input_val1;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val1->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val1;
+                                        
+                                            delete input_val1;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "getJobStatus") == 0 )
+                {
+
+                    
+                    input_val2 =
+                        
+                        new AviaryQuery::GetJobStatus();
+                        if( AXIS2_FAILURE ==  input_val2->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetJobStatus_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val2 =  skel->getJobStatus(msgCtx ,input_val2);
+                    
+                        if ( NULL == ret_val2 )
+                        {
+                            
+                                delete input_val2;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val2->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val2;
+                                        
+                                            delete input_val2;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "getSubmissionSummary") == 0 )
+                {
+
+                    
+                    input_val3 =
+                        
+                        new AviaryQuery::GetSubmissionSummary();
+                        if( AXIS2_FAILURE ==  input_val3->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetSubmissionSummary_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val3 =  skel->getSubmissionSummary(msgCtx ,input_val3);
+                    
+                        if ( NULL == ret_val3 )
+                        {
+                            
+                                delete input_val3;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val3->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val3;
+                                        
+                                            delete input_val3;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "getJobDetails") == 0 )
+                {
+
+                    
+                    input_val4 =
+                        
+                        new AviaryQuery::GetJobDetails();
+                        if( AXIS2_FAILURE ==  input_val4->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetJobDetails_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val4 =  skel->getJobDetails(msgCtx ,input_val4);
+                    
+                        if ( NULL == ret_val4 )
+                        {
+                            
+                                delete input_val4;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val4->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val4;
+                                        
+                                            delete input_val4;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+
+
+                if ( axutil_strcmp(op_name, "getJobSummary") == 0 )
+                {
+
+
+                    input_val5 =
+
+                        new AviaryQuery::GetJobSummary();
+                        if( AXIS2_FAILURE ==  input_val5->deserialize(&content_node, NULL, false))
+                        {
+
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetJobSummary_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;
+                        }
+
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val5 =  skel->getJobSummary(msgCtx ,input_val5);
+
+                        if ( NULL == ret_val5 )
+                        {
+
+                                delete input_val5;
+
+                            return NULL;
+                        }
+                        ret_node =
+                                            ret_val5->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val5;
+
+                                            delete input_val5;
+
+
+                        return new OMElement(NULL,ret_node);
+
+
+                    /* since this has no output params it just returns NULL */
+
+
+                }
+
+             
+             }
+            
+          AXIS2_LOG_ERROR(Environment::getEnv()->log, AXIS2_LOG_SI, "AviaryQueryService service ERROR: invalid OM parameters in request\n");
+          return NULL;
+    }
+
+    OMElement* WSF_CALL
+    AviaryQueryService::onFault(OMElement* omEle)
+	{
+		axiom_node_t *error_node = NULL;
+		axiom_element_t *error_ele = NULL;
+        axutil_error_codes_t error_code;
+        axiom_node_t *node = omEle->getAxiomNode();
+        error_code = (axutil_error_codes_t)Environment::getEnv()->error->error_number;
+
+        if(error_code <= AVIARYQUERYSERVICESKELETON_ERROR_NONE ||
+                error_code >= AVIARYQUERYSERVICESKELETON_ERROR_LAST )
+        {
+            error_ele = axiom_element_create(Environment::getEnv(), node, "fault", NULL,
+                            &error_node);
+            axiom_element_set_text(error_ele, Environment::getEnv(), "AviaryQueryService|http://grid.redhat.com/aviary-query/ failed",
+                            error_node);
+        }
+        
+
+		return new OMElement(NULL,error_node);
+	}
+
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryService.h b/src/condor_contrib/aviary/src/AviaryQueryService.h
new file mode 100644
index 0000000..18be684
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryService.h
@@ -0,0 +1,67 @@
+
+
+          #ifndef AVIARYQUERYSERVICE_H
+          #define AVIARYQUERYSERVICE_H
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <ServiceSkeleton.h>
+#include <stdio.h>
+#include <axis2_svc.h>
+
+using namespace wso2wsf;
+
+
+using namespace AviaryQuery;
+
+
+
+#define WSF_SERVICE_SKEL_INIT(class_name) \
+AviaryQueryServiceSkeleton* wsfGetAviaryQueryServiceSkeleton(){ return new class_name(); }
+
+AviaryQueryServiceSkeleton* wsfGetAviaryQueryServiceSkeleton(); 
+
+
+
+        class AviaryQueryService : public ServiceSkeleton
+        {
+            private:
+                AviaryQueryServiceSkeleton *skel;
+
+            public:
+
+               union {
+                     
+               } fault;
+
+
+              WSF_EXTERN WSF_CALL AviaryQueryService();
+
+              OMElement* WSF_CALL invoke(OMElement *message, MessageContext *msgCtx);
+
+              OMElement* WSF_CALL onFault(OMElement *message);
+
+              void WSF_CALL init();
+
+              ~AviaryQueryService(); 
+      };
+
+
+
+#endif    //     AVIARYQUERYSERVICE_H
+
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryServiceMacro.cpp b/src/condor_contrib/aviary/src/AviaryQueryServiceMacro.cpp
new file mode 100644
index 0000000..d8cae4c
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryServiceMacro.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include "AviaryQueryServiceSkeleton.h"
+#include "AviaryQueryService.h"
+#include <ServiceSkeleton.h>
+#include <stdio.h>
+#include <axis2_svc.h>
+#include <Environment.h>
+
+using namespace wso2wsf;
+
+using namespace AviaryQuery;
+
+
+
+/** Load the service into engine
+Note:- If you are extending from the Generated Skeleton class,you need is to change the argument provided to the
+macro to your derived class name.
+Example
+If your service is Calculator, you will have the business logic implementation class as CalculatorSkeleton.
+If the extended class is CalculatorSkeletonImpl, then you change the argument to the macro WSF_SERVICE_SKEL_INIT as
+WSF_SERVICE_SKEL_INIT(CalculatorSkeletonImpl). Also include the header file of the derived class, in this case CalculatorSkeletonImpl.h
+
+*/
+
+WSF_SERVICE_SKEL_INIT(AviaryQueryServiceSkeleton)
+
+
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.cpp b/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.cpp
new file mode 100644
index 0000000..4d52d48
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.cpp
@@ -0,0 +1,475 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// the implementation methods for AviaryQueryService methods
+
+//local includes
+#include "Globals.h"
+#include "JobServerObject.h"
+#include "AviaryQueryServiceSkeleton.h"
+#include <AviaryQuery_GetJobData.h>
+#include <AviaryQuery_GetJobDataResponse.h>
+#include <AviaryQuery_GetJobStatus.h>
+#include <AviaryQuery_GetJobStatusResponse.h>
+#include <AviaryQuery_GetSubmissionSummary.h>
+#include <AviaryQuery_GetSubmissionSummaryResponse.h>
+#include <AviaryQuery_GetJobDetails.h>
+#include <AviaryQuery_GetJobDetailsResponse.h>
+#include <AviaryQuery_GetJobSummary.h>
+#include <AviaryQuery_GetJobSummaryResponse.h>
+#include <Axis2SoapProvider.h>
+
+// condor includes
+#include "stl_string_utils.h"
+#include "proc.h"
+#include "condor_attributes.h"
+
+// axis includes
+#include "axutil_date_time.h"
+
+using namespace std;
+using namespace AviaryQuery;
+using namespace AviaryCommon;
+using namespace aviary::query;
+
+struct cmpid {
+	bool operator()(const char *a, const char *b) const {
+		return strcmp(a, b) < 0;
+	}
+};
+
+typedef vector<JobID*> JobIdCollection;
+typedef vector<SubmissionID*> SubmissionIdCollection;
+typedef vector<JobStatus*> JobStatusCollection;
+typedef vector<JobDetails*> JobDetailsCollection;
+typedef vector<JobSummary*> JobSummaryCollection;
+typedef vector<SubmissionSummary*> SubmissionSummaryCollection;
+typedef set<const char*, cmpid> IdCollection;
+
+// TODO: singleton this...
+extern aviary::soap::Axis2SoapProvider* provider;
+
+//
+// Utility section START
+//
+
+// Any key that begins with the '0' char is either the
+// header or a cluster, i.e. not a job
+#define IS_JOB(key) ((key) && '0' != (key)[0])
+
+// NOTE #1: unfortunately the Axis2/C generated code is inconsistent in its
+// internal checking of nillable (i.e., minOccurs=0) elements
+// so we have to use default ctors and build the element object using setters
+// otherwise segvs await us in generated code
+
+// NOTE #2: using template functions since WSO2 codegen won't give us
+// XSD extension->C++ inheritance
+template <class JobBase>
+void createGoodJobResponse(JobBase& jb, const char* job_id) {
+	JobServerObject* jso = JobServerObject::getInstance();
+	JobID* jid = new JobID;
+	jid->setJob(job_id);
+	jid->setPool(jso->getPool());
+	jid->setScheduler(jso->getName());
+	jb.setId(jid);
+	Status* js = new Status;
+	js->setCode(new StatusCodeType("OK"));
+	jb.setStatus(js);
+}
+
+template <class JobBase>
+void createBadJobResponse(JobBase& jb, const char* job_id, const AviaryStatus& error) {
+	JobID* jid = new JobID;
+	jid->setJob(job_id);
+	jb.setId(jid);
+	StatusCodeType* jst = new StatusCodeType;
+	jst->setStatusCodeTypeEnum(ADBStatusCodeTypeEnum(error.type));
+	Status* js = new Status(jst,error.text);
+	jb.setStatus(js);
+}
+
+// unfortunately no convenience functions from WS02 for dateTime
+axutil_date_time_t* encodeDateTime(const time_t* _time) {
+	struct tm _tm;
+
+	// need the re-entrant version because axutil_date_time_create
+	// calls time() again and overwrites static tm
+	localtime_r(_time,&_tm);
+	// get our Axis2 env for the allocator
+	const axutil_env_t* _env = provider->getEnv();
+
+	axutil_date_time_t* _value = NULL;
+	_value = axutil_date_time_create(_env);
+
+    if (!_value)
+    {
+        AXIS2_ERROR_SET(_env->error, AXIS2_ERROR_NO_MEMORY, AXIS2_FAILURE);
+        AXIS2_LOG_ERROR(_env->log, AXIS2_LOG_SI, "Out of memory");
+        return NULL;
+    }
+
+	// play their game with adjusting the year and month offset
+	axutil_date_time_set_date_time(_value,_env,
+								   _tm.tm_year+1900,
+								   _tm.tm_mon+1,
+								   _tm.tm_mday,
+								   _tm.tm_hour,
+								   _tm.tm_min,
+								   _tm.tm_sec,
+								   0);
+	return _value;
+};
+
+void mapFieldsToSummary(const JobSummaryFields& fields, JobSummary* _summary) {
+
+	// JobID should already been in our summary
+	SubmissionID* sid = new SubmissionID;
+	sid->setName(fields.submission_id);
+	sid->setOwner(fields.owner);
+	_summary->getId()->setSubmission(sid);
+	// do date/time conversion
+	_summary->setQueued(encodeDateTime((const time_t*)&fields.queued));
+	_summary->setLast_update(encodeDateTime((const time_t*)&fields.last_update));
+	JobStatusType* jst = new JobStatusType;
+	jst->setJobStatusType(getJobStatusString(fields.status));
+	_summary->setJob_status(jst);
+	_summary->setCmd(fields.cmd);
+	if (!fields.args1.empty()) {
+		_summary->setArgs1(fields.args1);
+	}
+	if (!fields.args2.empty()) {
+		_summary->setArgs2(fields.args2);
+	}
+	if (!fields.hold_reason.empty()) {
+		_summary->setHeld(fields.hold_reason);
+	}
+	if (!fields.release_reason.empty()) {
+		_summary->setReleased(fields.release_reason);
+	}
+	if (!fields.remove_reason.empty()) {
+		_summary->setRemoved(fields.remove_reason);
+	}
+}
+
+void mapToXsdAttributes(const aviary::codec::AttributeMapType& _map, AviaryCommon::Attributes* _attrs) {
+	for (AttributeMapIterator i = _map.begin(); _map.end() != i; i++) {
+		AviaryAttribute* codec_attr = (AviaryAttribute*)(*i).second;
+		AviaryCommon::Attribute* attr = new AviaryCommon::Attribute;
+		attr->setName((*i).first);
+		AviaryCommon::AttributeType* attr_type = new AviaryCommon::AttributeType;
+		switch (codec_attr->getType()) {
+			case AviaryAttribute::INTEGER_TYPE:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_INTEGER);
+				break;
+			case AviaryAttribute::FLOAT_TYPE:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_FLOAT);
+				break;
+			case AviaryAttribute::STRING_TYPE:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_STRING);
+				break;
+			case AviaryAttribute::EXPR_TYPE:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_EXPRESSION);
+				break;
+			default:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_UNDEFINED);
+		}
+		attr->setType(attr_type);
+		attr->setValue(codec_attr->getValue());
+		_attrs->addAttrs(attr);
+	}
+}
+
+//
+// Utility section END
+//
+
+//
+// Interface implementation START
+//
+GetSubmissionSummaryResponse* AviaryQueryServiceSkeleton::getSubmissionSummary(wso2wsf::MessageContext* /*outCtx*/
+	,GetSubmissionSummary* _getSubmissionSummary)
+{
+	GetSubmissionSummaryResponse* getSummaryResponse = new GetSubmissionSummaryResponse;
+
+	SubmissionCollectionType::const_iterator element = g_submissions.begin();
+	SubmissionSummaryCollection* submissions = new SubmissionSummaryCollection;
+
+	SubmissionCollectionType sub_map;
+
+	if (_getSubmissionSummary->isIdsNil() || _getSubmissionSummary->getIds()->size() == 0) {
+		// no ids supplied...they get them all
+		for (SubmissionCollectionType::iterator i = g_submissions.begin(); g_submissions.end() != i; i++) {
+			sub_map[(*i).first] = (*i).second;
+		}
+	}
+	else {
+		// fast track...client has supplied ids to scan
+		SubmissionIdCollection* id_list = _getSubmissionSummary->getIds();
+		for (SubmissionIdCollection::iterator sic_it = id_list->begin(); id_list->end() != sic_it; sic_it++) {
+			const char* sid_str = (*sic_it)->getName().c_str();
+			SubmissionCollectionType::iterator sct_it = g_submissions.find(sid_str);
+			if (sct_it != g_submissions.end()) {
+				sub_map[(*sct_it).first] = (*sct_it).second;
+			}
+			else {
+				// mark this as not matched when returning our results
+				sub_map[(*sct_it).first] = NULL;
+			}
+		}
+	}
+
+	for (SubmissionCollectionType::iterator i = sub_map.begin(); sub_map.end() != i; i++) {
+		SubmissionSummary* summary = new SubmissionSummary;
+		SubmissionObject *submission = (*i).second;
+
+		if (submission) {
+			SubmissionID* sid = new SubmissionID;
+			sid->setName(submission->getName());
+			sid->setOwner(submission->getOwner());
+			summary->setId(sid);
+			summary->setCompleted(submission->getCompleted().size());
+			summary->setHeld(submission->getHeld().size());
+			summary->setIdle(submission->getIdle().size());
+			summary->setRemoved(submission->getRemoved().size());
+			summary->setRunning(submission->getRunning().size());
+			Status* ss = new Status;
+			ss->setCode(new StatusCodeType("OK"));
+			summary->setStatus(ss);
+
+			if (!_getSubmissionSummary->isIncludeJobSummariesNil() && _getSubmissionSummary->getIncludeJobSummaries()) {
+				// client wants the job summaries also
+				JobSummaryPairCollection jobs;
+				submission->getJobSummaries(jobs);
+				for (JobSummaryPairCollection::const_iterator it = jobs.begin(); jobs.end() != it; it++) {
+					JobSummary* js = new JobSummary;
+					createGoodJobResponse<JobSummary>(*js,(*it).first);
+					mapFieldsToSummary(*((*it).second),js);
+					summary->addJobs(js);
+				}
+			}
+
+		}
+		else {
+			SubmissionID* sid = new SubmissionID;
+			summary->setId(sid);
+			StatusCodeType* sst = new StatusCodeType;
+			sst->setStatusCodeType("NO_MATCH");
+			Status* ss = new Status(sst,"Unable to locate submission");
+			summary->setStatus(ss);
+		}
+		submissions->push_back(summary);
+	}
+
+	getSummaryResponse->setSubmissions(submissions);
+
+    return getSummaryResponse;
+}
+
+GetJobStatusResponse* AviaryQueryServiceSkeleton::getJobStatus(wso2wsf::MessageContext* /*outCtx*/
+	,GetJobStatus* _getJobStatus)
+{
+	GetJobStatusResponse* jobStatusResponse = new GetJobStatusResponse;
+	JobServerObject* jso = JobServerObject::getInstance();
+	JobStatusCollection* job_results = new JobStatusCollection;
+
+	IdCollection id_set;
+
+	if (_getJobStatus->isIdsNil() || _getJobStatus->getIds()->size() == 0) {
+		// no ids supplied...they get them all
+		for (JobCollectionType::iterator i = g_jobs.begin(); g_jobs.end() != i; i++) {
+			const char* job_id = (*i).first;
+			if (IS_JOB(job_id)) {
+				id_set.insert(job_id);
+			}
+		}
+	}
+	else {
+		// fast track...client has supplied ids to scan
+		JobIdCollection* id_list = _getJobStatus->getIds();
+		for (JobIdCollection::iterator i = id_list->begin(); id_list->end() != i; i++) {
+			id_set.insert((*i)->getJob().c_str());
+		}
+	}
+
+	for (IdCollection::const_iterator i = id_set.begin(); id_set.end() != i; i++) {
+		JobStatus* js = new JobStatus;
+		const char* job = *i;
+		AviaryStatus status;
+		int job_status = JOB_STATUS_MIN;
+		if (jso->getStatus(job,job_status,status)) {
+			createGoodJobResponse<JobStatus>(*js,job);
+			JobStatusType* jst = new JobStatusType;
+			jst->setJobStatusType(getJobStatusString(job_status));
+			js->setJob_status(jst);
+		}
+		else {
+			// problem...report to client
+			createBadJobResponse<JobStatus>(*js,job,status);
+		}
+		job_results->push_back(js);
+	}
+
+	jobStatusResponse->setJobs(job_results);
+
+    return jobStatusResponse;
+}
+
+GetJobSummaryResponse* AviaryQueryServiceSkeleton::getJobSummary(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobSummary* _getJobSummary)
+{
+	GetJobSummaryResponse* jobSummaryResponse = new GetJobSummaryResponse;
+	JobServerObject* jso = JobServerObject::getInstance();
+	JobSummaryCollection* job_results = new JobSummaryCollection;
+	
+	IdCollection id_set;
+
+	if (_getJobSummary->isIdsNil() || _getJobSummary->getIds()->size() == 0) {
+		// no ids supplied...they get them all
+		for (JobCollectionType::iterator i = g_jobs.begin(); g_jobs.end() != i; i++) {
+			const char* job_id = (*i).first;
+			if (IS_JOB(job_id)) {
+				id_set.insert(job_id);
+			}
+		}
+	}
+	else {
+		// fast track...client has supplied ids to scan
+		JobIdCollection* id_list = _getJobSummary->getIds();
+		for (JobIdCollection::iterator i = id_list->begin(); id_list->end() != i; i++) {
+			id_set.insert((*i)->getJob().c_str());
+		}
+	}
+	
+	for (IdCollection::const_iterator i = id_set.begin(); id_set.end() != i; i++) {
+		JobSummary* js = new JobSummary;
+		const char* job = *i;
+		JobSummaryFields jsf;
+		AviaryStatus status;
+		if (jso->getSummary(job,jsf,status)) {
+			createGoodJobResponse<JobSummary>(*js,job);
+			mapFieldsToSummary(jsf,js);
+		}
+		else {
+			// problem...report to client
+			createBadJobResponse<JobSummary>(*js, job, status);
+		}
+		job_results->push_back(js);
+	}
+
+	jobSummaryResponse->setJobs(job_results);
+
+    return jobSummaryResponse;
+}
+
+GetJobDetailsResponse* AviaryQueryServiceSkeleton::getJobDetails(wso2wsf::MessageContext* /* outCtx*/
+	,GetJobDetails* _getJobDetails)
+{
+	GetJobDetailsResponse* jobDetailsResponse = new GetJobDetailsResponse;
+	JobServerObject* jso = JobServerObject::getInstance();
+	JobDetailsCollection* job_results = new JobDetailsCollection;
+
+	IdCollection id_set;
+
+	if (_getJobDetails->isIdsNil() || _getJobDetails->getIds()->size() == 0) {
+		// no ids supplied...they get them all
+		for (JobCollectionType::iterator i = g_jobs.begin(); g_jobs.end() != i; i++) {
+			const char* job_id = (*i).first;
+			if (IS_JOB(job_id)) {
+				id_set.insert(job_id);
+			}
+		}
+	}
+	else {
+		// fast track...client has supplied ids to scan
+		JobIdCollection* id_list = _getJobDetails->getIds();
+		for (JobIdCollection::iterator i = id_list->begin(); id_list->end() != i; i++) {
+			id_set.insert((*i)->getJob().c_str());
+		}
+	}
+
+	for (IdCollection::const_iterator i = id_set.begin(); id_set.end() != i; i++) {
+		JobDetails* jd = new JobDetails;
+		const char* job = *i;
+		aviary::codec::AttributeMapType attr_map;
+		AviaryStatus status;
+		if (jso->getJobAd(job,attr_map,status)) {
+			createGoodJobResponse<JobDetails>(*jd,job);
+			// load attributes
+			AviaryCommon::Attributes* attrs = new AviaryCommon::Attributes;
+			mapToXsdAttributes(attr_map,attrs);
+			jd->setDetails(attrs);
+		}
+		else {
+			// problem...report to client
+			createBadJobResponse<JobDetails>(*jd, job, status);
+		}
+		job_results->push_back(jd);
+	}
+
+	jobDetailsResponse->setJobs(job_results);
+
+    return jobDetailsResponse;
+}
+
+// NOTE: getJobData is the rare case (?) where someone wants to pull the job output
+// thus, we don't batch this - just one at a time
+GetJobDataResponse* AviaryQueryServiceSkeleton::getJobData(wso2wsf::MessageContext* /* outCtx */
+	,GetJobData* _getJobData)
+{
+    GetJobDataResponse* jobDataResponse = new  GetJobDataResponse;
+	JobServerObject* jso = JobServerObject::getInstance();
+
+	const char* job = _getJobData->getData()->getId()->getJob().c_str();
+	AviaryCommon::JobDataType* jdt = _getJobData->getData()->getType();
+	ADBJobDataTypeEnum file_type = jdt->getJobDataTypeEnum();
+	AviaryStatus status;
+	status.type = AviaryStatus::FAIL;
+	string fname, content;
+	int fsize;
+	if (jso->fetchJobData(job,UserFileType(file_type),fname,_getJobData->getMax_bytes(),_getJobData->getFrom_end(),fsize,content,status)) {
+		JobID* jid = new JobID;
+		jid->setJob(job);
+		jid->setPool(jso->getPool());
+		jid->setScheduler(jso->getName());
+		JobData* jd = new JobData;
+		jd->setId(jid);
+		jd->setType(jdt);
+		jobDataResponse->setData(jd);
+		Status* js = new Status;
+		js->setCode(new StatusCodeType("OK"));
+		jobDataResponse->setStatus(js);
+
+		// load requested file data
+		jobDataResponse->setContent(content);
+		jobDataResponse->setFile_name(fname);
+		jobDataResponse->setFile_size(fsize);
+	}
+	else {
+		// problem...report to client
+		JobID* jid = new JobID;
+		jid->setJob(job);
+		JobData* jd = new JobData;
+		jd->setId(jid);
+		jd->setType(jdt);
+		jobDataResponse->setData(jd);
+		StatusCodeType* jst = new StatusCodeType;
+		jst->setStatusCodeTypeEnum(ADBStatusCodeTypeEnum(status.type));
+		Status* js = new Status(jst,status.text);
+		jobDataResponse->setStatus(js);
+	}
+
+    return jobDataResponse;
+}
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.h b/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.h
new file mode 100644
index 0000000..e400201
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVIARYQUERYSERVICESKELETON_H
+#define AVIARYQUERYSERVICESKELETON_H
+
+    #include <OMElement.h>
+    #include <MessageContext.h>
+   
+     #include <AviaryQuery_GetJobData.h>
+    
+     #include <AviaryQuery_GetJobDataResponse.h>
+    
+     #include <AviaryQuery_GetJobStatus.h>
+    
+     #include <AviaryQuery_GetJobStatusResponse.h>
+    
+     #include <AviaryQuery_GetSubmissionSummary.h>
+    
+     #include <AviaryQuery_GetSubmissionSummaryResponse.h>
+    
+     #include <AviaryQuery_GetJobDetails.h>
+    
+     #include <AviaryQuery_GetJobDetailsResponse.h>
+
+     #include <AviaryQuery_GetJobSummary.h>
+
+     #include <AviaryQuery_GetJobSummaryResponse.h>
+    
+    
+namespace AviaryQuery {
+    
+
+   /** we have to reserve some error codes for adb and for custom messages */
+    #define AVIARYQUERYSERVICESKELETON_ERROR_CODES_START (AXIS2_ERROR_LAST + 2500)
+
+    typedef enum
+    {
+        AVIARYQUERYSERVICESKELETON_ERROR_NONE = AVIARYQUERYSERVICESKELETON_ERROR_CODES_START,
+
+        AVIARYQUERYSERVICESKELETON_ERROR_LAST
+    } AviaryQueryServiceSkeleton_error_codes;
+
+    
+
+
+class AviaryQueryServiceSkeleton
+{
+        public:
+            AviaryQueryServiceSkeleton(){}
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "getJobData|http://grid.redhat.com/aviary-query/" operation.
+         * 
+         * @param _getJobData of the AviaryQuery::GetJobData
+         *
+         * @return AviaryQuery::GetJobDataResponse*
+         */
+        
+
+         virtual 
+        AviaryQuery::GetJobDataResponse* getJobData(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobData* _getJobData);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "getJobStatus|http://grid.redhat.com/aviary-query/" operation.
+         * 
+         * @param _getJobStatus of the AviaryQuery::GetJobStatus
+         *
+         * @return AviaryQuery::GetJobStatusResponse*
+         */
+        
+
+         virtual 
+        AviaryQuery::GetJobStatusResponse* getJobStatus(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobStatus* _getJobStatus);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "getSubmissionSummary|http://grid.redhat.com/aviary-query/" operation.
+         * 
+         * @param _getSubmissionSummary of the AviaryQuery::GetSubmissionSummary
+         *
+         * @return AviaryQuery::GetSubmissionSummaryResponse*
+         */
+        
+
+         virtual 
+        AviaryQuery::GetSubmissionSummaryResponse* getSubmissionSummary(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetSubmissionSummary* _getSubmissionSummary);
+
+
+     
+
+
+
+
+		 
+
+        /**
+         * Auto generated method declaration
+         * for "getJobDetails|http://grid.redhat.com/aviary-query/" operation.
+         * 
+         * @param _getJobDetails of the AviaryQuery::GetJobDetails
+         *
+         * @return AviaryQuery::GetJobDetailsResponse*
+         */
+        
+
+         virtual 
+        AviaryQuery::GetJobDetailsResponse* getJobDetails(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobDetails* _getJobDetails);
+
+
+         /**
+         * Auto generated method declaration
+         * for "getJobSummary|http://grid.redhat.com/aviary-query/" operation.
+         *
+         * @param _getJobSummary of the AviaryQuery::GetJobSummary
+         *
+         * @return AviaryQuery::GetJobSummaryResponse*
+         */
+
+
+         virtual
+        AviaryQuery::GetJobSummaryResponse* getJobSummary(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobSummary* _getJobSummary);
+
+
+};
+
+
+}
+
+
+
+        
+#endif // AVIARYQUERYSERVICESKELETON_H
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryScheddPlugin.cpp b/src/condor_contrib/aviary/src/AviaryScheddPlugin.cpp
new file mode 100644
index 0000000..ec1ceaf
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryScheddPlugin.cpp
@@ -0,0 +1,366 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_qmgr.h"
+#include "condor_config.h"
+
+// local includes
+#include "AviaryScheddPlugin.h"
+#include "Axis2SoapProvider.h"
+#include "SchedulerObject.h"
+
+// Global from the condor_schedd, it's name
+extern char * Name;
+
+// Any key that begins with the '0' char is either the
+// header or a cluster, i.e. not a job
+#define IS_JOB(key) ((key) && '0' != (key)[0])
+
+using namespace std;
+using namespace aviary::job;
+using namespace aviary::soap;
+
+// global SchedulerObject
+// TODO: convert to singleton
+Axis2SoapProvider* provider = NULL;
+SchedulerObject* schedulerObj = NULL;
+
+void
+AviaryScheddPlugin::earlyInitialize()
+{
+
+    // Since this plugin is registered with multiple
+    // PluginManagers it may be initialized more than once,
+    // and we don't want that
+	static bool skip = false;
+	if (skip) return; skip = true;
+
+	// config then env for our all-important axis2 repo dir
+    const char* log_file = "./aviary_job.axis2.log";
+	string repo_path;
+	char *tmp = NULL;
+	if (tmp = param("WSFCPP_HOME")) {
+		repo_path = tmp;
+		free(tmp);
+	}
+	else if (tmp = getenv("WSFCPP_HOME")) {
+		repo_path = tmp;
+	}
+	else {
+		EXCEPT("No WSFCPP_HOME in config or env");
+	}
+
+	int port = param_integer("HTTP_PORT",9090);
+	int level = param_integer("AXIS2_DEBUG_LEVEL",AXIS2_LOG_LEVEL_CRITICAL);
+
+    // init transport here
+    provider = new Axis2SoapProvider(level,log_file,repo_path.c_str());
+    string axis_error;
+    if (!provider->init(port,AXIS2_HTTP_DEFAULT_SO_TIMEOUT,axis_error)) {
+		dprintf(D_ALWAYS, "%s\n",axis_error.c_str());
+        EXCEPT("Failed to initialize Axis2SoapProvider");
+    }
+
+	schedulerObj = SchedulerObject::getInstance();
+
+	dirtyJobs = new DirtyJobsType();
+
+	isHandlerRegistered = false;
+
+	ReliSock *sock = new ReliSock;
+	if (!sock) {
+		EXCEPT("Failed to allocate transport socket");
+	}
+	if (!sock->assign(provider->getHttpListenerSocket())) {
+		EXCEPT("Failed to bind transport socket");
+	}
+	int index;
+	if (-1 == (index =
+			   daemonCore->Register_Socket((Stream *) sock,
+										   "Aviary Method Socket",
+										   (SocketHandlercpp) ( &AviaryScheddPlugin::HandleTransportSocket ),
+										   "Handler for Aviary Methods.",
+										   this))) {
+		EXCEPT("Failed to register transport socket");
+	}
+
+	dprintf(D_ALWAYS,"Axis2 listener on http port: %d\n",port);
+
+	m_initialized = false;
+}
+
+void
+AviaryScheddPlugin::initialize()
+{
+		// Since this plugin is registered with multiple
+		// PluginManagers it may be initialized more than once,
+		// and we don't want that
+	static bool skip = false;
+	if (skip) return; skip = true;
+
+		// WalkJobQueue(int (*func)(ClassAd *))
+	ClassAd *ad = GetNextJob(1);
+	while (ad != NULL) {
+		MyString key;
+		PROC_ID id;
+		int value;
+
+		if (!ad->LookupInteger(ATTR_CLUSTER_ID, id.cluster)) {
+			EXCEPT("%s on job is missing or not an integer", ATTR_CLUSTER_ID);
+		}
+		if (!ad->LookupInteger(ATTR_PROC_ID, id.proc)) {
+			EXCEPT("%s on job is missing or not an integer", ATTR_PROC_ID);
+		}
+		if (!ad->LookupInteger(ATTR_JOB_STATUS, value)) {
+			EXCEPT("%s on job is missing or not an integer", ATTR_JOB_STATUS);
+		}
+
+		key.sprintf("%d.%d", id.cluster, id.proc);
+
+		processJob(key.Value(), ATTR_JOB_STATUS, value);
+
+		FreeJobAd(ad);
+		ad = GetNextJob(0);
+	}
+ 
+	m_initialized = true;
+}
+
+
+void
+AviaryScheddPlugin::shutdown()
+{
+		// Since this plugin is registered with multiple
+		// PluginManagers (eg, shadow) it may be shutdown
+		// more than once, and we don't want that
+	static bool skip = false;
+	if (skip) return; skip = true;
+
+	dprintf(D_FULLDEBUG, "AviaryScheddPlugin: shutting down...\n");
+
+	if (schedulerObj) {
+		delete schedulerObj;
+		schedulerObj = NULL;
+	}
+}
+
+
+void
+AviaryScheddPlugin::update(int cmd, const ClassAd *ad)
+{
+	MyString hashKey;
+
+	switch (cmd) {
+	case UPDATE_SCHEDD_AD:
+		dprintf(D_FULLDEBUG, "Received UPDATE_SCHEDD_AD\n");
+		schedulerObj->update(*ad);
+		break;
+	default:
+		dprintf(D_FULLDEBUG, "Unsupported command: %s\n",
+				getCollectorCommandString(cmd));
+	}
+}
+
+
+void
+AviaryScheddPlugin::archive(const ClassAd */*ad*/) { };
+
+
+void
+AviaryScheddPlugin::newClassAd(const char */*key*/) { };
+
+
+void
+AviaryScheddPlugin::setAttribute(const char *key,
+							   const char *name,
+							   const char *value)
+{
+	if (!m_initialized) return;
+
+//	dprintf(D_FULLDEBUG, "setAttribute: %s[%s] = %s\n", key, name, value);
+
+	markDirty(key, name, value);
+}
+
+
+void
+AviaryScheddPlugin::destroyClassAd(const char *_key)
+{
+	if (!m_initialized) return;
+
+//	dprintf(D_FULLDEBUG, "destroyClassAd: %s\n", key);
+
+	if (!IS_JOB(_key)) return;
+
+		// If we wait to process the deletion the job ad will be gone
+		// and we won't be able to lookup the Submission. So, we must
+		// process the job immediately, but that also means we need to
+		// process all pending changes for the job as well.
+	DirtyJobsType::iterator entry = dirtyJobs->begin();
+	while (dirtyJobs->end() != entry) {
+		string key = (*entry).first;
+		string name = (*entry).second.first;
+		int value = (*entry).second.second;
+
+		if (key == _key) {
+			processJob(key.c_str(), name.c_str(), value);
+
+				// No need to process this entry again later
+			entry = dirtyJobs->erase(entry);
+		} else {
+			entry++;
+		}
+	}
+}
+
+
+void
+AviaryScheddPlugin::deleteAttribute(const char */*key*/,
+								  const char */*name*/) { }
+
+int
+AviaryScheddPlugin::HandleTransportSocket(Stream *)
+{
+    // TODO: respond to a transport callback here?
+    string provider_error;
+    if (!provider->processHttpRequest(provider_error)) {
+        dprintf (D_ALWAYS,"Error processing request: %s\n",provider_error.c_str());
+    }
+
+    return KEEP_STREAM;
+}
+
+void
+AviaryScheddPlugin::processDirtyJobs()
+{
+	BeginTransaction();
+
+	while (!dirtyJobs->empty()) {
+		DirtyJobEntry entry = dirtyJobs->front(); dirtyJobs->pop_front();
+		string key = entry.first;
+		string name = entry.second.first;
+		int value = entry.second.second;
+
+		processJob(key.c_str(), name.c_str(), value);
+	}
+
+	CommitTransaction();
+
+	isHandlerRegistered = false;
+}
+
+
+bool
+AviaryScheddPlugin::processJob(const char *key,
+							 const char *name,
+							 int value)
+{
+	PROC_ID id;
+	ClassAd *jobAd;
+
+		// Skip any key that doesn't point to an actual job
+	if (!IS_JOB(key)) return false;
+
+//	dprintf(D_FULLDEBUG, "Processing: %s\n", key);
+
+	id = getProcByString(key);
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "Failed to parse key: %s - skipping\n", key);
+		return false;
+	}
+
+		// Lookup the job ad assocaited with the key. If it is not
+		// present, skip the key
+	if (NULL == (jobAd = ::GetJobAd(id.cluster, id.proc, false))) {
+		dprintf(D_ALWAYS,
+				"NOTICE: Failed to lookup ad for %s - maybe deleted\n",
+				key);
+		return false;
+	}
+
+		// Store two pieces of information in the Job, 1. the
+		// Submission's name, 2. the Submission's id
+		//
+		// Submissions indexed on their name, the id is present
+		// for reconstruction of the Submission
+
+		// XXX: Use the jobAd instead of GetAttribute below, gets us $$() expansion
+
+	MyString submissionName;
+	if (GetAttributeString(id.cluster, id.proc,
+						   ATTR_JOB_SUBMISSION,
+						   submissionName) < 0) {
+			// Provide a default name for the Submission
+
+			// If we are a DAG node, we default to our DAG group
+		PROC_ID dagman;
+		if (GetAttributeInt(id.cluster, id.proc,
+							ATTR_DAGMAN_JOB_ID,
+							&dagman.cluster) >= 0) {
+			dagman.proc = 0;
+
+			if (GetAttributeString(dagman.cluster, dagman.proc,
+								   ATTR_JOB_SUBMISSION,
+								   submissionName) < 0) {
+					// This can only happen if the DAGMan job was
+					// removed, and we remained, which should not
+					// happen, but could. In such a case we are
+					// orphaned, and we'll make a guess. We'll be
+					// wrong if the DAGMan job didn't use the
+					// default, but it is better to be wrong than
+					// to fail entirely, which is the alternative.
+				submissionName.sprintf("%s#%d", Name, dagman.cluster);
+			}
+		} else {
+			submissionName.sprintf("%s#%d", Name, id.cluster);
+		}
+
+		MyString tmp;
+		tmp += "\"";
+		tmp += submissionName;
+		tmp += "\"";
+		SetAttribute(id.cluster, id.proc,
+					 ATTR_JOB_SUBMISSION,
+					 tmp.Value());
+	}
+}
+
+void
+AviaryScheddPlugin::markDirty(const char *key,
+							const char *name,
+							const char *value)
+{
+	if (!IS_JOB(key)) return;
+	if (!(strcasecmp(name, ATTR_JOB_STATUS) == 0 ||
+		  strcasecmp(name, ATTR_LAST_JOB_STATUS) == 0)) return;
+
+	DirtyJobStatus status(name, atoi(value));
+	DirtyJobEntry entry(key, status);
+	dirtyJobs->push_back(DirtyJobEntry(key, DirtyJobStatus(name, atoi(value))));
+
+	if (!isHandlerRegistered) {
+			// To test destroyClassAd, set the timeout here to a few
+			// seconds, submit a job and immediately delete it.
+		daemonCore->Register_Timer(0,
+								   (TimerHandlercpp)
+								   &AviaryScheddPlugin::processDirtyJobs,
+								   "Process Dirty",
+								   this);
+		isHandlerRegistered = true;
+	}
+}
diff --git a/src/condor_contrib/aviary/src/AviaryScheddPlugin.h b/src/condor_contrib/aviary/src/AviaryScheddPlugin.h
new file mode 100644
index 0000000..ad247ac
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryScheddPlugin.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AVIARYSCHEDDPLUGIN_H
+#define _AVIARYSCHEDDPLUGIN_H
+
+// c++ includes
+#include <list>
+#include <string>
+
+// condor includes
+#include "condor_qmgr.h"
+#include "../condor_schedd.V6/ScheddPlugin.h"
+#include "ClassAdLogPlugin.h"
+#include "../condor_daemon_core.V6/condor_daemon_core.h"
+
+// local includes
+#include "SchedulerObject.h"
+#include "PROC_ID_comparator.h"
+
+
+namespace aviary {
+namespace job {
+
+// BIG NOTE: If Service is not first in the parent list the
+//           processDirtyJobs handler will segfault when using the
+//           dirtyJobs list
+class AviaryScheddPlugin : public Service, ClassAdLogPlugin, ScheddPlugin
+{
+
+public:
+
+	void earlyInitialize();
+
+	void initialize();
+
+	void shutdown();
+
+	void update(int cmd, const ClassAd *ad);
+
+	void archive(const ClassAd *ad);
+
+	void newClassAd(const char */*key*/);
+
+	void setAttribute(const char *key,
+					  const char *name,
+					  const char *value);
+
+	void destroyClassAd(const char *key);
+
+	void deleteAttribute(const char *key,
+						 const char *name);
+
+private:
+
+	typedef std::pair<std::string, int> DirtyJobStatus;
+	typedef std::pair<std::string, DirtyJobStatus> DirtyJobEntry;
+	typedef std::list<DirtyJobEntry> DirtyJobsType;
+	DirtyJobsType *dirtyJobs;
+
+
+	bool isHandlerRegistered;
+
+	bool m_initialized;
+
+	bool m_isPublishing;
+
+	int HandleTransportSocket(Stream *);
+
+	void processDirtyJobs();
+
+	bool processJob(const char *key, const char *name, int value);
+
+	void markDirty(const char *key, const char *name, const char *value);
+
+};
+
+}} /* aviary::job */
+
+#endif /* _AVIARYSCHEDDPLUGIN_H */
diff --git a/src/condor_contrib/aviary/src/AviaryScheddPluginInstantiation.cpp b/src/condor_contrib/aviary/src/AviaryScheddPluginInstantiation.cpp
new file mode 100644
index 0000000..71c40c6
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryScheddPluginInstantiation.cpp
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "condor_common.h"
+
+#include "AviaryScheddPlugin.h"
+
+using namespace aviary::job;
+
+AviaryScheddPlugin *scheddPluginInstance;
+
+#ifndef WIN32
+
+void
+__attribute__ ((constructor))
+init(void)
+{
+    scheddPluginInstance = new AviaryScheddPlugin();
+}
+
+#endif
+
diff --git a/src/condor_contrib/aviary/src/AviaryUtils.cpp b/src/condor_contrib/aviary/src/AviaryUtils.cpp
new file mode 100644
index 0000000..61e0693
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryUtils.cpp
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_classad.h"
+#include "condor_debug.h"
+#include "compat_classad_util.h"
+#include "condor_qmgr.h"
+#include "get_daemon_name.h"
+
+// c++ includes
+#include <map>
+
+// local includes
+#include "AviaryUtils.h"
+
+using namespace std;
+using namespace compat_classad;
+
+string
+aviary::util::getPoolName()
+{
+    string poolName;
+    char *tmp = NULL;
+
+    tmp = param("COLLECTOR_HOST");
+    if (!tmp) {
+        tmp = strdup("NO COLLECTOR_HOST, NOT GOOD");
+    }
+    poolName = tmp;
+    free(tmp); tmp = NULL;
+
+    return poolName;
+}
+
+string
+aviary::util::getScheddName() {
+	string scheddName;
+	char* tmp = NULL;
+
+	tmp = param("SCHEDD_NAME");
+	if (!tmp) {
+		scheddName = default_daemon_name();
+	} else {
+		scheddName = build_valid_daemon_name(tmp);
+		free(tmp); tmp = NULL;
+	}
+
+	return scheddName;
+}
+
+// cleans up the quoted values from the job log reader
+string aviary::util::trimQuotes(const char* str) {
+	string val = str;
+
+	size_t endpos = val.find_last_not_of("\\\"");
+	if( string::npos != endpos ) {
+		val = val.substr( 0, endpos+1 );
+	}
+	size_t startpos = val.find_first_not_of("\\\"");
+	if( string::npos != startpos ) {
+		val = val.substr( startpos );
+	}
+
+	return val;
+}
+
+// validate that an incoming group/user name is
+// alphanumeric, underscores, or a dot separator
+bool aviary::util::isValidGroupUserName(const string& _name, string& _text) {
+	const char* ptr = _name.c_str();
+	while( *ptr ) {
+		char c = *ptr++;
+		if (	('a' > c || c > 'z') &&
+			('A' > c || c > 'Z') &&
+			('0' > c || c > '9') &&
+			(c != '_' ) &&
+			(c != '.' ) ) {
+			_text = "Invalid name for group/user - alphanumeric, underscore and dot characters only";
+			return false;
+		}
+	}
+	return true;
+}
+
+// validate that an incoming attribute name is
+// alphanumeric, or underscores
+bool aviary::util::isValidAttributeName(const string& _name, string& _text) {
+	const char* ptr = _name.c_str();
+	while( *ptr ) {
+		char c = *ptr++;
+		if (	('a' > c || c > 'z') &&
+			('A' > c || c > 'Z') &&
+			('0' > c || c > '9') &&
+			(c != '_' ) ) {
+			_text = "Invalid name for attribute - alphanumeric and underscore characters only";
+			return false;
+		}
+	}
+	return true;
+}
+
+bool aviary::util::checkRequiredAttrs(compat_classad::ClassAd& ad, const char* attrs[], string& missing) {
+	bool status = true;
+	int i = 0;
+
+        while (NULL != attrs[i]) {
+		if (!ad.Lookup(attrs[i])) {
+			missing += " "; missing += attrs[i];
+			status = false;
+		}
+		i++;
+	}
+	return status;
+}
diff --git a/src/condor_contrib/aviary/src/AviaryUtils.h b/src/condor_contrib/aviary/src/AviaryUtils.h
new file mode 100644
index 0000000..b13314d
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryUtils.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AVIARYUTILS_H
+#define _AVIARYUTILS_H
+
+// condor includes
+#include "condor_classad.h"
+
+using namespace std;
+using namespace compat_classad;
+
+namespace aviary {
+namespace util {
+
+string getPoolName();
+
+string getScheddName();
+
+string trimQuotes(const char* value);
+
+bool isValidGroupUserName(const string& _name, string& _text);
+
+bool isValidAttributeName(const string& _name, string& _text);
+
+bool checkRequiredAttrs(ClassAd& ad, const char* attrs[], string& missing);
+
+}}
+
+#endif /* _AVIARYUTILS_H */
diff --git a/src/condor_contrib/aviary/src/Axis2SoapProvider.cpp b/src/condor_contrib/aviary/src/Axis2SoapProvider.cpp
new file mode 100644
index 0000000..fa0e1ca
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Axis2SoapProvider.cpp
@@ -0,0 +1,328 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include <axutil_error_default.h>
+#include <axutil_log_default.h>
+#include <axutil_thread_pool.h>
+#include <axiom_xml_reader.h>
+#include <axutil_file_handler.h>
+#include "Axis2SoapProvider.h"
+
+// NOTE: these types are not in the public
+// Axis2/C API via headers but we need them;
+// review if there is a newer rev after 1.6
+
+// lifted out from http_receiver.c
+typedef struct
+{
+     axis2_transport_receiver_t http_server;
+     axis2_http_svr_thread_t *svr_thread;
+     int port;
+     axis2_conf_ctx_t *conf_ctx;
+     axis2_conf_ctx_t *conf_ctx_private;
+} axis2_http_server_impl_t;
+ 
+#define AXIS2_INTF_TO_IMPL(http_server) \
+ ((axis2_http_server_impl_t *)(http_server))
+ 
+// lifted out from http_svr_thread.c
+struct axis2_http_svr_thread
+{
+    int listen_socket;
+    axis2_bool_t stopped;
+    axis2_http_worker_t *worker;
+    int port;
+};
+
+typedef struct axis2_http_svr_thd_args
+{
+    axutil_env_t *env;
+    axis2_socket_t socket;
+    axis2_http_worker_t *worker;
+    axutil_thread_t *thread;
+} axis2_http_svr_thd_args_t;
+
+using namespace aviary::soap;
+
+Axis2SoapProvider::Axis2SoapProvider(int _log_level, const char* _log_file, const char* _repo_path)
+{
+    if (_log_file) {
+        m_log_file = _log_file;
+    }
+    if (_repo_path) {
+        m_repo_path = _repo_path;
+    }
+    m_log_level = axutil_log_levels_t(_log_level);
+    m_env = NULL;
+    m_http_server = NULL;
+    m_svr_thread = NULL;
+    m_initialized = false;
+}
+
+Axis2SoapProvider::~Axis2SoapProvider()
+{
+    if (m_http_server) {
+        axis2_transport_receiver_free(m_http_server, m_env);
+    }
+
+    if (m_env) {
+        axutil_env_free(m_env);
+    }
+
+    axiom_xml_reader_cleanup();
+
+}
+
+bool
+Axis2SoapProvider::init(int _port, int _read_timeout, std::string& _error)
+{
+    if (m_log_file.empty() || m_repo_path.empty()) {
+        _error = "Log file or repo path is NULL";
+        return false;
+    }
+
+    if (!m_initialized) {
+        axutil_allocator_t* allocator = axutil_allocator_init(NULL);
+        axutil_error_t *error = axutil_error_create(allocator);
+        axutil_log_t *log = axutil_log_create(allocator, NULL, m_log_file.c_str());
+
+        // TODO: not sure we need a TP but don't wanted to get tripped up by a NP
+        // deeper in the stack
+        axutil_thread_pool_t *thread_pool = axutil_thread_pool_init(allocator);
+        axiom_xml_reader_init();
+        m_env = axutil_env_create(allocator);
+        axutil_error_init();
+
+        m_env = axutil_env_create_with_error_log_thread_pool(allocator, error, log, thread_pool);
+        m_env->log->level = m_log_level;
+
+        axis2_status_t status = axutil_file_handler_access(m_repo_path.c_str(), AXIS2_R_OK);
+
+        if (status != AXIS2_SUCCESS) {
+			_error = m_repo_path;
+			_error += " does not exist or insufficient permissions";
+            AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI,_error.c_str());
+            return m_initialized;
+        }
+
+        m_http_server = axis2_http_server_create_with_file(m_env, m_repo_path.c_str(), _port);
+        if (!m_http_server) {
+			_error =  AXIS2_ERROR_GET_MESSAGE(m_env->error);
+            AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI, "HTTP server create failed: %d: %s",
+                            m_env->error->error_number,_error.c_str());
+            return m_initialized;
+        }
+
+        m_svr_thread = createHttpReceiver(m_env,m_http_server,_error); 
+        if (!m_svr_thread) {
+			_error =  AXIS2_ERROR_GET_MESSAGE(m_env->error);
+			AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI, "HTTP receiver create failed: %d: %s",
+                            m_env->error->error_number,_error.c_str());
+            return m_initialized;
+        }
+
+        m_initialized = true;
+    }
+
+    return m_initialized;
+
+}
+
+axis2_http_svr_thread_t*
+Axis2SoapProvider::createHttpReceiver(axutil_env_t* _env, axis2_transport_receiver_t* _server, std::string& _error)
+{
+
+    axis2_http_server_impl_t *server_impl = NULL;
+    axis2_http_worker_t *worker = NULL;
+
+    server_impl = AXIS2_INTF_TO_IMPL(_server);
+    server_impl->svr_thread = axis2_http_svr_thread_create(_env, server_impl->port);
+
+    // shouldn't bother checking this for ST but we'll play along
+    if(!server_impl->svr_thread) {
+        AXIS2_LOG_ERROR(_env->log, AXIS2_LOG_SI, "unable to create server thread for port %d",
+                server_impl->port);
+        return NULL;
+    }
+
+    worker = axis2_http_worker_create(_env, server_impl->conf_ctx);
+    if(!worker) {
+        AXIS2_LOG_ERROR(_env->log, AXIS2_LOG_SI, "axis2 http worker creation failed");
+        axis2_http_svr_thread_free(server_impl->svr_thread, _env);
+        server_impl->svr_thread = NULL;
+        return NULL;
+    }
+
+    axis2_http_worker_set_svr_port(worker, _env, server_impl->port);
+    axis2_http_svr_thread_set_worker(server_impl->svr_thread, _env, worker);
+    return server_impl->svr_thread;
+
+}
+
+SOCKET
+Axis2SoapProvider::getHttpListenerSocket()
+{
+    SOCKET socket = INVALID_SOCKET;
+    if (m_svr_thread) {
+        socket = m_svr_thread->listen_socket;
+    }
+    return socket;
+}
+
+bool
+Axis2SoapProvider::processHttpRequest(std::string& _error)
+{
+    if (!m_initialized) {
+         _error = "Axis2SoapPovider has not been initialized yet";
+        return false;
+    }
+    else {
+
+        AXIS2_ENV_CHECK(m_env, AXIS2_FAILURE);
+
+        int socket = INVALID_SOCKET;
+        axis2_http_svr_thd_args_t *arg_list = NULL;
+
+        socket = (int)axutil_network_handler_svr_socket_accept(m_env, m_svr_thread->listen_socket);
+        if(!m_svr_thread->worker)
+        {
+            AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI,
+                "Worker not ready yet. Cannot serve the request");
+            axutil_network_handler_close_socket(m_env, socket);
+            return false;
+        }
+
+        arg_list = (axis2_http_svr_thd_args_t *)AXIS2_MALLOC(m_env->allocator, sizeof(axis2_http_svr_thd_args_t));
+        if(!arg_list)
+        {
+            AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI,
+                "Memory allocation error in the svr thread loop");
+            return false;
+        }
+
+        arg_list->env = (axutil_env_t *)m_env;
+        arg_list->socket = socket;
+        arg_list->worker = m_svr_thread->worker;
+
+        // single-threaded for DC
+        invokeHttpWorker(NULL, (void *)arg_list);
+    }
+
+    return true;
+}
+
+void *AXIS2_THREAD_FUNC
+Axis2SoapProvider::invokeHttpWorker(
+    axutil_thread_t * thd,
+    void *data)
+{
+    struct AXIS2_PLATFORM_TIMEB t1, t2;
+    axis2_simple_http_svr_conn_t *svr_conn = NULL;
+    axis2_http_simple_request_t *request = NULL;
+    int millisecs = 0;
+    double secs = 0;
+    axis2_http_worker_t *tmp = NULL;
+    axis2_status_t status = AXIS2_FAILURE;
+    axutil_env_t *env = NULL;
+    axis2_socket_t socket;
+    axutil_env_t *thread_env = NULL;
+    axis2_http_svr_thd_args_t *arg_list = NULL;
+
+#ifndef WIN32
+#ifdef AXIS2_SVR_MULTI_THREADED
+    signal(SIGPIPE, SIG_IGN);
+#endif
+#endif
+
+    if(!data)
+    {
+        return NULL;
+    }
+    arg_list = (axis2_http_svr_thd_args_t *)data;
+
+    env = arg_list->env;
+    thread_env = axutil_init_thread_env(env);
+
+    IF_AXIS2_LOG_DEBUG_ENABLED(env->log)
+    {
+        AXIS2_PLATFORM_GET_TIME_IN_MILLIS(&t1);
+    }
+
+    socket = arg_list->socket;
+    svr_conn = axis2_simple_http_svr_conn_create(thread_env, (int)socket);
+    if(!svr_conn)
+    {
+        AXIS2_LOG_ERROR(env->log, AXIS2_LOG_SI, "creating simple_http_svr_connection failed");
+        return NULL;
+    }
+
+    axis2_simple_http_svr_conn_set_rcv_timeout(svr_conn, thread_env, m_http_socket_read_timeout);
+
+    /* read HTTPMethod, URL, HTTP Version and http headers. Leave the remaining in the stream */
+    request = axis2_simple_http_svr_conn_read_request(svr_conn, thread_env);
+    if(!request)
+    {
+        AXIS2_LOG_ERROR(env->log, AXIS2_LOG_SI, "Could not create request");
+        return NULL;
+    }
+
+    tmp = arg_list->worker;
+    status = axis2_http_worker_process_request(tmp, thread_env, svr_conn, request);
+    axis2_simple_http_svr_conn_free(svr_conn, thread_env);
+    axis2_http_simple_request_free(request, thread_env);
+
+    IF_AXIS2_LOG_DEBUG_ENABLED(env->log)
+    {
+        AXIS2_PLATFORM_GET_TIME_IN_MILLIS(&t2);
+        millisecs = t2.millitm - t1.millitm;
+        secs = difftime(t2.time, t1.time);
+        if(millisecs < 0)
+        {
+            millisecs += 1000;
+            secs--;
+        }
+        secs += millisecs / 1000.0;
+
+#if defined(WIN32)
+        AXIS2_LOG_DEBUG(thread_env->log, AXIS2_LOG_SI, "Request processed...");
+#else
+        AXIS2_LOG_DEBUG(thread_env->log, AXIS2_LOG_SI, "Request processed in %.3f seconds", secs);
+#endif
+    }
+
+    if(status == AXIS2_SUCCESS)
+    {
+        AXIS2_LOG_DEBUG(thread_env->log, AXIS2_LOG_SI, "Request served successfully");
+    }
+    else
+    {
+        AXIS2_LOG_WARNING(thread_env->log, AXIS2_LOG_SI, "Error occurred in processing request ");
+    }
+
+    // just ST here
+    AXIS2_FREE(thread_env->allocator, arg_list);
+    axutil_free_thread_env(thread_env);
+    thread_env = NULL;
+
+    return NULL;
+}
+
+// TODO: need a public axis2_tcp_worker.h for this
+//Axis2SoapProvider::processTcpRequest() {
+//    axis2_tcp_worker_process_request();
+//}
diff --git a/src/condor_contrib/aviary/src/Axis2SoapProvider.h b/src/condor_contrib/aviary/src/Axis2SoapProvider.h
new file mode 100644
index 0000000..1828ee8
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Axis2SoapProvider.h
@@ -0,0 +1,80 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _AXIS2SOAPPROVIDER_H
+#define _AXIS2SOAPPROVIDER_H
+
+#include <string>
+#include <axis2_http_server.h>
+#include <axis2_http_transport.h>
+#include <platforms/axutil_platform_auto_sense.h>
+#include <axis2_http_worker.h>
+#include <axutil_network_handler.h>
+#include <axis2_http_svr_thread.h>
+// TODO: future tcp support
+//#include <axis2_tcp_worker.h>
+
+// borrow what DC does
+#if !defined(WIN32)
+#  ifndef SOCKET
+#    define SOCKET int
+#  endif
+#  ifndef INVALID_SOCKET
+#    define INVALID_SOCKET -1
+#  endif
+#endif /* not WIN32 */
+
+#define DEFAULT_LOG_FILE "./axis2.log"
+#define DEFAULT_REPO_FILE "../axis2.xml"
+#define DEFAULT_PORT 9090
+
+// C++ wrapper around a SINGLE-THREADED
+// Axis2/C engine; suitable for integration
+// with DaemonCore socket registration
+// ./configure --enable-multi-thread=no
+
+namespace aviary {
+namespace soap {
+
+class Axis2SoapProvider {
+    public:
+        Axis2SoapProvider(int _log_level=AXIS2_LOG_LEVEL_DEBUG, const char* _log_file=DEFAULT_LOG_FILE, const char* _repo_path=DEFAULT_REPO_FILE);
+        ~Axis2SoapProvider();
+        bool init(int _port, int _read_timeout, std::string& _error);
+        SOCKET getHttpListenerSocket();
+        bool processHttpRequest(std::string& _error);
+
+		const axutil_env_t* getEnv() {return m_env;}
+
+    private:
+        std::string m_log_file;
+        std::string m_repo_path;
+        axutil_log_levels_t m_log_level;
+        axutil_env_t* m_env;
+        axis2_transport_receiver_t* m_http_server;
+        axis2_http_svr_thread_t* m_svr_thread;
+        int m_http_socket_read_timeout;
+        bool m_initialized;
+
+        axis2_http_svr_thread_t* createHttpReceiver(axutil_env_t* _env, axis2_transport_receiver_t* _server, std::string& _error);
+        void *AXIS2_THREAD_FUNC invokeHttpWorker( axutil_thread_t * thd, void *data );
+};
+
+}}
+
+#endif    // _AXIS2SOAPPROVIDER_H
diff --git a/src/condor_contrib/aviary/src/CMakeLists.txt b/src/condor_contrib/aviary/src/CMakeLists.txt
new file mode 100644
index 0000000..ea1a512
--- /dev/null
+++ b/src/condor_contrib/aviary/src/CMakeLists.txt
@@ -0,0 +1,85 @@
+ ###############################################################
+ # 
+ # Copyright (C) 2009-2011, Red Hat, Inc.
+ # 
+ # Licensed under the Apache License, Version 2.0 (the "License"); you 
+ # may not use this file except in compliance with the License.  You may 
+ # obtain a copy of the License at 
+ # 
+ #    http://www.apache.org/licenses/LICENSE-2.0 
+ # 
+ # Unless required by applicable law or agreed to in writing, software 
+ # distributed under the License is distributed on an "AS IS" BASIS, 
+ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ # See the License for the specific language governing permissions and 
+ # limitations under the License. 
+ # 
+ ###############################################################
+
+# shouldn't happen if gen code checked-in
+if ( NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/../codegen" )
+     message( FATAL_ERROR "run ../gen-xsd-cpp.sh first!")
+endif ()
+
+############################
+# file target references.
+############################
+file( GLOB COMMON_GEN_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/../codegen/common/src/*.cpp )
+file( GLOB JOB_GEN_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/../codegen/job/src/*.cpp )
+file( GLOB JOB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/AviaryJobService*.cpp )
+file( GLOB QUERY_GEN_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/../codegen/query/src/*.cpp )
+file( GLOB QUERY_SRCS ${CMAKE_CURRENT_SOURCE_DIR} AviaryQueryService*.cpp )
+
+file( GLOB SCHED_PLUGIN_SRCS Codec.cpp AviaryUtils.cpp SchedulerObject.cpp
+			PROC_ID_comparator.cpp Axis2SoapProvider.cpp AviaryScheddPlugin*.cpp )
+
+file( GLOB JOB_SERVER_SRCS aviary_query_server.cpp Axis2SoapProvider.cpp 
+							SubmissionObject.cpp JobServerJobLogConsumer.cpp
+							Job.cpp HistoryFile.cpp HistoryProcessingUtils.cpp Globals.cpp
+							Codec.cpp JobServerObject.cpp AviaryUtils.cpp )
+
+############################
+# schedd plugin
+############################
+src_target_ref( condor_collector "hashkey" COLLECTOR_REF )
+src_target_ref( utils "set_user_priv_from_ad" UTILS_REF )
+
+add_library (aviary_job_axis SHARED ${COMMON_GEN_SRCS} ${JOB_GEN_SRCS} ${JOB_SRCS} Codec.cpp AviaryUtils.cpp SchedulerObject.cpp )
+# remove unresolved deps by copying in -lwso2_wsf objects
+target_link_libraries(aviary_job_axis -Wl,--whole-archive -lwso2_wsf -Wl,--no-whole-archive)
+
+condor_plugin( AviaryScheddPlugin-plugin "${COLLECTOR_REF};${UTILS_REF};${SCHED_PLUGIN_SRCS}" "${C_LIBEXEC}" "${WSO2_FOUND}" ON)
+# remove unresolved deps by copying in -laxis2_engine objects
+target_link_libraries(AviaryScheddPlugin-plugin -Wl,--whole-archive -laxis2_engine -Wl,--no-whole-archive)
+
+############################
+# query server (aka ye old job server)
+############################
+add_library (aviary_query_axis SHARED ${COMMON_GEN_SRCS} ${QUERY_GEN_SRCS} ${QUERY_SRCS} )
+target_link_libraries (aviary_query_axis ${WSO2_FOUND})
+
+condor_exe( aviary_query_server "${JOB_SERVER_SRCS}"
+			"${C_SBIN}" "${CONDOR_LIBS};${PCRE_FOUND};${OPENSSL_FOUND};${COREDUMPER_FOUND};${KRB5_FOUND};${GLOBUS_FOUND};${GCB_FOUND};${WSO2_FOUND}" OFF )
+
+############################
+# install targets && configure our axis2.xml for platform
+############################
+configure_file("${CMAKE_CURRENT_SOURCE_DIR}/../etc/axis2.xml.in" "${CMAKE_CURRENT_BINARY_DIR}/../etc/axis2.xml" @ONLY)
+install (FILES ${CMAKE_CURRENT_BINARY_DIR}/../etc/axis2.xml DESTINATION ${CMAKE_INSTALL_PREFIX} )
+
+install (TARGETS aviary_query_axis DESTINATION ${C_SERVICES}/query)
+install (FILES ${CMAKE_CURRENT_SOURCE_DIR}/../services/query/services.xml DESTINATION ${C_SERVICES}/query )
+install (FILES ${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-common.xsd
+			${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-query.xsd
+			${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-query.wsdl
+		DESTINATION ${C_SERVICES}/query )
+
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/../etc/61aviary.config DESTINATION "${C_ETC_EXAMPLES}")
+
+install (TARGETS aviary_job_axis DESTINATION ${C_SERVICES}/job)
+install (FILES ${CMAKE_CURRENT_SOURCE_DIR}/../services/job/services.xml DESTINATION ${C_SERVICES}/job )
+install (FILES ${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-common.xsd
+				${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-job.xsd
+				${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-job.wsdl
+		DESTINATION ${C_SERVICES}/job )
+
diff --git a/src/condor_contrib/aviary/src/Codec.cpp b/src/condor_contrib/aviary/src/Codec.cpp
new file mode 100644
index 0000000..aa3535b
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Codec.cpp
@@ -0,0 +1,144 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_qmgr.h"
+
+// local includes
+#include "Codec.h"
+#include "AviaryUtils.h"
+
+using namespace compat_classad;
+using namespace aviary::codec;
+using namespace aviary::util;
+
+// TODO: defer until linking issues sorted
+//Codec*
+//DefaultCodecFactory::createCodec() {
+//    if (!m_codec) {
+//        m_codec = new BaseCodec;
+//    }
+//    return m_codec;
+//}
+
+BaseCodec::BaseCodec()
+{
+    //
+}
+
+BaseCodec::~BaseCodec()
+{
+    //
+}
+
+
+bool
+BaseCodec::addAttributeToMap (ClassAd& ad, const char* name, AttributeMapType& _map)
+{
+    ExprTree *expr;
+
+    // All these extra lookups are horrible. They have to
+    // be there because the ClassAd may have multiple
+    // copies of the same attribute name! This means that
+    // the last attribute with a given name will set the
+    // value, but the last attribute tends to be the
+    // attribute with the oldest (wrong) value. How
+    // annoying is that!
+    if (!(expr = ad.Lookup(name))) {
+        dprintf(D_FULLDEBUG, "Warning: failed to lookup attribute '%s' from ad\n", name);
+        return false;
+    }
+
+    classad::Value value;
+    ad.EvaluateExpr(expr,value);
+	const char* key = strdup(name);
+    switch (value.GetType()) {
+        // seems this covers expressions also
+        case classad::Value::BOOLEAN_VALUE:
+            _map[key] = new AviaryAttribute(AviaryAttribute::EXPR_TYPE,strdup(trimQuotes(ExprTreeToString(expr)).c_str()));
+            break;
+        case classad::Value::INTEGER_VALUE:
+            _map[key] = new AviaryAttribute(AviaryAttribute::INTEGER_TYPE,strdup(ExprTreeToString(expr)));;
+            break;
+        case classad::Value::REAL_VALUE:
+            _map[key] = new AviaryAttribute(AviaryAttribute::FLOAT_TYPE,strdup(ExprTreeToString(expr)));
+            break;
+        case classad::Value::STRING_VALUE:
+        default:
+            _map[key] = new AviaryAttribute(AviaryAttribute::STRING_TYPE,strdup(trimQuotes(ExprTreeToString(expr)).c_str()));
+    }
+
+    return true;
+}
+
+bool
+BaseCodec::classAdToMap(ClassAd& ad, AttributeMapType& _map)
+{
+    ExprTree *expr;
+	const char *name;
+	ad.ResetExpr();
+	_map.clear();
+	while (ad.NextExpr(name,expr)) {
+		if (!addAttributeToMap(ad, name, _map)) {
+                    return false;
+		}
+	}
+
+// //debug
+//        if (DebugFlags & D_FULLDEBUG) {
+//            ad.dPrint(D_FULLDEBUG|D_NOHEADER);
+//        }
+
+    return true;
+}
+
+
+bool
+BaseCodec::mapToClassAd(AttributeMapType& _map, ClassAd& ad)
+{
+
+    for (AttributeMapIterator entry = _map.begin(); _map.end() != entry; entry++) {
+        const char* name = entry->first;
+        AviaryAttribute* value = entry->second;
+
+        switch (value->getType()) {
+            case AviaryAttribute::INTEGER_TYPE:
+                ad.Assign(name, atoi(value->getValue()));
+                break;
+            case AviaryAttribute::FLOAT_TYPE:
+                ad.Assign(name, atof(value->getValue()));
+                break;
+            case AviaryAttribute::STRING_TYPE:
+                ad.Assign(name, value->getValue());
+                break;
+            case AviaryAttribute::EXPR_TYPE:
+                ad.AssignExpr(name, value->getValue());
+                break;
+            default:
+                dprintf(D_FULLDEBUG, "Warning: Unknown/unsupported type in map for attribute '%s'\n", name);
+        }
+    }
+
+//     // debug
+//     if (DebugFlags & D_FULLDEBUG) {
+//           ad.dPrint(D_FULLDEBUG|D_NOHEADER);
+//     }
+
+    return true;
+}
diff --git a/src/condor_contrib/aviary/src/Codec.h b/src/condor_contrib/aviary/src/Codec.h
new file mode 100644
index 0000000..b73a958
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Codec.h
@@ -0,0 +1,127 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _CODEC_H
+#define _CODEC_H
+
+// c++ includes
+#include <map>
+#include <vector>
+
+// condor includes
+#include <compat_classad.h>
+
+using namespace std;
+using namespace compat_classad;
+
+namespace aviary {
+namespace codec {
+
+// universal err struct
+struct AviaryStatus
+{
+	// keep these aligned with whatever public API
+	// in XSD, JSON, etc.
+    enum StatusType
+    {
+		// don't use "OK"
+        A_OK = 0,
+        FAIL = 1,
+        NO_MATCH = 2,
+        STRING_TYPE = 3,
+		INVALID_OFFSET = 4,
+		UNIMPLEMENTED = 5,
+		UNAVAILABLE = 6
+    };
+
+    StatusType type;
+    string text;
+};
+
+class AviaryAttribute
+{
+public:
+    enum AttributeType
+    {
+        EXPR_TYPE = 0,
+        INTEGER_TYPE = 1,
+        FLOAT_TYPE = 2,
+        STRING_TYPE = 3
+    };
+    AviaryAttribute ( AttributeType _type, const char* _value): m_type(_type), m_value(_value) {};
+    ~AviaryAttribute();
+
+    AttributeType getType() const { return m_type; }
+    const char * getValue() const { return m_value; }
+
+private:
+    AttributeType m_type;
+    const char * m_value;
+};
+
+typedef map<const char*, AviaryAttribute*> AttributeMapType;
+typedef AttributeMapType::const_iterator AttributeMapIterator;
+
+// TODO: revisit
+// singleton class for encoding/decoding from/to transport-specific types
+// to a simple type to be used in the impl;
+// intent is to sit above ClassAds but still interact with them;
+// base is suitable for SOAP, but QMF might need subclassing
+// with it's !!descriptors idiom
+class Codec {
+public:
+    virtual bool addAttributeToMap(ClassAd& ad, const char* name, AttributeMapType& _map) = 0;
+    virtual bool classAdToMap(ClassAd &ad, AttributeMapType &_map) = 0;
+    virtual bool mapToClassAd(AttributeMapType &_map, ClassAd &ad) = 0;
+
+};
+
+// TODO: defer until linking issues sorted
+//class CodecFactory {
+// public:
+//     virtual Codec* createCodec() = 0;
+// 
+// };
+// 
+// class DefaultCodecFactory: public CodecFactory {
+// public:
+//     virtual Codec* createCodec();
+// protected:
+//     Codec* m_codec;
+// };
+
+class BaseCodec: public Codec {
+public:
+    //friend class DefaultCodecFactory;
+    virtual bool addAttributeToMap(ClassAd& ad, const char* name, AttributeMapType& _map);
+    virtual bool classAdToMap(ClassAd &ad, AttributeMapType &_map);
+    virtual bool mapToClassAd(AttributeMapType &_map, ClassAd &ad);
+
+//protected:
+    BaseCodec();
+    ~BaseCodec();
+
+private:
+    BaseCodec (const BaseCodec &);
+    BaseCodec& operator= (const BaseCodec &);
+
+};
+
+}}
+
+#endif    // _CODEC_H
diff --git a/src/condor_contrib/aviary/src/Globals.cpp b/src/condor_contrib/aviary/src/Globals.cpp
new file mode 100644
index 0000000..14e36fb
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Globals.cpp
@@ -0,0 +1,29 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include "Globals.h"
+
+namespace aviary {
+namespace query {
+
+JobCollectionType g_jobs;
+SubmissionCollectionType g_submissions;
+OwnerlessClusterType g_ownerless_clusters;
+OwnerlessSubmissionType g_ownerless_submissions;
+
+}}
\ No newline at end of file
diff --git a/src/condor_contrib/aviary/src/Globals.h b/src/condor_contrib/aviary/src/Globals.h
new file mode 100644
index 0000000..2b09add
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Globals.h
@@ -0,0 +1,51 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _GLOBALS_H
+#define _GLOBALS_H
+
+// condor includes
+#include "condor_common.h"
+
+// c++ includes
+#include <map>
+
+// local includes
+#include "Job.h"
+#include "JobServerObject.h"
+#include "SubmissionObject.h"
+#include "cmpstr.h"
+
+using namespace std;
+
+namespace aviary {
+namespace query {
+
+typedef map<const char *, Job *, cmpstr> JobCollectionType;
+typedef map<const char *, SubmissionObject *, cmpstr> SubmissionCollectionType;
+typedef map<int, string> OwnerlessClusterType;
+typedef map<int, SubmissionObject*> OwnerlessSubmissionType;
+
+extern JobCollectionType g_jobs;
+extern SubmissionCollectionType g_submissions;
+extern OwnerlessClusterType g_ownerless_clusters;
+extern OwnerlessSubmissionType g_ownerless_submissions;
+
+}}
+
+#endif /* _GLOBALS_H */
diff --git a/src/condor_contrib/aviary/src/HistoryFile.cpp b/src/condor_contrib/aviary/src/HistoryFile.cpp
new file mode 100644
index 0000000..81cc624
--- /dev/null
+++ b/src/condor_contrib/aviary/src/HistoryFile.cpp
@@ -0,0 +1,380 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "condor_common.h"
+
+#include "condor_config.h"
+#include "condor_debug.h"
+
+#include "condor_attributes.h"
+
+#include "directory.h"
+
+#include "HistoryFile.h"
+
+#include "HistoryProcessingUtils.h"
+
+#include <libgen.h> // dirname
+
+#include <string>
+
+#define HISTORY_INDEX_SUFFIX ".idx"
+using std::string;
+
+
+HistoryFile::HistoryFile(const string name):
+	m_name(name),
+	m_stat(NULL),
+	m_file(NULL),
+	m_index(NULL)
+{
+}
+
+HistoryFile::~HistoryFile()
+{
+	cleanup();
+}
+
+void
+HistoryFile::cleanup()
+{
+	m_entries.clear();
+	if (m_file) { fclose(m_file); m_file = NULL; }
+	if (m_index) { fclose(m_index); m_index = NULL; }
+	if (m_stat) { free(m_stat); m_stat = NULL; }
+}
+
+HistoryFile::HistoryFile(const HistoryFile &base)
+{
+	m_file = NULL;
+	m_index = NULL;
+	m_stat = NULL;
+
+	*this = base;
+}
+
+HistoryFile &
+HistoryFile::operator=(const HistoryFile &base)
+{
+	if (this != &base) {
+		(*this).m_name = base.m_name;
+
+		cleanup();
+
+		// Don't just copy the stat and FILE* members, initialize them
+		CondorError errstack;
+		if (!init(errstack)) {
+			// XXX: Should throw an exception here
+			dprintf ( D_ALWAYS, "HistoryFile::operator=: %s\n",
+					errstack.getFullText(true));		
+		}
+	}
+
+	return *this;
+}
+
+bool
+HistoryFile::init(CondorError &errstack)
+{
+	StatWrapper stat_wrapper;
+
+	if (stat_wrapper.Stat(m_name.c_str())) {
+		errstack.pushf("HistoryFile::init", 1,
+					   "Failed to stat %s: %d (%s)\n",
+					   m_name.c_str(),
+					   stat_wrapper.GetErrno(),
+					   strerror(stat_wrapper.GetErrno()));
+		return false;
+	}
+
+	m_stat = (StatStructType *) malloc(sizeof(StatStructType));
+	ASSERT(m_stat);
+	memcpy(m_stat, stat_wrapper.GetBuf(), sizeof(StatStructType));
+	if (!S_ISREG(m_stat->st_mode)) {
+		errstack.pushf("HistoryFile::init", 2,
+					   "%s: not a regular file\n",
+					   m_name.c_str());
+		return false;
+	}
+
+	m_file = safe_fopen_wrapper(m_name.c_str(), "r");
+	if (NULL == m_file) {
+		errstack.pushf("HistoryFile::init", 4,
+					   "Failed to fopen %s: %d (%s)\n",
+					   m_name.c_str(), errno, strerror(errno));
+		return false;
+	}
+
+	// Store the index in history.INO.idx to handle renames
+	MyString tmp;
+	char *buf = strdup(m_name.c_str());
+	ASSERT(buf);
+	long unsigned int id;
+	ASSERT(getId(id));
+	tmp.sprintf("%s%shistory.%ld%s", dirname(buf), DIR_DELIM_STRING, id, HISTORY_INDEX_SUFFIX);
+	m_index_name = tmp.Value();
+	free(buf);
+
+	const char *mode = "r+";
+
+	if (stat_wrapper.Stat(m_index_name.c_str())) {
+			// Not being available is acceptable
+		if (ENOENT != stat_wrapper.GetErrno()) {
+			errstack.pushf("HistoryFile::init", 1,
+						   "Failed to stat %s: %d (%s)\n",
+						   m_index_name.c_str(),
+						   stat_wrapper.GetErrno(),
+						   strerror(stat_wrapper.GetErrno()));
+			return false;
+		}
+
+		mode = "w+";
+ 	}
+
+	const StatStructType *stat = stat_wrapper.GetBuf();
+	if (!S_ISREG(stat->st_mode)) {
+		errstack.pushf("HistoryFile::init", 2,
+					   "%s: not a regular file\n",
+					   m_index_name.c_str());
+		return false;
+	}
+
+	m_index = safe_fopen_wrapper(m_index_name.c_str(), mode);
+	if (NULL == m_index) {
+		errstack.pushf("HistoryFile::init", 4,
+					   "Failed to fopen %s: %d (%s)\n",
+					   m_index_name.c_str(), errno, strerror(errno));
+		return false;
+	}
+
+	return true;
+}
+
+bool
+HistoryFile::getId(long unsigned int &id)
+{
+	if (!m_stat) return false;
+
+	id = m_stat->st_ino;
+	return true;
+}
+
+HistoryFile::HistoryEntriesTypeIterators
+HistoryFile::poll(CondorError &/*errstack*/)
+{
+	// Record the end of the current set of records, used to
+	// return just the newly read records
+	int size = m_entries.size();
+
+	// Load from the index
+	CondorError ignored_errstack;
+	if (!pollIndex(ignored_errstack)) {
+		dprintf(D_FULLDEBUG, "%s\n", ignored_errstack.getFullText(true));		
+	}
+
+	// Seek to the end of the last known record
+	if (!m_entries.empty()) {
+		HistoryEntry entry = m_entries.back();
+		fseek(m_file, entry.stop, SEEK_SET);
+	}
+
+	int end, error, empty;
+	end = 0;
+	while (!end) {
+		long int start, stop;
+
+		start = ftell(m_file);
+
+		// NOTE: If the ClassAd parsing completes without finding
+		// the delimiter the result is end=1 and empty=0. This
+		// should be sufficient for identifying incomplete
+		// records that are otherwise valid.
+		ClassAd ad(m_file, "***", end, error, empty);
+
+		stop = ftell(m_file);
+
+		if (end) continue;
+		if (error) {
+			error = 0;
+			dprintf(D_ALWAYS, "HistoryFile::poll: malformed ad, skipping\n");
+			continue;
+		}
+		if (empty) {
+			empty = 0;
+			dprintf(D_ALWAYS, "HistoryFile::poll: empty ad, skipping\n");
+			continue;
+		}
+
+		int cluster, proc, q_date, status, entered_status;
+		char *global_id = NULL, *cmd = NULL, *args1 = NULL, *args2 = NULL;
+		char *release_reason = NULL, *hold_reason = NULL;
+		char *submission = NULL;
+		char *owner = NULL;
+		if (!ad.LookupInteger(ATTR_CLUSTER_ID, cluster)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping\n",
+					ATTR_CLUSTER_ID);
+			continue;
+		}
+		if (!ad.LookupInteger(ATTR_PROC_ID, proc)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping\n",
+					ATTR_PROC_ID);
+			continue;
+		}
+		if (!ad.LookupInteger(ATTR_Q_DATE, q_date)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_Q_DATE, cluster, proc);
+			continue;
+		}
+		if (!ad.LookupInteger(ATTR_JOB_STATUS, status)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_JOB_STATUS, cluster, proc);
+			continue;
+		}
+		if (!ad.LookupInteger(ATTR_ENTERED_CURRENT_STATUS, entered_status)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_ENTERED_CURRENT_STATUS, cluster, proc);
+			continue;
+		}
+		if (!ad.LookupString(ATTR_GLOBAL_JOB_ID, &global_id)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_GLOBAL_JOB_ID, cluster, proc);
+			continue;
+		}
+		if (!ad.LookupString(ATTR_JOB_CMD, &cmd)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_JOB_CMD, cluster, proc);
+			continue;
+		}
+		ad.LookupString(ATTR_JOB_ARGUMENTS1, &args1);
+		ad.LookupString(ATTR_JOB_ARGUMENTS2, &args2);
+		ad.LookupString(ATTR_RELEASE_REASON, &release_reason);
+		ad.LookupString(ATTR_HOLD_REASON, &hold_reason);
+		ad.LookupString(ATTR_JOB_SUBMISSION, &submission);
+		ad.LookupString(ATTR_OWNER, &owner);
+
+		// Write an index record
+		fprintf(m_index,
+				"%ld %ld %s %d %d %d %d %d\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
+				start, stop, global_id,
+				cluster, proc,
+				q_date, status, entered_status,
+				submission ? submission : "",
+				owner ? owner : "",
+				cmd,
+				args1 ? args1 : "",
+				args2 ? args2 : "",
+				release_reason ? release_reason : "",
+				hold_reason ? hold_reason : "");
+
+		HistoryEntry entry;
+
+		entry.file = m_name;
+		entry.start = start;
+		entry.stop = stop;
+		entry.id = global_id;
+		entry.cluster = cluster;
+		entry.proc = proc;
+		entry.q_date = q_date;
+		entry.status = status;
+		entry.entered_status = entered_status;
+		if (submission) entry.submission = submission;
+		if (owner) entry.owner = owner;
+		entry.cmd = cmd;
+		if (args1) entry.args1 = args1;
+		if (args2) entry.args2 = args2;
+		if (release_reason) entry.release_reason = release_reason;
+		if (hold_reason) entry.hold_reason = hold_reason;
+
+		m_entries.push_back(entry);
+	}
+
+		// Return iterators for newly read records
+	return HistoryFile::HistoryEntriesTypeIterators(m_entries.begin() + size,
+													m_entries.end());
+}
+
+/**
+ * Index format:
+ *  start(%ld) stop(%ld) id(%s) cluster(%d) proc(%d) q_date(%d) status(%d) entered_status(%d)
+ *  submission(%s)
+ *  cmd(%s)
+ *  args1(%s)
+ * 	args2(%s)
+ *  release_reason(%s)
+ *  hold_reason(%s)
+ */
+bool
+HistoryFile::pollIndex(CondorError &errstack)
+{
+	while (1) {
+		int code;
+		HistoryEntry entry;
+
+		entry.file = m_name;
+		char *id = NULL;
+		code = fscanf(m_index, "%ld %ld %as %d %d %d %d %d",
+					  &entry.start, &entry.stop, &id,
+					  &entry.cluster, &entry.proc,
+					  &entry.q_date, &entry.status, &entry.entered_status);
+		if (code != 8) {
+			// Ok, at the end of the file, we're done
+			// code check is to handle truncated final entry
+			if (feof(m_index) && code < 0) {
+				break;
+			}
+
+			// XXX: EINTR?
+			errstack.pushf("HistoryFile::pollIndex", 6,
+						   "Failed to fscanf HistoryEntry from %s, "
+						   "rc=%d: %d (%s)\n",
+						   m_index_name.c_str(), code, errno, strerror(errno));
+
+			return false;
+		}
+
+		MyString buf;
+
+		buf.readLine(m_index); // consume newline
+
+#define BUF_SET(dest,attr)											\
+		if (buf.readLine(m_index)) {								\
+			buf.trim();												\
+			if (!buf.IsEmpty()) {									\
+				dest = buf.Value();									\
+			}														\
+		} else {													\
+			errstack.pushf("HistoryFile::pollIndex", 7,				\
+						   "Failed to read %s's %s from %s\n",		\
+						   id, attr, m_index_name.c_str());			\
+			return false;											\
+		}
+
+		BUF_SET(entry.submission, ATTR_JOB_SUBMISSION);
+		BUF_SET(entry.owner, ATTR_OWNER);
+		BUF_SET(entry.cmd, ATTR_JOB_CMD);
+		BUF_SET(entry.args1, ATTR_JOB_ARGUMENTS1);
+		BUF_SET(entry.args2, ATTR_JOB_ARGUMENTS2);
+		BUF_SET(entry.release_reason, ATTR_RELEASE_REASON);
+		BUF_SET(entry.hold_reason, ATTR_HOLD_REASON);
+
+		entry.id = id;
+		free(id); id = NULL;
+
+		m_entries.push_back(entry);
+	}
+
+	return true;
+}
diff --git a/src/condor_contrib/aviary/src/HistoryFile.h b/src/condor_contrib/aviary/src/HistoryFile.h
new file mode 100644
index 0000000..a7b0adc
--- /dev/null
+++ b/src/condor_contrib/aviary/src/HistoryFile.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _HISTORYFILE_H
+#define _HISTORYFILE_H
+
+#include <string>
+#include <deque>
+
+using std::string;
+using std::deque;
+using std::pair;
+
+#include "stat_wrapper.h"
+#include "CondorError.h"
+
+namespace aviary {
+namespace history {
+		
+struct HistoryEntry
+{
+	string file;
+	long int start; // ftell stream index for record start
+	long int stop;  // ftell stream index for record end
+	string id;
+	int q_date;
+	int cluster;
+	int proc;
+	int status;
+	int entered_status;
+	string submission;
+	string owner;
+	string cmd;
+	string args1;
+	string args2;
+	string release_reason;
+	string hold_reason;
+};
+
+class HistoryFile
+{
+public:
+	typedef deque<HistoryEntry> HistoryEntriesType;
+	typedef HistoryEntriesType::const_iterator HistoryEntriesTypeIterator;
+	typedef pair<HistoryEntriesTypeIterator,
+				 HistoryEntriesTypeIterator> HistoryEntriesTypeIterators;
+
+	HistoryFile(const string name);
+
+	~HistoryFile();
+
+	HistoryFile(const HistoryFile &base);
+	HistoryFile & operator=(const HistoryFile &base);
+
+	bool init(CondorError &errstack);
+
+	bool getId(long unsigned int &id);
+
+	HistoryEntriesTypeIterators poll(CondorError &errstack);
+
+	void cleanup();
+
+private:
+	string m_name;
+	string m_index_name;
+	HistoryEntriesType m_entries;
+	StatStructType *m_stat;
+	FILE *m_file;
+	FILE *m_index;
+
+	bool pollIndex(CondorError &errstack);
+
+};
+
+}}
+
+#endif /* _HISTORYFILE_H */
diff --git a/src/condor_contrib/aviary/src/HistoryProcessingUtils.cpp b/src/condor_contrib/aviary/src/HistoryProcessingUtils.cpp
new file mode 100644
index 0000000..0936f4d
--- /dev/null
+++ b/src/condor_contrib/aviary/src/HistoryProcessingUtils.cpp
@@ -0,0 +1,265 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_debug.h"
+#include "condor_attributes.h"
+#include "CondorError.h"
+#include "directory.h"
+#include "stat_wrapper.h"
+
+//local includes
+#include "JobServerJobLogConsumer.h"
+#include "Job.h"
+#include "HistoryProcessingUtils.h"
+#include "HistoryFile.h"
+#include "AviaryUtils.h"
+#include "Globals.h"
+
+// platform includes
+#include <libgen.h> // dirname
+
+// c++ includes
+#include <string>
+#include <deque>
+#include <set>
+
+using namespace aviary::query;
+
+#define HISTORY_INDEX_SUFFIX ".idx"
+using namespace std;
+
+typedef set<long unsigned int> HistoryFileListType;
+static HistoryFileListType m_historyFiles;
+MyString m_path;
+
+// force a reset of history processing
+void aviary::history::init_history_files() {
+    m_historyFiles.clear();
+    processHistoryDirectory();
+    processOrphanedIndices();
+    processCurrentHistory(true);
+}
+
+// Processing jobs from history file must allow for
+// duplicates, such as when current history file is renamed.
+static
+void
+process ( const HistoryEntry &entry )
+{
+    MyString key;
+
+    key.sprintf ( "%d.%d", entry.cluster, entry.proc );
+
+    const char* key_cstr = key.StrDup();
+
+    HistoryJobImpl *hji = new HistoryJobImpl (entry);
+
+    JobCollectionType::const_iterator element = g_jobs.find ( key_cstr );
+    if ( g_jobs.end() != element )
+    {
+	(*element).second->setImpl(hji);
+	dprintf ( D_FULLDEBUG, "HistoryJobImpl added to '%s'\n", key_cstr );
+    }
+    else {
+      // live job long gone...could be a restart
+      Job* job = new Job(key_cstr);
+      job->setImpl(hji);
+      g_jobs[key_cstr] = job;
+      dprintf ( D_FULLDEBUG, "HistoryJobImpl created for '%s'\n", key_cstr);
+    }
+
+	// // debug
+	// fprintf ( stdout,
+	//          "%ld %ld %s %d %d %d %d %d %s %s %s %s %s %s %s\n",
+	//          entry.start, entry.stop, entry.id.c_str(),
+	//          entry.cluster, entry.proc,
+	//          entry.q_date, entry.status, entry.entered_status,
+	//          entry.submission.c_str(),
+	//          entry.owner.c_str(),
+	//          entry.cmd.c_str(),
+	//          entry.args1.c_str(),
+	//          entry.args2.c_str(),
+	//          entry.release_reason.c_str(),
+	//          entry.hold_reason.c_str() );
+}
+
+/**
+ * Process the history directory and maintain the history file map
+ *
+ * Only handle rotated history files, those history.* that are not an
+ * index. For each one that is not in the history file map, create a
+ * new HistoryFile, poll it for entries to process, and add it to the
+ * map.
+ */
+void
+aviary::history::processHistoryDirectory()
+{
+    const char *file = NULL;
+
+    Directory dir ( m_path.Value() );
+    dir.Rewind();
+    while ( ( file = dir.Next() ) )
+    {
+        // Skip all non-history files, e.g. history and history.*.idx
+        if ( strncmp ( file, "history.", 8 ) ||
+                !strncmp ( file + ( strlen ( file ) - 4 ), HISTORY_INDEX_SUFFIX, 4 ) ) continue;
+
+        HistoryFile h_file ( ( m_path + DIR_DELIM_STRING + file ).Value() );
+        CondorError errstack;
+        if ( !h_file.init ( errstack ) )
+        {
+            dprintf ( D_ALWAYS, "%s\n", errstack.getFullText() );
+            return;
+        }
+        errstack.clear();
+
+        long unsigned int id;
+        ASSERT ( h_file.getId ( id ) );
+        HistoryFileListType::iterator entry = m_historyFiles.find ( id );
+        if ( m_historyFiles.end() == entry )
+        {
+            HistoryFile::HistoryEntriesTypeIterators ij = h_file.poll ( errstack );
+            for ( HistoryFile::HistoryEntriesTypeIterator i = ij.first;
+                    i != ij.second;
+                    i++ )
+            {
+                process ( ( *i ) );
+            }
+
+            m_historyFiles.insert ( id );
+        }
+    }
+}
+
+/**
+ * Process orphaned index files, those that exist but do not have a
+ * corresponding history file.
+ *
+ * Process all .idx files looking for the corresponding HistoryFile in
+ * the history file map.
+ */
+void
+aviary::history::processOrphanedIndices()
+{
+    const char *file = NULL;
+
+    Directory dir ( m_path.Value() );
+    dir.Rewind();
+    while ( ( file = dir.Next() ) )
+    {
+        // Skip all non-history index files, e.g. history and history.*
+        if ( strncmp ( file, "history.", 8 ) ||
+                strncmp ( file + ( strlen ( file ) - 4 ), HISTORY_INDEX_SUFFIX, 4 ) ) continue;
+
+        // XXX: This is ugly because it indicates we know details
+        // of how HistoryFile implements index files.
+
+        // The index file is "history.%ld.idx" where %ld is the id
+        // of the history file the index is for.
+
+        long unsigned int id;
+        int count = sscanf ( file, "history.%ld.idx", &id );
+        if ( 1 != count )
+        {
+            dprintf ( D_ALWAYS, "Error parsing %s, skipping.\n", file );
+            continue;
+        }
+
+        HistoryFileListType::iterator entry = m_historyFiles.find ( id );
+        if ( m_historyFiles.end() == entry )
+        {
+            // The index is dangling, remove it.
+            if ( !dir.Remove_Current_File() )
+            {
+               dprintf ( D_ALWAYS, "Failed to remove: %s\n", file );
+            }
+        }
+    }
+}
+
+/**
+ * Process the current history file.
+ *
+ * 1) check to see if it is properly initialized, recording id (inode)
+ * 2) stat the current history file
+ * 3) poll for new entries and process them
+ * 4) detect rotations
+ */
+void
+aviary::history::processCurrentHistory(bool force_reset)
+{
+    static MyString currentHistoryFilename = m_path + DIR_DELIM_STRING + "history";
+    static HistoryFile currentHistory ( currentHistoryFilename.Value() );
+
+    CondorError errstack;
+
+    if (force_reset) {
+       currentHistory.cleanup();
+    }
+
+	// (1)
+    long unsigned int id;
+    if ( !currentHistory.getId ( id ) || force_reset)
+    {
+        if ( !currentHistory.init ( errstack ) )
+        {
+            dprintf ( D_ALWAYS, "%s\n", errstack.getFullText() );
+            return;
+        }
+        ASSERT ( currentHistory.getId ( id ) );
+        m_historyFiles.insert ( id );
+    }
+
+    // (2)
+    // Stat before poll to handle race of: poll + write + rotate + stat
+    StatWrapper stat_wrapper;
+    if ( stat_wrapper.Stat ( currentHistoryFilename ) )
+    {
+        dprintf ( D_ALWAYS, "Failed to stat %s: %d (%s)\n",
+                  currentHistoryFilename.Value(),
+                  stat_wrapper.GetErrno(), strerror ( stat_wrapper.GetErrno() ) );
+        return;
+    }
+    const StatStructType *stat = stat_wrapper.GetBuf();
+    ASSERT ( currentHistory.getId ( id ) );
+
+    // (3)
+    errstack.clear();
+    HistoryFile::HistoryEntriesTypeIterators poll = currentHistory.poll ( errstack );
+    for ( HistoryFile::HistoryEntriesTypeIterator i = poll.first;
+            i != poll.second;
+            i++ )
+    {
+        process ( ( *i ) );
+    }
+
+    // (4)
+    // If different the file has rotated
+    if ( id != stat->st_ino )
+    {
+        currentHistory = HistoryFile ( currentHistoryFilename.Value() );
+        if ( !currentHistory.init ( errstack ) )
+        {
+            dprintf ( D_ALWAYS, "%s\n", errstack.getFullText() );
+            return;
+        }
+        ASSERT ( currentHistory.getId ( id ) );
+        m_historyFiles.insert ( id );
+    }
+}
diff --git a/src/condor_contrib/aviary/src/HistoryProcessingUtils.h b/src/condor_contrib/aviary/src/HistoryProcessingUtils.h
new file mode 100644
index 0000000..c16531a
--- /dev/null
+++ b/src/condor_contrib/aviary/src/HistoryProcessingUtils.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _HISTORYPROCESSINGUTILS_H
+#define _HISTORYPROCESSINGUTILS_H
+
+#include "Job.h"
+#include "AviaryUtils.h"
+
+namespace aviary {
+namespace history {
+
+void init_history_files();
+void processHistoryDirectory();
+void processOrphanedIndices();
+void processCurrentHistory(bool force_reset = false);
+bool populateMapFromClassAd ( ClassAd& ad, AttributeMapType& _map );
+
+}}
+
+#endif /* _HISTORYPROCESSINGUTILS_H */
diff --git a/src/condor_contrib/aviary/src/Job.cpp b/src/condor_contrib/aviary/src/Job.cpp
new file mode 100644
index 0000000..8465593
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Job.cpp
@@ -0,0 +1,691 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "condor_attributes.h"
+#include "condor_parser.h"
+#include "compat_classad.h"
+#include "proc.h"
+#include "stl_string_utils.h"
+
+// c++ includes
+#include <sstream>
+
+// local includes
+#include "Globals.h"
+#include "AviaryUtils.h"
+
+using namespace std;
+using namespace compat_classad;
+using namespace aviary::query;
+using namespace aviary::util;
+
+// Any key that begins with the '0' char is either the
+// header or a cluster, i.e. not a job
+#define IS_JOB(key) ((key) && '0' != (key)[0])
+
+// summary attributes
+ const char *ATTRS[] = {ATTR_CLUSTER_ID,
+                           ATTR_PROC_ID,
+                           ATTR_GLOBAL_JOB_ID,
+                           ATTR_Q_DATE,
+                           ATTR_ENTERED_CURRENT_STATUS,
+                           ATTR_JOB_STATUS,
+                           ATTR_JOB_CMD,
+                           ATTR_JOB_ARGUMENTS1,
+                           ATTR_JOB_ARGUMENTS2,
+                           ATTR_RELEASE_REASON,
+                           ATTR_HOLD_REASON,
+                           ATTR_JOB_SUBMISSION,
+                           ATTR_OWNER,
+                           NULL
+                          };
+
+// TODO: C++ utils which may very well exist elsewhere :-)
+template <class T>
+bool from_string ( T& t,
+                   const string& s,
+                   ios_base& ( *f ) ( ios_base& ) )
+{
+    istringstream iss ( s );
+    return ! ( iss >> f >> t ).fail();
+}
+
+template <class T>
+string to_string ( T t, ios_base & ( *f ) ( ios_base& ) )
+{
+    ostringstream oss;
+    oss << f << t;
+    return oss.str();
+}
+
+//////////////
+// LiveJobImpl
+//////////////
+LiveJobImpl::LiveJobImpl (const char* cluster_proc, ClusterJobImpl* parent)
+{
+    m_job = NULL;
+    m_parent = NULL;
+    m_summary_ad = NULL;
+    m_full_ad = new ClassAd();
+    if ( parent)
+    {
+        m_parent = parent;
+        m_parent->incrementRef();
+        m_full_ad->ChainToAd ( parent->m_full_ad );
+    }
+
+    dprintf ( D_FULLDEBUG, "LiveJobImpl created for '%s'\n", cluster_proc);
+}
+
+LiveJobImpl::~LiveJobImpl()
+{
+    // unchain our parent first
+    if (m_full_ad) {
+        m_full_ad->Unchain();
+        delete m_full_ad;
+        m_full_ad = NULL;
+    }
+
+    if (m_summary_ad) {
+        delete m_summary_ad;
+        m_summary_ad = NULL;
+    }
+
+    if (m_parent) {
+        m_parent->decrementRef();
+    }
+
+    dprintf ( D_FULLDEBUG, "LiveJobImpl destroyed: key '%s'\n", m_job->getKey());
+}
+
+bool
+LiveJobImpl::get ( const char *_name, const AviaryAttribute *&_attribute ) const
+{
+    // our job ad is chained so lookups will
+    // encompass our parent ad as well as the child
+
+    // parse the type
+    ExprTree *expr = NULL;
+    if ( ! ( expr = m_full_ad->Lookup ( _name ) ) )
+    {
+	    dprintf ( D_FULLDEBUG,
+                  "warning: failed to lookup attribute %s in job '%s'\n", _name, m_job->getKey() );
+        return false;
+    }
+    // decode the type
+    classad::Value value;
+    m_full_ad->EvaluateExpr(expr,value);
+    switch ( value.GetType() )
+    {
+        case classad::Value::INTEGER_VALUE:
+        {
+            int i;
+            if ( !m_full_ad->LookupInteger ( _name, i ) )
+            {
+                return false;
+            }
+            _attribute = new AviaryAttribute ( AviaryAttribute::INTEGER_TYPE, to_string<int> ( i,dec ).c_str() );
+            return true;
+        }
+        case classad::Value::REAL_VALUE:
+        {
+            float f;
+            if ( !m_full_ad->LookupFloat ( _name, f ) )
+            {
+                return false;
+            }
+            _attribute = new AviaryAttribute ( AviaryAttribute::FLOAT_TYPE, to_string<float> ( f,dec ).c_str() );
+            return true;
+        }
+        case classad::Value::STRING_VALUE:
+        {
+            MyString str;
+            if ( !m_full_ad->LookupString ( _name, str ) )
+            {
+                return false;
+            }
+            _attribute = new AviaryAttribute ( AviaryAttribute::STRING_TYPE, str.StrDup() );
+            return true;
+        }
+        default:
+        {
+            ExprTree* tree = NULL;
+            if ( ! ( tree = m_full_ad->Lookup ( _name ) ) )
+            {
+                return false;
+            }
+            const char* rhs;
+            rhs = ExprTreeToString( expr );
+            _attribute = new AviaryAttribute ( AviaryAttribute::EXPR_TYPE, rhs );
+            return true;
+        }
+    }
+
+    return false;
+}
+
+int LiveJobImpl::getStatus() const
+{
+    const AviaryAttribute* attr;
+
+    if ( !this->get ( ATTR_JOB_STATUS, attr ) )
+    {
+	// assume we might get cluster jobs here also
+	return JOB_STATUS_MIN;
+    }
+
+    return strtol ( attr->getValue(), ( char ** ) NULL, 10 );
+}
+
+void
+LiveJobImpl::set ( const char *_name, const char *_value )
+{
+
+    if ( strcasecmp ( _name, ATTR_JOB_SUBMISSION ) == 0 )
+    {
+        string val = trimQuotes( _value );
+        // grab the cluster from our key
+        PROC_ID id = getProcByString(m_job->getKey());
+	if (m_job) {
+		m_job->setSubmission ( val.c_str(), id.cluster );
+	}
+    }
+
+    // our status is changing...decrement for old one
+    if ( strcasecmp ( _name, ATTR_JOB_STATUS ) == 0 )
+    {
+	if ( m_job )
+        {
+	    m_job->setStatus(this->getStatus());
+            m_job->decrementSubmission ();
+        }
+    }
+
+    if ( strcasecmp ( _name, ATTR_OWNER ) == 0 )
+    {
+	// need to leave an owner for this job
+	// to be picked up soon
+	// if we are in here, we don't have m_submission
+	PROC_ID id = getProcByString(m_job->getKey());
+	string val = trimQuotes( _value );
+	g_ownerless_clusters[id.cluster] = val;
+	m_job->updateSubmission(id.cluster,val.c_str());
+    }
+
+    // parse the type
+    ExprTree *expr;
+    if ( ParseClassAdRvalExpr ( _value, expr ) )
+    {
+        dprintf ( D_ALWAYS,
+                  "error: parsing %s[%s] = %s, skipping\n",
+                  m_job->getKey(), _name, _value );
+        return;
+    }
+    // add this value to the classad
+    classad::Value value;
+    expr->Evaluate(value);
+    switch ( value.GetType() )
+    {
+        case classad::Value::INTEGER_VALUE:
+            int i;
+            from_string<int> ( i, string ( _value ), dec );
+            m_full_ad->Assign ( _name, i );
+            break;
+        case classad::Value::REAL_VALUE:
+            float f;
+            from_string<float> ( f, string ( _value ), dec );
+            m_full_ad->Assign ( _name, f );
+            break;
+        case classad::Value::STRING_VALUE:
+            m_full_ad->Assign ( _name, _value );
+            break;
+        default:
+            m_full_ad->AssignExpr ( _name, _value );
+            break;
+    }
+    delete expr; expr = NULL;
+
+    // our status has changed...increment for new one
+    if ( strcasecmp ( _name, ATTR_JOB_STATUS ) == 0 )
+    {
+        if ( m_job )
+        {
+	    m_job->setStatus(this->getStatus());
+            m_job->incrementSubmission ();
+        }
+    }
+}
+
+void
+LiveJobImpl::remove ( const char *_name )
+{
+	// seems we implode if we don't unchain first
+	classad::ClassAd* cp = m_full_ad->GetChainedParentAd();
+	m_full_ad->Delete ( _name );
+	m_full_ad->ChainToAd(cp);
+}
+
+const ClassAd* LiveJobImpl::getSummary () const
+{
+	ClassAd* _summary_ad = NULL;
+	if (!m_summary_ad) {
+		_summary_ad = new ClassAd();
+		_summary_ad->ResetExpr();
+		int i = 0;
+		while (NULL != ATTRS[i]) {
+			const AviaryAttribute* attr = NULL;
+			if (this->get(ATTRS[i],attr)) {
+				switch (attr->getType()) {
+					case AviaryAttribute::FLOAT_TYPE:
+						_summary_ad->Assign(ATTRS[i], atof(attr->getValue()));
+						break;
+					case AviaryAttribute::INTEGER_TYPE:
+						_summary_ad->Assign(ATTRS[i], atol(attr->getValue()));
+						break;
+					case AviaryAttribute::EXPR_TYPE:
+					case AviaryAttribute::STRING_TYPE:
+					default:
+						_summary_ad->Assign(ATTRS[i], strdup(attr->getValue()));
+				}
+			}
+		i++;
+		}
+	} else {
+		_summary_ad = m_summary_ad;
+	}
+
+	return _summary_ad;
+}
+
+const ClassAd* LiveJobImpl::getFullAd () const
+{
+    return m_full_ad;
+}
+
+/////////////////
+// ClusterJobImpl
+/////////////////
+ClusterJobImpl::ClusterJobImpl(const char* key): LiveJobImpl(key, NULL)
+{
+        m_ref_count = 0;
+}
+
+ClusterJobImpl::~ClusterJobImpl()
+{
+        dprintf ( D_FULLDEBUG, "ClusterJobImpl destroyed: key '%s'\n", m_job->getKey());
+}
+
+void
+ClusterJobImpl::incrementRef()
+{
+        m_ref_count++;
+}
+
+void
+ClusterJobImpl::decrementRef()
+{
+        --m_ref_count;
+}
+
+/////////////////
+// HistoryJobImpl
+/////////////////
+HistoryJobImpl::HistoryJobImpl ( const HistoryEntry& _he):
+	m_he(_he)
+{
+    m_job = NULL;
+    g_ownerless_clusters[_he.cluster] = _he.owner;
+    dprintf ( D_FULLDEBUG, "HistoryJobImpl created for '%d.%d'\n", _he.cluster, _he.proc );
+}
+
+HistoryJobImpl::~HistoryJobImpl ()
+{
+	dprintf ( D_FULLDEBUG, "HistoryJobImpl destroyed: key '%s'\n", m_job->getKey());
+}
+
+int HistoryJobImpl::getStatus() const
+{
+    return m_he.status;
+}
+
+int HistoryJobImpl::getCluster() const
+{
+	return m_he.cluster;
+}
+
+const char* HistoryJobImpl::getSubmissionId() const
+{
+	return m_he.submission.c_str();
+}
+
+void HistoryJobImpl::getSummary ( ClassAd& _ad ) const
+{
+	_ad.ResetExpr();
+	// use HistoryEntry data only
+	_ad.Assign(ATTR_GLOBAL_JOB_ID,m_he.id.c_str());
+	_ad.Assign(ATTR_CLUSTER_ID,m_he.cluster);
+	_ad.Assign(ATTR_PROC_ID,m_he.proc);
+	_ad.Assign(ATTR_Q_DATE,m_he.q_date);
+	_ad.Assign(ATTR_JOB_STATUS,m_he.status);
+	_ad.Assign(ATTR_ENTERED_CURRENT_STATUS,m_he.entered_status);
+	_ad.Assign(ATTR_JOB_SUBMISSION,m_he.submission.c_str());
+	_ad.Assign(ATTR_OWNER,m_he.owner.c_str());
+	_ad.Assign(ATTR_JOB_CMD,m_he.cmd.c_str());
+
+	// beyond here these may be empty so don't
+	// automatically add to summary
+	if (!m_he.args1.empty()) {
+		_ad.Assign(ATTR_JOB_ARGUMENTS1,m_he.args1.c_str());
+	}
+	if (!m_he.args2.empty()) {
+		_ad.Assign(ATTR_JOB_ARGUMENTS2,m_he.args2.c_str());
+	}
+	if (!m_he.release_reason.empty()) {
+		_ad.Assign(ATTR_RELEASE_REASON,m_he.release_reason.c_str());
+	}
+	if (!m_he.hold_reason.empty()) {
+		_ad.Assign(ATTR_HOLD_REASON,m_he.hold_reason.c_str());
+	}
+
+}
+
+// specialization: this GetFullAd has to retrieve its classad attributes
+// from the history file based on index pointers
+void
+ HistoryJobImpl::getFullAd ( ClassAd& _ad) const
+{
+    // fseek to he.start
+    // ClassAd method to deserialize from a file with "***"
+
+    FILE * hFile;
+    int end = 0;
+    int error = 0;
+    int empty = 0;
+	string _text;
+
+    // TODO: move the ClassAd/file deserialize back to HistoryFile???
+    const char* fName = m_he.file.c_str();
+    if ( ! ( hFile = safe_fopen_wrapper ( fName, "r" ) ) )
+    {
+		sprintf(_text,"unable to open history file '%s'", m_he.file.c_str());
+        dprintf ( D_ALWAYS, "%s\n",_text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+		return;
+    }
+    if ( fseek ( hFile , m_he.start , SEEK_SET ) )
+    {
+		sprintf(_text,"bad seek in '%s' at index %d", m_he.file.c_str(),m_he.start);
+        dprintf ( D_ALWAYS, "%s\n",_text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+        return;
+    }
+
+    ClassAd myJobAd ( hFile, "***", end, error, empty );
+    fclose ( hFile );
+
+	// debug logging and error to i/f for now
+	// we might not have our original history file anymore
+    if ( error )
+    {
+		sprintf(_text,"malformed ad for job '%s' in file '%s'",m_job->getKey(), m_he.file.c_str());
+        dprintf ( D_FULLDEBUG, "%s\n", _text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+		return;
+    }
+    if ( empty )
+    {
+		sprintf(_text,"empty ad for job '%s' in '%s'", m_job->getKey(),m_he.file.c_str());
+        dprintf ( D_FULLDEBUG,"%s\n", _text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+		return;
+    }
+
+	if (!_ad.CopyFrom(myJobAd)) {
+		sprintf(_text,"problem copying contents of history ClassAd for '%s'",m_job->getKey());
+		dprintf ( D_ALWAYS, "%s\n",_text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+	}
+
+}
+
+//////
+// Job
+//////
+Job::Job(const char* _key):  m_submission(NULL), m_live_job(NULL), m_history_job(NULL), m_key(_key) 
+{
+        dprintf (D_FULLDEBUG,"Job::Job of '%s'\n", m_key);
+}
+
+Job::~Job() {
+	// Destroy will be safe way to
+	// cleanup
+
+	dprintf (D_FULLDEBUG,"Job::~Job of '%s'\n", m_key);
+
+    this->decrementSubmission();
+
+	delete m_live_job;
+	delete m_history_job;
+
+	delete m_key;
+	// submissions are shared and can't be deleted here
+}
+
+void Job::setImpl (LiveJobImpl* lji)
+{
+	lji->setJob(this);
+	// probably shouldn't happen
+	if (m_live_job) {
+		delete m_live_job;
+	}
+	m_live_job = lji;
+
+	// status of a live job always has precedence
+	// so decrement if the history job got in ahead of it
+	if (m_history_job) {
+		m_status = m_history_job->getStatus();
+		m_submission->decrement(this);
+	}
+	m_status = m_live_job->getStatus();
+}
+
+void Job::setImpl (HistoryJobImpl* hji)
+{
+	hji->setJob(this);
+	// probably shouldn't happen
+	if (m_history_job) {
+		delete m_history_job;
+	}
+	m_history_job = hji;
+
+	// stay away from extra inc/decs if the live job is still doing its thing
+	if (!m_submission) {
+		m_status = m_history_job->getStatus();
+		setSubmission(m_history_job->getSubmissionId(),m_history_job->getCluster());
+	}
+
+	// call Destroy to see if we can clean up the live job
+	this->destroy();
+}
+
+void Job::setStatus(int status)
+{
+	m_status = status;
+}
+
+const char* Job::getKey() const
+{
+	return m_key;
+}
+
+void Job::set ( const char *_name, const char *_value ) {
+	if (m_live_job) {
+		m_live_job->set(_name,_value);
+	}
+	// ignore for history jobs
+}
+
+void Job::remove ( const char *_name ) {
+	if (m_live_job) {
+		m_live_job->remove(_name);
+	}
+	// ignore for history jobs
+}
+
+void Job::incrementSubmission() {
+	if (m_submission) {
+		m_submission->increment(this);
+	}
+}
+
+void Job::decrementSubmission() {
+	if (m_submission) {
+		m_submission->decrement(this);
+	}
+}
+
+void
+Job::updateSubmission ( int cluster, const char* owner )
+{
+	OwnerlessSubmissionType::const_iterator it = g_ownerless_submissions.find ( cluster );
+	if ( g_ownerless_submissions.end() != it ) {
+		SubmissionObject* submission = (*it).second;
+		submission->setOwner(owner);
+		g_ownerless_submissions.erase(cluster);
+	}
+}
+
+void
+Job::setSubmission ( const char* _subName, int cluster )
+{
+	const char* owner = NULL;
+
+	// need to see if someone has left us an owner
+	OwnerlessClusterType::const_iterator it = g_ownerless_clusters.find ( cluster );
+	if ( g_ownerless_clusters.end() != it )
+	{
+		owner = ( *it ).second.c_str() ;
+	}
+
+	SubmissionCollectionType::const_iterator element = g_submissions.find ( _subName );
+	SubmissionObject *submission;
+	if ( g_submissions.end() == element )
+	{
+		submission = new SubmissionObject ( _subName, owner );
+		g_submissions[strdup ( _subName ) ] = submission;
+	}
+	else
+	{
+		submission = ( *element ).second;
+	}
+	m_submission = submission;
+
+	m_submission->increment(this);
+
+	if (owner) {
+		// ensure that the submission has an owner
+		m_submission->setOwner ( owner );
+		g_ownerless_clusters.erase ( cluster );
+	}
+	else {
+		// add it to our list to be updated for owner
+		g_ownerless_submissions[cluster] = m_submission;
+	}
+
+}
+
+bool ClusterJobImpl::destroy()
+{
+        return m_ref_count == 0;
+}
+
+bool
+LiveJobImpl::destroy()
+{
+        return ((this->getStatus() == COMPLETED) || (this->getStatus() == REMOVED));
+}
+
+bool
+Job::destroy()
+{
+
+        bool live_destroy = (m_live_job && m_live_job->destroy());
+
+        if (m_history_job && live_destroy) {
+                // must be a proc
+                delete m_live_job;
+                m_live_job = NULL;
+                return false;
+        }
+
+        // hint to caller
+        return live_destroy;
+}
+
+// space v. speed tradeoff here - we want to keep the size of the job server down
+// since we may have to support millions of jobs in memory
+void Job::getFullAd ( ClassAd& _ad) const
+{
+	// history ads are always reconstructed
+	// so we deep copy the live job ad to be consistent
+	// on the interface
+
+	if (m_live_job) {
+		_ad = *(m_live_job->getFullAd());
+	}
+	else {
+		m_history_job->getFullAd(_ad);
+	}
+
+}
+
+// poke a hole for live job ad chaining
+const ClassAd* Job::getClassAd() const
+{
+	const ClassAd* ad_ptr = NULL;
+	if (m_live_job) {
+		ad_ptr = m_live_job->getFullAd();
+	}
+	return ad_ptr;
+
+}
+
+void Job::getSummary ( ClassAd& _ad) const
+{
+	//same thing as full ad
+	if (m_live_job) {
+		_ad = *(m_live_job->getSummary());
+	}
+	else {
+		m_history_job->getSummary(_ad);
+	}
+}
+
+int Job::getStatus() const
+{
+	return m_status;
+}
+
+JobImpl* Job::getImpl() {
+        // only will provide live job impl
+        // if it's NULL the caller needs to deal
+        return m_live_job;
+}
diff --git a/src/condor_contrib/aviary/src/Job.h b/src/condor_contrib/aviary/src/Job.h
new file mode 100644
index 0000000..77e2af6
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Job.h
@@ -0,0 +1,160 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _JOB_H
+#define _JOB_H
+
+// c++ includes
+#include <string>
+#include <map>
+#include <set>
+#include <vector>
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "condor_classad.h"
+
+// local includes
+#include "Codec.h"
+#include "HistoryFile.h"
+#include "cmpstr.h"
+
+using std::string;
+using std::map;
+using std::set;
+using std::vector;
+
+using namespace aviary::codec;
+using namespace aviary::history;
+
+namespace aviary {
+namespace query {
+
+class SubmissionObject;
+class Job;
+
+// interface class for job impls
+class JobImpl
+{
+public:
+        Job* getJob() { return m_job; }
+        void setJob(Job* _job) { m_job = _job; }
+
+protected:
+        Job* m_job;
+        JobImpl() {};
+};
+
+class ClusterJobImpl;
+
+// Job delegate that encapsulates the job active in the queue
+class LiveJobImpl: public JobImpl
+{
+    public:
+        LiveJobImpl ( const char*, ClusterJobImpl* );
+        virtual ~LiveJobImpl();
+        int getStatus () const;
+        const ClassAd* getSummary () const;
+        const ClassAd* getFullAd () const;
+        void set ( const char* , const char* );
+        bool get ( const char * , const AviaryAttribute *& ) const;
+        void remove ( const char* );
+
+        virtual bool destroy();
+
+    private:
+        ClusterJobImpl* m_parent;
+        ClassAd* m_full_ad;
+        ClassAd* m_summary_ad;
+};
+
+class ClusterJobImpl: public LiveJobImpl
+{
+public:
+        ClusterJobImpl(const char*);
+        ~ClusterJobImpl();
+        void incrementRef();
+        void decrementRef();
+        bool destroy();
+
+private:
+        int m_ref_count;
+};
+
+// Job delegate that encapsulates the archived job history
+// and can derive the attributes of its associated class ad
+class HistoryJobImpl: public JobImpl
+{
+    public:
+        HistoryJobImpl (const HistoryEntry&);
+        ~HistoryJobImpl();
+        int  getStatus () const;
+        void getSummary ( ClassAd& ) const;
+        void getFullAd ( ClassAd& ) const;
+        int  getCluster() const;
+        const char* getSubmissionId () const;
+
+    private:
+        HistoryEntry m_he;
+};
+
+// the public face of jobs
+// not for subclassing - clients (generally) shouldn't be
+// burdened with the live/history distinction
+class Job
+{
+    public:
+        Job(const char*);
+        ~Job();
+
+        const char * getKey() const;
+
+        int  getStatus () const;
+        void setStatus(int);
+
+        void getSummary (ClassAd&) const;
+        void getFullAd (ClassAd&) const;
+        const ClassAd* getClassAd() const;
+
+        void set ( const char* , const char* );
+        void remove ( const char* );
+
+        void setSubmission ( const char*, int );
+        void updateSubmission ( int, const char* );
+        void incrementSubmission();
+        void decrementSubmission();
+
+        void setImpl(LiveJobImpl*);
+        void setImpl(HistoryJobImpl*);
+        JobImpl* getImpl();
+
+        bool destroy();
+
+    private:
+        SubmissionObject *m_submission;
+        // live job to start, history job when ready
+        LiveJobImpl* m_live_job;
+        HistoryJobImpl* m_history_job;
+        const char* m_key;
+        int m_status;
+};
+
+}}
+
+#endif /* _JOB_H */
diff --git a/src/condor_contrib/aviary/src/JobServerJobLogConsumer.cpp b/src/condor_contrib/aviary/src/JobServerJobLogConsumer.cpp
new file mode 100644
index 0000000..eb8c320
--- /dev/null
+++ b/src/condor_contrib/aviary/src/JobServerJobLogConsumer.cpp
@@ -0,0 +1,226 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "condor_exprtype.h"
+#include "condor_attributes.h"
+#include "condor_astbase.h"
+#include "condor_parser.h"
+#include "condor_qmgr.h"
+#include "ClassAdLogReader.h"
+
+// local includes
+#include "JobServerJobLogConsumer.h"
+#include "Globals.h"
+#include "HistoryProcessingUtils.h"
+
+using namespace aviary::query;
+using namespace aviary::history;
+
+#define IS_JOB(key) ((key) && '0' != (key)[0])
+
+JobServerJobLogConsumer::JobServerJobLogConsumer(): m_reader(NULL)
+{ }
+
+JobServerJobLogConsumer::~JobServerJobLogConsumer()
+{ }
+
+void
+JobServerJobLogConsumer::Reset()
+{
+	// When deleting jobs, to avoid problems with jobs referencing
+	// deleted clusters, we must be sure to delete the clusters
+	// last
+
+	dprintf(D_FULLDEBUG, "JobServerJobLogConsumer::Reset() - deleting jobs and submissions\n");
+
+	for (JobCollectionType::iterator i = g_jobs.begin();
+	     g_jobs.end() != i; i++) {
+		// Skip clusters for now
+		if ('0' != (*i).second->getKey()[0]) {
+			delete (*i).second;
+			g_jobs.erase(i);
+		}
+	}
+
+	for (JobCollectionType::iterator i = g_jobs.begin();
+		  g_jobs.end() != i; i++) {
+		     delete (*i).second;
+		     g_jobs.erase(i);
+	}
+
+	for (SubmissionCollectionType::iterator i = g_submissions.begin();
+		       g_submissions.end() != i; i++) {
+			  delete (*i).second;
+			  g_submissions.erase(i);
+	}
+
+	// due to the shared use of g_jobs
+	// a JobLogReader->Reset() might cause
+	// us to reload our history
+	init_history_files();
+
+}
+
+bool
+JobServerJobLogConsumer::NewClassAd(const char *_key,
+									const char */*type*/,
+									const char */*target*/)
+{
+
+	const char* key_dup = strdup(_key);
+
+	dprintf(D_FULLDEBUG, "JobServerJobLogConsumer::NewClassAd processing _key='%s'\n", _key);
+
+	// ignore the marker
+	if (strcmp(_key,"0.0") == 0) {
+	  return true;
+	}
+
+	if ('0' == _key[0]) {
+		// Cluster ad
+		if (g_jobs.end() == g_jobs.find(_key)) {
+			Job* new_cluster_job = new Job(key_dup);
+			new_cluster_job->setImpl(new ClusterJobImpl(key_dup));
+			g_jobs[key_dup] = new_cluster_job;
+		}
+	} else {
+		// Proc ad
+
+		// first see if some other proc job is here
+		// ie history
+		if (g_jobs.end() != g_jobs.find(_key)) {
+			return true;
+		}
+
+		PROC_ID proc = getProcByString(_key);
+		MyString cluster_key;
+
+		cluster_key.sprintf("0%d.-1", proc.cluster);
+
+		const char *cluster_dup = cluster_key.StrDup();
+		JobCollectionType::const_iterator element = g_jobs.find(cluster_dup);
+        ClusterJobImpl* cluster_impl = NULL;
+
+		if (g_jobs.end() == element) {
+			// didn't find an existing cluster job so create a new one
+			Job* new_cluster_job = new Job(cluster_dup);
+            cluster_impl = new ClusterJobImpl(cluster_dup);
+            new_cluster_job->setImpl(cluster_impl);
+            g_jobs[cluster_dup] = new_cluster_job;
+		} else {
+			// found an existing cluster job - we'll assume it is the cluster parent
+			cluster_impl = static_cast<ClusterJobImpl*>((*element).second->getImpl());
+		}
+
+        Job* new_proc_job = new Job(key_dup);
+        new_proc_job->setImpl(new LiveJobImpl(key_dup, cluster_impl));
+        g_jobs[key_dup] = new_proc_job;
+
+	}
+
+	return true;
+}
+
+bool
+JobServerJobLogConsumer::DestroyClassAd(const char *_key)
+{
+
+	// ignore the marker
+	if (strcmp(_key,"0.0") == 0) {
+	  return true;
+	}
+
+   dprintf ( D_FULLDEBUG, "JobServerJobLogConsumer::DestroyClassAd - key '%s'\n", _key);
+    JobCollectionType::iterator g_element = g_jobs.find(_key);
+
+    if (g_jobs.end() == g_element) {
+        dprintf(D_ALWAYS,
+                "error reading %s: no such job found for key '%s'\n",
+                m_reader->GetClassAdLogFileName(), _key);
+        return false;
+    }
+
+    Job* job = (*g_element).second;
+    // Destroy will figure out the submission decrement
+    if (job->destroy()) {
+            delete job;
+            job = NULL;
+            g_jobs.erase(g_element);
+    }
+
+    return true;
+}
+
+bool
+JobServerJobLogConsumer::SetAttribute(const char *_key,
+									  const char *_name,
+									  const char *_value)
+{
+
+	// ignore the marker
+	if (strcmp(_key,"0.0") == 0) {
+	  return true;
+	}
+
+	if (0 == strcmp(_name,"NextClusterNum") ) {
+		// skip over these
+		//dprintf(D_FULLDEBUG, "%s: skipping job entry '%s' for '%s = %s'\n",
+		//	m_reader->GetJobLogFileName(), _key, _name, _value);
+		return true;
+	}
+
+    JobCollectionType::const_iterator g_element = g_jobs.find(_key);
+
+	if (g_jobs.end() == g_element) {
+		dprintf(D_ALWAYS,
+				"error reading %s : no such job '%s' for '%s = %s'\n",
+				m_reader->GetClassAdLogFileName(),
+				_key, _name, _value);
+		return false;
+	}
+
+	(*g_element).second->set(_name, _value);
+
+	return true;
+}
+
+bool
+JobServerJobLogConsumer::DeleteAttribute(const char *_key,
+										 const char *_name)
+{
+	// ignore the marker
+	if (strcmp(_key,"0.0") == 0) {
+	  return true;
+	}
+
+	JobCollectionType::const_iterator g_element = g_jobs.find(_key);
+
+	if (g_jobs.end() == g_element) {
+		dprintf(D_ALWAYS,
+				"error reading %s: no such job '%s' for 'delete %s'\n",
+                m_reader->GetClassAdLogFileName(), _key, _name);
+		return false;
+	}
+
+	(*g_element).second->remove(_name);
+
+	return true;
+}
diff --git a/src/condor_contrib/aviary/src/JobServerJobLogConsumer.h b/src/condor_contrib/aviary/src/JobServerJobLogConsumer.h
new file mode 100644
index 0000000..22703ed
--- /dev/null
+++ b/src/condor_contrib/aviary/src/JobServerJobLogConsumer.h
@@ -0,0 +1,62 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _JOBSERVERJOBLOGCONSUMER_H
+#define _JOBSERVERJOBLOGCONSUMER_H
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "ClassAdLogReader.h"
+
+// local includes
+#include "Job.h"
+#include "SubmissionObject.h"
+
+// c++ includes
+#include <string>
+#include <map>
+#include <set>
+
+using namespace std;
+
+class JobServerJobLogConsumer: public ClassAdLogConsumer
+{
+public:
+	JobServerJobLogConsumer();
+	~JobServerJobLogConsumer();
+
+	void Reset();
+	bool NewClassAd(const char *key,
+					const char *type,
+					const char *target);
+	bool DestroyClassAd(const char *key);
+	bool SetAttribute(const char *key,
+					  const char *name,
+					  const char *value);
+	bool DeleteAttribute(const char *key,
+						 const char *name);
+    void SetJobLogReader(ClassAdLogReader *_reader) { m_reader = _reader; }
+
+
+private:
+
+    ClassAdLogReader *m_reader;
+};
+
+#endif /* _JOBSERVERJOBLOGCONSUMER_H */
diff --git a/src/condor_contrib/aviary/src/JobServerObject.cpp b/src/condor_contrib/aviary/src/JobServerObject.cpp
new file mode 100644
index 0000000..ee76024
--- /dev/null
+++ b/src/condor_contrib/aviary/src/JobServerObject.cpp
@@ -0,0 +1,374 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_attributes.h"
+#include "condor_debug.h"
+#include "condor_qmgr.h"
+#include "set_user_priv_from_ad.h"
+#include "stat_info.h"
+#include "stl_string_utils.h"
+
+// C++ includes
+// enable for debugging classad to ostream
+// watch out for unistd clash
+//#include <sstream>
+
+//local includes
+#include "JobServerObject.h"
+#include "AviaryConversionMacros.h"
+#include "AviaryUtils.h"
+#include "Codec.h"
+#include "JobServerJobLogConsumer.h"
+#include "Globals.h"
+
+using namespace std;
+using namespace aviary::query;
+using namespace aviary::util;
+using namespace aviary::codec;
+
+JobServerObject* JobServerObject::m_instance = NULL;
+
+JobServerObject::JobServerObject ()
+{
+	m_name = getScheddName();
+	m_pool = getPoolName();
+	m_codec = new BaseCodec;
+}
+
+JobServerObject::~JobServerObject()
+{
+	delete m_codec;
+}
+
+JobServerObject* JobServerObject::getInstance()
+{
+    if (!m_instance) {
+        m_instance = new JobServerObject();
+    }
+    return m_instance;
+}
+
+void
+JobServerObject::update ( const ClassAd &ad )
+{
+    MGMT_DECLARATIONS;
+
+    m_stats.Pool = getPoolName();
+    STRING ( CondorPlatform );
+    STRING ( CondorVersion );
+    TIME_INTEGER ( DaemonStartTime );
+//  TIME_INTEGER(JobQueueBirthdate);
+    STRING ( Machine );
+//  INTEGER(MaxJobsRunning);
+    INTEGER ( MonitorSelfAge );
+    DOUBLE ( MonitorSelfCPUUsage );
+    DOUBLE ( MonitorSelfImageSize );
+    INTEGER ( MonitorSelfRegisteredSocketCount );
+    INTEGER ( MonitorSelfResidentSetSize );
+    TIME_INTEGER ( MonitorSelfTime );
+    STRING ( MyAddress );
+    //TIME_INTEGER(MyCurrentTime);
+    STRING ( Name );
+//  INTEGER(NumUsers);
+    STRING ( PublicNetworkIpAddr );
+//  INTEGER(TotalHeldJobs);
+//  INTEGER(TotalIdleJobs);
+//  INTEGER(TotalJobAds);
+//  INTEGER(TotalRemovedJobs);
+//  INTEGER(TotalRunningJobs);
+
+    m_stats.System = m_stats.Machine;
+}
+
+Job*
+getValidKnownJob(const char* key, AviaryStatus &_status) {
+
+	// #1: is it even a proper "cluster.proc"?
+	PROC_ID id = getProcByString(key);
+	if (id.cluster < 0 || id.proc < 0) {
+		sprintf (_status.text, "Invalid job id '%s'",key);
+		dprintf(D_FULLDEBUG, "%s\n", _status.text.c_str());
+		_status.type = AviaryStatus::FAIL;
+		return NULL;
+	}
+
+	// #2 is it anywhere in our job map?
+    JobCollectionType::const_iterator element = g_jobs.find(key);
+    if ( g_jobs.end() == element ) {
+		sprintf (_status.text, "Unknown local job id '%s'",key);
+		dprintf(D_FULLDEBUG, "%s\n", _status.text.c_str());
+		_status.type = AviaryStatus::NO_MATCH;
+		return NULL;
+    }
+
+	return (*element).second;
+}
+
+bool JobServerObject::getStatus(const char* key, int& job_status, AviaryStatus &_status) {
+	Job* job = NULL;
+	if (!(job = getValidKnownJob(key,_status))) {
+		return false;
+	}
+
+	job_status = job->getStatus();
+
+	_status.type = AviaryStatus::A_OK;
+	return true;
+}
+
+bool JobServerObject::getSummary(const char* key, JobSummaryFields& _summary, AviaryStatus &_status) {
+	Job* job = NULL;
+	if (!(job = getValidKnownJob(key,_status))) {
+		return false;
+	}
+
+    ClassAd classAd;
+    job->getSummary ( classAd );
+    // little cheat for ad problems with history lookups
+    string str;
+    if ( classAd.LookupString("JOB_AD_ERROR", str) )
+    {
+		sprintf(_status.text,"Error obtaining ClassAd for job '%s'; ",key);
+		_status.text += str;
+		dprintf(D_ALWAYS,"%s\n",_status.text.c_str());
+        return false;
+    }
+
+	// return the limited attributes
+    classAd.LookupString(ATTR_JOB_CMD,_summary.cmd);
+	classAd.LookupString(ATTR_JOB_ARGUMENTS1,_summary.args1);
+	classAd.LookupString(ATTR_JOB_ARGUMENTS2,_summary.args2);
+	classAd.LookupString(ATTR_HOLD_REASON,_summary.hold_reason);
+	classAd.LookupString(ATTR_RELEASE_REASON,_summary.release_reason);
+	classAd.LookupString(ATTR_REMOVE_REASON,_summary.remove_reason);
+	classAd.LookupString(ATTR_JOB_SUBMISSION,_summary.submission_id);
+	classAd.LookupString(ATTR_OWNER,_summary.owner);
+	classAd.LookupInteger(ATTR_Q_DATE,_summary.queued);
+	classAd.LookupInteger(ATTR_ENTERED_CURRENT_STATUS,_summary.last_update);
+	_summary.status = job->getStatus();
+
+	_status.type = AviaryStatus::A_OK;
+    return true;
+}
+
+bool
+JobServerObject::getJobAd ( const char* key, AttributeMapType& _map, AviaryStatus &_status)
+{
+	Job* job = NULL;
+	if (!(job = getValidKnownJob(key,_status))) {
+		return false;
+	}
+    // call Job::getFullAd and use utils to populate the map
+    ClassAd classAd;
+    job->getFullAd ( classAd );
+    // little cheat for ad problems with history lookups
+    string str;
+    if ( classAd.LookupString("JOB_AD_ERROR", str) )
+    {
+		sprintf(_status.text,"Error obtaining ClassAd for job '%s'; ",key);
+		_status.text += str;
+		dprintf(D_ALWAYS,"%s\n",_status.text.c_str());
+    }
+
+    // return all the attributes in the ClassAd
+    if ( !m_codec->classAdToMap ( classAd, _map  ) )
+    {
+		sprintf(_status.text,"Error mapping info for job '%s'; ",key);
+		dprintf(D_ALWAYS,"%s\n",_status.text.c_str());
+        return false;
+    }
+
+    // debug
+//    if (DebugFlags & D_FULLDEBUG) {
+//        classAd.dPrint(D_FULLDEBUG|D_NOHEADER);
+//        std::ostringstream oss;
+//        oss << _map;
+//        dprintf(D_FULLDEBUG|D_NOHEADER, oss.str().c_str());
+//    }
+
+	_status.type = AviaryStatus::A_OK;
+    return true;
+}
+
+bool
+JobServerObject::fetchJobData(const char* key,
+					   const UserFileType ftype,
+					   std::string& fname,
+					   int max_bytes,
+					   bool from_end,
+					   int& fsize,
+					   std::string &data,
+					   AviaryStatus &_status)
+{
+	int32_t start;
+	int32_t end;
+	priv_state prev_priv_state;
+	int fd = -1;
+	int count;
+	int length;
+	int whence;
+	char *buffer;
+	bool fetched;
+	Job* job = NULL;
+
+	if (!(job =getValidKnownJob(key,_status))) {
+		return false;
+	}
+
+
+	ClassAd ad;
+	string str;
+	job->getFullAd ( ad );
+	if ( ad.LookupString("JOB_AD_ERROR", str)  ) {
+		sprintf(_status.text,"Error checking ClassAd for user priv on job '%s'; ",key);
+		_status.text += str;
+		dprintf(D_ALWAYS,"%s\n",_status.text.c_str());
+		return false;
+	}
+	
+	// find out what the actual file is from classad lookup
+	switch (ftype) {
+		case ERR:
+			if ( !ad.LookupString(ATTR_JOB_ERROR, fname)  ) {
+				sprintf (_status.text,  "No error file for job '%s'",key);
+				dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+				return false;
+			}
+			break;
+		case LOG:
+			if ( !ad.LookupString(ATTR_ULOG_FILE, fname)  ) {
+				sprintf (_status.text,  "No log file for job '%s'",key);
+				dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+				return false;
+			}
+			break;
+		case OUT:
+			if ( !ad.LookupString(ATTR_JOB_OUTPUT, fname)  ) {
+				sprintf (_status.text,  "No output file for job '%s'",key);
+				dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+				return false;
+			}
+			break;
+		default:
+			// ruh-roh...asking for a file type we don't know about
+			sprintf (_status.text,  "Unknown file type for job '%s'",key);
+			dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+			return false;
+	}
+	
+	StatInfo the_file(fname.c_str());
+	if (the_file.Error()) {
+		sprintf (_status.text, "Error opening requested file '%s', error %d",fname.c_str(),the_file.Errno());
+		dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+		return false;
+	}
+
+	fsize = the_file.GetFileSize();
+
+	// we calculate these based on file size
+	if (from_end) {
+		end = fsize;
+		start = end - max_bytes;
+	}
+	else {
+		start = 0;
+		end = max_bytes;
+	}
+
+	// start >= 0, end >= 0 :: lseek(start, SEEK_SET), read(end - start)
+	//  end < start :: error, attempt to read backwards
+	// start >= 0, end < 0 :: error, don't know length
+	// start < 0, end > 0 :: attempt to read off end of file, end = 0
+	// start < 0, end <= 0 :: lseek(start, SEEK_END), read(abs(start - end))
+	//  end < start :: error, attempt to read backwards
+
+	// TODO: redundant checks given above
+	if ((start >= 0 && end >= 0 && end < start) ||
+		(start >= 0 && end < 0) ||
+		(start < 0 && end <= 0 && end < start)) {
+		_status.text = "Invalid start and end values";
+		return false;
+	}
+
+	// Instead of reading off the end of the file, read to the
+	// end of it
+	if (start < 0 && end > 0) {
+		end = 0;
+	}
+
+	if (start >= 0) {
+		whence = SEEK_SET;
+		length = end - start;
+	} else {
+		whence = SEEK_END;
+		length = abs(start - end);
+	}
+
+	// TODO: Sanity check that length isn't too big?
+	buffer = new char[length + 1];
+
+	prev_priv_state = set_user_priv_from_ad(ad);
+
+	if (-1 != (fd = safe_open_wrapper(fname.c_str(),
+									  O_RDONLY | _O_BINARY,
+									  0))) {
+			// If we are seeking from the end of the file, it is
+			// possible that we will try to seek off the front of the
+			// file. To avoid this, we check the file's size and set
+			// the max length that we are able to seek
+		if (SEEK_END == whence) {
+			struct stat buf;
+			if (-1 != fstat(fd, &buf)) {
+				if (buf.st_size < abs(start)) {
+					start = -buf.st_size;
+				}
+			} // if fstat fails, we just continue having made an effort
+		}
+
+		if (-1 != lseek(fd, start, whence)) {				
+			if (-1 == (count = full_read(fd, buffer, length))) {
+				_status.text = "Failed to read from " + fname;
+				fetched = false;
+			} else {
+					// Terminate the string.
+				buffer[count] = '\0';
+
+				data = buffer;
+				fetched = true;
+			}
+
+			close(fd); // assume closed on failure?
+		} else {
+			_status.text = "Failed to seek in " + fname;
+			fetched = false;
+		}
+	} else {
+		_status.text = "Failed to open " + fname;
+		fetched = false;
+	}
+
+	set_priv(prev_priv_state);
+
+	delete [] buffer;
+
+	if (fetched) {
+		_status.type = AviaryStatus::A_OK;
+	}
+	return fetched;
+}
diff --git a/src/condor_contrib/aviary/src/JobServerObject.h b/src/condor_contrib/aviary/src/JobServerObject.h
new file mode 100644
index 0000000..d305270
--- /dev/null
+++ b/src/condor_contrib/aviary/src/JobServerObject.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _JOBSERVEROBJECT_H
+#define _JOBSERVEROBJECT_H
+
+// condor includes
+#include "condor_common.h"
+#include "condor_classad.h"
+
+// local includes
+#include "Codec.h"
+
+struct a;
+struct a;
+struct a;
+struct a;
+using namespace std;
+using namespace compat_classad;
+using namespace aviary::codec;
+
+namespace aviary {
+namespace query {
+
+struct JobServerStats {
+    // Properties
+    string      CondorPlatform;
+    string      CondorVersion;
+    int64_t     DaemonStartTime;
+    string      Pool;
+    string      System;
+    uint32_t    MaxJobsRunning;
+    string      Machine;
+    string      MyAddress;
+    string      Name;
+	string		PublicNetworkIpAddr;
+
+    // Statistics
+    uint32_t    MonitorSelfAge;
+    double      MonitorSelfCPUUsage;
+    double      MonitorSelfImageSize;
+    uint32_t    MonitorSelfRegisteredSocketCount;
+    uint32_t    MonitorSelfResidentSetSize;
+    int64_t     MonitorSelfTime;
+    uint32_t    NumUsers;
+};
+
+enum UserFileType {
+	ERR = 0,
+	LOG = 1,
+	OUT = 2
+};
+
+struct JobSummaryFields {
+	int status;
+	string cmd;
+	string args1;
+	string args2;
+	int queued;
+	int last_update;
+	string hold_reason;
+	string release_reason;
+	string remove_reason;
+	string submission_id;
+	string owner;
+};
+
+typedef pair<const char*,JobSummaryFields*> JobSummaryPair;
+typedef vector<JobSummaryPair> JobSummaryPairCollection;
+
+class JobServerObject
+{
+public:
+
+	void update(const ClassAd &ad);
+
+	bool getStatus(const char* id, int& status, AviaryStatus &_status);
+	bool getSummary(const char* key, JobSummaryFields& _summary, AviaryStatus &_status);
+	bool getJobAd(const char* id, AttributeMapType& _map, AviaryStatus &_status);
+	bool fetchJobData(const char* key,
+					   const UserFileType ftype,
+					   std::string& fname,
+					   int max_bytes,
+					   bool from_end,
+					   int& fsize,
+					   std::string &data,
+			           AviaryStatus &_status);
+
+    ~JobServerObject();
+	static JobServerObject* getInstance();
+
+	const char* getName() { return m_name.c_str(); }
+	const char* getPool() { return m_pool.c_str(); }
+
+private:
+    JobServerObject();
+	JobServerObject(JobServerObject const&);
+	JobServerObject& operator=(JobServerObject const&);
+
+	string m_name;
+	string m_pool;
+	JobServerStats m_stats;
+	Codec* m_codec;
+
+	static JobServerObject* m_instance;
+
+};
+
+}} /* aviary::query */
+
+#endif /* _JOBSERVEROBJECT_H */
diff --git a/src/condor_contrib/aviary/src/PROC_ID_comparator.cpp b/src/condor_contrib/aviary/src/PROC_ID_comparator.cpp
new file mode 100644
index 0000000..6eb94ba
--- /dev/null
+++ b/src/condor_contrib/aviary/src/PROC_ID_comparator.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "proc.h"
+
+// local includes
+#include "PROC_ID_comparator.h"
+
+using namespace aviary::util;
+
+bool
+PROC_ID_comparator::operator()(const std::string &lhs, const std::string &rhs)
+{
+	PROC_ID lhs_id, rhs_id;
+
+		// !!! The EXCEPT macro is "#define EXCEPT \", so we must
+		// !!! enclose it in { }'s else we'll always EXCEPT
+
+	if (!StrToProcId(lhs.c_str(), lhs_id)) { EXCEPT("Invalid LHS PROC_ID %s", lhs.c_str()); }
+	if (!StrToProcId(rhs.c_str(), rhs_id)) { EXCEPT("Invalid RHS PROC_ID %s", rhs.c_str()); }
+
+	return
+		(lhs_id.cluster < rhs_id.cluster) ||
+		((lhs_id.cluster == rhs_id.cluster) && (lhs_id.proc < rhs_id.proc));
+}
diff --git a/src/condor_contrib/aviary/src/PROC_ID_comparator.h b/src/condor_contrib/aviary/src/PROC_ID_comparator.h
new file mode 100644
index 0000000..4a45d1c
--- /dev/null
+++ b/src/condor_contrib/aviary/src/PROC_ID_comparator.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _PROC_ID_COMPARATOR_H
+#define _PROC_ID_COMPARATOR_H
+
+#include <string>
+
+namespace aviary {
+namespace util {
+
+struct PROC_ID_comparator
+{
+	bool operator()(const std::string &lhs, const std::string &rhs);
+};
+
+}};
+
+#endif /* _PROC_ID_COMPARATOR_H */
diff --git a/src/condor_contrib/aviary/src/SchedulerObject.cpp b/src/condor_contrib/aviary/src/SchedulerObject.cpp
new file mode 100644
index 0000000..5f48c97
--- /dev/null
+++ b/src/condor_contrib/aviary/src/SchedulerObject.cpp
@@ -0,0 +1,363 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_attributes.h"
+#include "condor_debug.h"
+#include "condor_qmgr.h"
+#include "../condor_schedd.V6/scheduler.h"
+
+// local includes
+#include "AviaryUtils.h"
+#include "AviaryConversionMacros.h"
+#include "SchedulerObject.h"
+#include "Codec.h"
+
+// Global Scheduler object, used for needReschedule
+extern Scheduler scheduler;
+extern char * Name;
+
+using namespace aviary::job;
+using namespace aviary::util;
+using namespace aviary::codec;
+
+SchedulerObject* SchedulerObject::m_instance = NULL;
+
+SchedulerObject::SchedulerObject()
+{
+    m_pool = getPoolName();
+	m_name = getScheddName();
+    m_codec = new BaseCodec();
+}
+
+SchedulerObject::~SchedulerObject()
+{
+	delete m_codec;
+}
+
+SchedulerObject* SchedulerObject::getInstance()
+{
+    if (!m_instance) {
+        m_instance = new SchedulerObject();
+    }
+    return m_instance;
+}
+
+void
+SchedulerObject::update(const ClassAd &ad)
+{
+	MGMT_DECLARATIONS;
+
+	m_stats.Pool = getPoolName();
+	STRING(CondorPlatform);
+	STRING(CondorVersion);
+	TIME_INTEGER(DaemonStartTime);
+	TIME_INTEGER(JobQueueBirthdate);
+	STRING(Machine);
+	INTEGER(MaxJobsRunning);
+	INTEGER(MonitorSelfAge);
+	DOUBLE(MonitorSelfCPUUsage);
+	DOUBLE(MonitorSelfImageSize);
+	INTEGER(MonitorSelfRegisteredSocketCount);
+	INTEGER(MonitorSelfResidentSetSize);
+	TIME_INTEGER(MonitorSelfTime);
+	STRING(MyAddress);
+    //TIME_INTEGER(MyCurrentTime);
+	STRING(Name);
+	INTEGER(NumUsers);
+	STRING(MyAddress);
+	INTEGER(TotalHeldJobs);
+	INTEGER(TotalIdleJobs);
+	INTEGER(TotalJobAds);
+	INTEGER(TotalRemovedJobs);
+	INTEGER(TotalRunningJobs);
+	m_stats.System = m_stats.Machine;
+
+	// debug
+	if (DebugFlags & D_FULLDEBUG) {
+		const_cast<ClassAd*>(&ad)->dPrint(D_FULLDEBUG|D_NOHEADER);
+	}
+}
+
+
+bool
+SchedulerObject::submit(AttributeMapType &jobAdMap, std::string &id, std::string &text)
+{
+	int cluster;
+	int proc;
+
+    if (!m_codec) {
+        text = "Codec has not been initialized";
+        return false;
+    }
+
+	// our mandatory set of attributes for a submit
+	const char* required[] = {
+				ATTR_JOB_CMD,
+				ATTR_REQUIREMENTS,
+				ATTR_OWNER,
+				ATTR_JOB_IWD,
+				NULL
+				};
+
+		// 1. Create transaction
+	BeginTransaction();
+
+		// 2. Create cluster
+	if (-1 == (cluster = NewCluster())) {
+		AbortTransaction();
+		text = "Failed to create new cluster";
+		return false;
+	}
+
+		// 3. Create proc
+	if (-1 == (proc = NewProc(cluster))) {
+		AbortTransaction();
+		text = "Failed to create new proc";
+		return false;
+	}
+
+		// 4. Submit job ad
+
+		// Schema: (vanilla job)
+		// Schedd demands - Owner, JobUniverse
+		// To run - JobStatus, Requirements
+
+		// Schedd excepts if no Owner
+		// Schedd prunes on startup if no Owner or JobUniverse
+		// Schedd won't run job without JobStatus
+		// Job cannot match without Requirements
+		// Shadow rejects jobs without an Iwd
+		// Shadow: Job has no CondorVersion, assuming pre version 6.3.3
+		// Shadow: Unix Vanilla job is pre version 6.3.3, setting 'TransferFiles = "NEVER"'
+		// Starter won't run job without Cmd
+		// Starter needs a valid Owner (local account name) if not using nobody
+		// condor_q requires ClusterId (int), ProcId (int), QDate (int), RemoteUserCpu (float), JobStatus (int), JobPrio (int), ImageSize (int), Owner (str) and Cmd (str)
+
+		// Schema: (vm job)
+		// ShouldTransferFiles - unset by default, must be set
+
+	ClassAd ad;
+	int universe;
+
+    // ShouldTransferFiles - unset by default, must be set
+    // shadow will try to setup local transfer sandbox otherwise
+    // without good priv
+    ad.Assign(ATTR_SHOULD_TRANSFER_FILES, "NO");
+
+	if (!m_codec->mapToClassAd(jobAdMap, ad)) {
+		AbortTransaction();
+		text = "Failed to parse job ad";
+		return false;
+	}
+
+	std::string missing;
+	if (!checkRequiredAttrs(ad, required, missing)) {
+		AbortTransaction();
+		text = "Job ad is missing required attributes: " + missing;
+		return false;
+	}
+
+		// EARLY SET: These attribute are set early so the incoming ad
+		// has a change to override them.
+	::SetAttribute(cluster, proc, ATTR_JOB_STATUS, "1"); // 1 = idle
+
+		// Junk that condor_q wants, but really shouldn't be necessary
+	::SetAttribute(cluster, proc, ATTR_JOB_REMOTE_USER_CPU, "0.0"); // float
+	::SetAttribute(cluster, proc, ATTR_JOB_PRIO, "0");              // int
+	::SetAttribute(cluster, proc, ATTR_IMAGE_SIZE, "0");            // int
+
+	if (!ad.LookupInteger(ATTR_JOB_UNIVERSE, universe)) {
+		char* uni_str = param("DEFAULT_UNIVERSE");
+		if (!uni_str) {
+			universe = CONDOR_UNIVERSE_VANILLA;
+		}
+		else {
+			universe = CondorUniverseNumber(uni_str);
+		}
+		::SetAttributeInt(cluster, proc, ATTR_JOB_UNIVERSE, universe );
+	}
+	// more stuff - without these our idle stats are whack
+	if ( universe != CONDOR_UNIVERSE_MPI && universe != CONDOR_UNIVERSE_PVM ) {
+		::SetAttribute(cluster, proc, ATTR_MAX_HOSTS, "1");              // int
+		::SetAttribute(cluster, proc, ATTR_MIN_HOSTS, "1");            // int
+	}
+	::SetAttribute(cluster, proc, ATTR_CURRENT_HOSTS, "0"); // int
+
+	ExprTree *expr;
+	const char *name;
+	std::string value;
+	ad.ResetExpr();
+	while (ad.NextExpr(name,expr)) {
+
+			// All these extra lookups are horrible. They have to
+			// be there because the ClassAd may have multiple
+			// copies of the same attribute name! This means that
+			// the last attribute with a given name will set the
+			// value, but the last attribute tends to be the
+			// attribute with the oldest (wrong) value. How
+			// annoying is that!
+		if (!(expr = ad.Lookup(name))) {
+			dprintf(D_ALWAYS, "Failed to lookup %s\n", name);
+
+			AbortTransaction();
+			text = "Failed to parse job ad attribute";
+			return false;
+		}
+
+        value = ExprTreeToString(expr);
+        ::SetAttribute(cluster, proc, name, value.c_str());
+	}
+
+		// LATE SET: These attributes are set late, after the incoming
+		// ad, so they override whatever the incoming ad set.
+	char buf[22]; // 22 is max size for an id, 2^32 + . + 2^32 + \0
+	snprintf(buf, 22, "%d", cluster);
+	::SetAttribute(cluster, proc, ATTR_CLUSTER_ID, buf);
+	snprintf(buf, 22, "%d", proc);
+	::SetAttribute(cluster, proc, ATTR_PROC_ID, buf);
+	snprintf(buf, 22, "%d", time(NULL));
+	::SetAttribute(cluster, proc, ATTR_Q_DATE, buf);
+
+		// Could check for some invalid attributes, e.g
+		//  JobUniverse <= CONDOR_UNIVERSE_MIN or >= CONDOR_UNIVERSE_MAX
+	
+		// 5. Commit transaction
+	CommitTransaction();
+
+
+		// 6. Reschedule
+	scheduler.needReschedule();
+
+
+		// 7. Return identifier
+		// TODO: dag ids?
+	MyString tmp;
+	//tmp.sprintf("%s#%d.%d", Name, cluster, proc);
+	// we have other API compositions for job id and submission id
+	// so let's return raw cluster.proc
+	tmp.sprintf("%d.%d", cluster, proc);
+	id = tmp.Value();
+
+	return true;
+}
+
+bool
+SchedulerObject::setAttribute(std::string key,
+							  std::string name,
+							  std::string value,
+							  std::string &text)
+{
+	PROC_ID id = getProcByString(key.c_str());
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "SetAttribute: Failed to parse id: %s\n", key.c_str());
+		text = "Invalid Id";
+		return false;
+	}
+
+	if (!isValidAttributeName(name,text)) {
+		return false;
+	}
+
+		// All values are strings in the eyes of
+		// ::SetAttribute. Their type is inferred when read from
+		// the ClassAd log. It is important that the incoming
+		// value is properly quoted to differentiate between EXPR
+		// and STRING.
+	if (::SetAttribute(id.cluster,
+					   id.proc,
+					   name.c_str(),
+					   value.c_str())) {
+		text = "Failed to set attribute " + name + " to " + value;
+		return false;
+	}
+
+	return true;
+}
+
+bool
+SchedulerObject::hold(std::string key, std::string &reason, std::string &text)
+{
+	PROC_ID id = getProcByString(key.c_str());
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "Hold: Failed to parse id: %s\n", key.c_str());
+		text = "Invalid Id";
+		return false;
+	}	
+
+	if (!holdJob(id.cluster,
+				 id.proc,
+				 reason.c_str(),
+				 true, // Always perform this action within a transaction
+				 true, // Always notify the shadow of the hold
+				 false, // Do not email the user about this action
+				 false, // Do not email admin about this action
+				 false // This is not a system related (internal) hold
+				 )) {
+		text = "Failed to hold job";
+		return false;
+	}
+
+	return true;
+}
+
+bool
+SchedulerObject::release(std::string key, std::string &reason, std::string &text)
+{
+	PROC_ID id = getProcByString(key.c_str());
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "Release: Failed to parse id: %s\n", key.c_str());
+		text = "Invalid Id";
+		return false;
+	}
+
+	if (!releaseJob(id.cluster,
+					id.proc,
+					reason.c_str(),
+					true, // Always perform this action within a transaction
+					false, // Do not email the user about this action
+					false // Do not email admin about this action
+					)) {
+		text = "Failed to release job";
+		return false;
+	}
+
+	return true;
+}
+
+bool
+SchedulerObject::remove(std::string key, std::string &reason, std::string &text)
+{
+	PROC_ID id = getProcByString(key.c_str());
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "Remove: Failed to parse id: %s\n", key.c_str());
+		text = "Invalid Id";
+		return false;
+	}	
+
+	if (!abortJob(id.cluster,
+				  id.proc,
+				  reason.c_str(),
+				  true // Always perform within a transaction
+				  )) {
+		text = "Failed to remove job";
+		return false;
+	}
+
+	return true;
+}
diff --git a/src/condor_contrib/aviary/src/SchedulerObject.h b/src/condor_contrib/aviary/src/SchedulerObject.h
new file mode 100644
index 0000000..670218e
--- /dev/null
+++ b/src/condor_contrib/aviary/src/SchedulerObject.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SCHEDULEROBJECT_H
+#define _SCHEDULEROBJECT_H
+
+// condor includes
+#include "condor_common.h"
+#include "condor_classad.h"
+
+// local includes
+#include "Codec.h"
+#include "AviaryUtils.h"
+
+using namespace std;
+using namespace aviary::util;
+using namespace aviary::codec;
+
+namespace aviary {
+namespace job {
+
+struct SchedulerStats {
+    // Properties
+    string      CondorPlatform;
+    string      CondorVersion;
+    int64_t     DaemonStartTime;
+    string      Pool;
+    string      System;
+    int64_t     JobQueueBirthdate;
+    uint32_t    MaxJobsRunning;
+    string      Machine;
+    string      MyAddress;
+    string      Name;
+
+    // Statistics
+    uint32_t    MonitorSelfAge;
+    double      MonitorSelfCPUUsage;
+    double      MonitorSelfImageSize;
+    uint32_t    MonitorSelfRegisteredSocketCount;
+    uint32_t    MonitorSelfResidentSetSize;
+    int64_t     MonitorSelfTime;
+    uint32_t    NumUsers;
+    uint32_t    TotalHeldJobs;
+    uint32_t    TotalIdleJobs;
+    uint32_t    TotalJobAds;
+    uint32_t    TotalRemovedJobs;
+    uint32_t    TotalRunningJobs;
+};
+
+class SchedulerObject {
+public:
+
+
+	void update(const ClassAd &ad);
+	bool submit(AttributeMapType& jobAdMap, string& id, string& text);
+	bool setAttribute(string id,
+                      string name,
+                      string value,
+                      string &text);
+	bool hold(string id, string &reason, string &text);
+	bool release(string id, string &reason, string &text);
+	bool remove(string id, string &reason, string &text);
+
+    static SchedulerObject* getInstance();
+
+	const char* getPool() {return m_pool.c_str(); }
+	const char* getName() {return m_name.c_str(); }
+
+	~SchedulerObject();
+
+private:
+    SchedulerObject();
+	SchedulerObject(SchedulerObject const&);
+	SchedulerObject& operator=(SchedulerObject const&);
+
+    string m_pool;
+    string m_name;
+	Codec* m_codec;
+    SchedulerStats m_stats;
+    static SchedulerObject* m_instance;
+
+};
+
+
+}} /* aviary::job */
+
+#endif /* _SCHEDULEROBJECT_H */
diff --git a/src/condor_contrib/aviary/src/SubmissionObject.cpp b/src/condor_contrib/aviary/src/SubmissionObject.cpp
new file mode 100644
index 0000000..32d19f2
--- /dev/null
+++ b/src/condor_contrib/aviary/src/SubmissionObject.cpp
@@ -0,0 +1,221 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_debug.h"
+#include "condor_attributes.h"
+#include "proc.h"
+
+// local includes
+#include "SubmissionObject.h"
+#include "JobServerObject.h"
+#include "AviaryUtils.h"
+
+using namespace std;
+using namespace aviary::query;
+using namespace aviary::codec;
+using namespace aviary::util;
+
+SubmissionObject::SubmissionObject (
+                                     const char *_name,
+                                     const char *_owner ) :
+        ownerSet ( false )
+{
+	m_name = _name;
+    if ( _owner )
+    {
+        setOwner ( _owner );
+    }
+    else
+    {
+        setOwner ( "Unknown" );
+        ownerSet = false;
+    }
+
+    m_codec = new BaseCodec;
+
+    dprintf ( D_FULLDEBUG, "Created new SubmissionObject '%s' for '%s'\n", _name, _owner);
+}
+
+SubmissionObject::~SubmissionObject()
+{
+	dprintf ( D_FULLDEBUG, "SubmissionObject::~SubmissionObject for '%s'\n", m_name.c_str());
+	delete m_codec;
+}
+
+void
+SubmissionObject::increment ( const Job *job )
+{
+    int status = job->getStatus();
+
+    dprintf ( D_FULLDEBUG, "SubmissionObject::increment '%s' on '%s'\n", getJobStatusString(status), job->getKey());
+
+    switch ( status )
+    {
+        case IDLE:
+            m_idle.insert ( job );
+            break;
+        case RUNNING:
+            m_running.insert ( job );
+            break;
+        case REMOVED:
+            m_removed.insert ( job );
+            break;
+        case COMPLETED:
+            m_completed.insert ( job );
+            break;
+        case HELD:
+            m_held.insert ( job );
+            break;
+        default:
+            dprintf ( D_ALWAYS, "error: Unknown %s of %d on %s\n",
+                      ATTR_JOB_STATUS, status, job->getKey() );
+            break;
+    }
+}
+
+void
+SubmissionObject::decrement ( const Job *job )
+{
+    int status = job->getStatus();
+
+    dprintf ( D_FULLDEBUG, "SubmissionObject::decrement '%s' on '%s'\n", getJobStatusString(status), job->getKey());
+
+    switch ( status )
+    {
+        case IDLE:
+            m_idle.erase ( job );
+            break;
+        case RUNNING:
+            m_running.erase ( job );
+            break;
+        case REMOVED:
+            m_removed.erase ( job );
+            break;
+        case COMPLETED:
+            m_completed.erase ( job );
+            break;
+        case HELD:
+            m_held.erase ( job );
+            break;
+        default:
+            dprintf ( D_ALWAYS, "error: Unknown %s of %d on %s\n",
+                      ATTR_JOB_STATUS, status, job->getKey() );
+            break;
+    }
+}
+
+
+const SubmissionObject::JobSet &
+SubmissionObject::getIdle()
+{
+    return m_idle;
+}
+
+const SubmissionObject::JobSet &
+SubmissionObject::getRunning()
+{
+    return m_running;
+}
+
+const SubmissionObject::JobSet &
+SubmissionObject::getRemoved()
+{
+    return m_removed;
+}
+
+const SubmissionObject::JobSet &
+SubmissionObject::getCompleted()
+{
+    return m_completed;
+}
+
+const SubmissionObject::JobSet &
+SubmissionObject::getHeld()
+{
+    return m_held;
+}
+
+void
+SubmissionObject::setOwner ( const char *_owner )
+{
+    if (_owner && !ownerSet )
+    {
+        m_owner = _owner;
+        ownerSet = true;
+    }
+}
+
+JobSummaryPair makeJobPair(const Job* job) {
+	JobServerObject* jso = JobServerObject::getInstance();
+	const char* job_cp = job->getKey();
+	JobSummaryFields* jsf = new JobSummaryFields;
+	AviaryStatus status;
+	// TODO: should check this return val i suppose
+	jso->getSummary(job_cp, *jsf, status);
+	return make_pair(job_cp,jsf);
+}
+
+void
+SubmissionObject::getJobSummaries ( JobSummaryPairCollection &jobs)
+{
+
+    // id, timestamp (which?), command, args, ins, outs, state, message
+    // id, time queued, time entered current state, state, command, args, hold reason, release reason
+
+    // find all the jobs in their various states...
+
+    //1) Idle
+    for ( SubmissionObject::JobSet::const_iterator i = getIdle().begin();
+            getIdle().end() != i; i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+	}
+
+    //2) Running
+    for ( SubmissionObject::JobSet::const_iterator i = getRunning().begin();
+            getRunning().end() != i;
+            i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+    }
+
+    //3) Removed
+    for ( SubmissionObject::JobSet::const_iterator i = getRemoved().begin();
+            getRemoved().end() != i; i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+    }
+
+    //4) Completed
+    for ( SubmissionObject::JobSet::const_iterator i = getCompleted().begin();
+            getCompleted().end() != i; i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+    }
+
+    //5) Held
+    for ( SubmissionObject::JobSet::const_iterator i = getHeld().begin();
+            getHeld().end() != i; i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+    }
+
+}
diff --git a/src/condor_contrib/aviary/src/SubmissionObject.h b/src/condor_contrib/aviary/src/SubmissionObject.h
new file mode 100644
index 0000000..2b0f7a6
--- /dev/null
+++ b/src/condor_contrib/aviary/src/SubmissionObject.h
@@ -0,0 +1,88 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _SUBMISSIONOBJECT_H
+#define _SUBMISSIONOBJECT_H
+
+// c++ includes
+#include <string>
+#include <map>
+#include <set>
+
+// coondor includes
+#include "condor_common.h"
+
+// local includes
+#include "Job.h"
+#include "JobServerObject.h"
+
+using std::string;
+using std::map;
+using std::set;
+
+namespace aviary {
+namespace query {
+		
+struct cmpjob {
+	bool operator()(const Job *a, const Job *b) const {
+		return strcmp(a->getKey(), b->getKey()) < 0;
+	}
+};
+
+class SubmissionObject
+{
+public:
+    friend class Job;
+	typedef set<const Job *, cmpjob> JobSet;
+
+	SubmissionObject( const char *name, const char *owner);
+	~SubmissionObject();
+
+	const JobSet & getIdle();
+	const JobSet & getRunning();
+	const JobSet & getRemoved();
+	const JobSet & getCompleted();
+	const JobSet & getHeld();
+
+	void setOwner(const char *owner);
+	const char* getOwner() { return m_owner.c_str(); }
+	const char* getName() { return m_name.c_str(); }
+	void getJobSummaries(JobSummaryPairCollection& _jobs);
+
+protected:
+	void increment(const Job *job);
+	void decrement(const Job *job);
+
+private:
+	JobSet m_idle;
+	JobSet m_running;
+	JobSet m_removed;
+	JobSet m_completed;
+	JobSet m_held;
+
+	bool ownerSet;
+
+	string m_name;
+	string m_owner;
+	Codec* m_codec;
+
+};
+
+}}
+
+#endif /* _SUBMISSIONOBJECT_H */
diff --git a/src/condor_contrib/aviary/src/aviary_query_server.cpp b/src/condor_contrib/aviary/src/aviary_query_server.cpp
new file mode 100644
index 0000000..1231a27
--- /dev/null
+++ b/src/condor_contrib/aviary/src/aviary_query_server.cpp
@@ -0,0 +1,279 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_daemon_core.h"
+#include "condor_debug.h"
+#include "condor_attributes.h"
+#include "get_daemon_name.h"
+#include "subsystem_info.h"
+#include "condor_config.h"
+#include "stat_info.h"
+#include "JobLogMirror.h"
+
+// local includes
+#include "Axis2SoapProvider.h"
+#include "JobServerJobLogConsumer.h"
+#include "JobServerObject.h"
+#include "HistoryProcessingUtils.h"
+#include "Globals.h"
+
+// about self
+DECL_SUBSYSTEM("QUERY_SERVER", SUBSYSTEM_TYPE_DAEMON );	// used by Daemon Core
+
+using namespace std;
+using namespace aviary::query;
+using namespace aviary::soap;
+using namespace aviary::history;
+
+ClassAd	*ad = NULL;
+Axis2SoapProvider* provider = NULL;
+JobLogMirror *mirror = NULL;
+JobServerJobLogConsumer *consumer = NULL;
+JobServerObject *job_server = NULL;
+
+extern MyString m_path;
+
+void init_classad();
+void Dump();
+int HandleTransportSocket(Service *, Stream *);
+int HandleResetSignal(Service *, int);
+void ProcessHistoryTimer(Service*);
+
+//-------------------------------------------------------------
+
+int main_init(int /* argc */, char * /* argv */ [])
+{
+	dprintf(D_ALWAYS, "main_init() called\n");
+
+	// setup the job log consumer
+	consumer = new JobServerJobLogConsumer();
+	mirror = new JobLogMirror(consumer);
+	mirror->init();
+
+    // config then env for our all-important axis2 repo dir
+    const char* log_file = "./aviary_query.axis2.log";
+	string repo_path;
+	char *tmp = NULL;
+	if (tmp = param("WSFCPP_HOME")) {
+		repo_path = tmp;
+		free(tmp);
+	}
+	else if (tmp = getenv("WSFCPP_HOME")) {
+		repo_path = tmp;
+	}
+	else {
+		EXCEPT("No WSFCPP_HOME in config or env");
+	}
+
+	int port = param_integer("HTTP_PORT",9091);
+	int level = param_integer("AXIS2_DEBUG_LEVEL",AXIS2_LOG_LEVEL_CRITICAL);
+
+    // init transport here
+    provider = new Axis2SoapProvider(level,log_file,repo_path.c_str());
+
+    std::string axis_error;
+    if (!provider->init(port,AXIS2_HTTP_DEFAULT_SO_TIMEOUT,axis_error)) {
+		dprintf(D_ALWAYS, "%s\n",axis_error.c_str());
+        EXCEPT("Failed to initialize Axis2SoapProvider");
+    }
+
+	init_classad();
+
+	ReliSock *sock = new ReliSock;
+	if (!sock) {
+		EXCEPT("Failed to allocate transport socket");
+	}
+
+	if (!sock->assign(provider->getHttpListenerSocket())) {
+		EXCEPT("Failed to bind transport socket");
+	}
+	int index;
+	if (-1 == (index =
+			   daemonCore->Register_Socket((Stream *) sock,
+                                           "Transport method socket",
+										   (SocketHandler)
+										   HandleTransportSocket,
+                                           "Handler for transport invocations"))) {
+		EXCEPT("Failed to register transport socket");
+	}
+
+	job_server = JobServerObject::getInstance();
+
+	dprintf(D_ALWAYS,"Axis2 listener on http port: %d\n",port);
+
+    // before doing any job history processing, set the location of the files
+    // TODO: need to test mal-HISTORY values: HISTORY=/tmp/somewhere
+    const char* tmp2 = param ( "HISTORY" );
+    StatInfo si( tmp2 );
+    tmp2 = si.DirPath ();
+    if ( !tmp2 )
+    {
+        dprintf ( D_ALWAYS, "warning: No HISTORY defined - Aviary Query Server will not process history jobs\n" );
+    }
+    else
+    {
+        m_path = tmp2;
+        dprintf ( D_FULLDEBUG, "HISTORY path is %s\n",tmp2 );
+        // register a timer for processing of historical job files
+        if (-1 == (index =
+            daemonCore->Register_Timer(
+                0,
+                param_integer("HISTORY_INTERVAL",120),
+                (TimerHandler)ProcessHistoryTimer,
+                "Timer for processing job history files"
+                ))) {
+        EXCEPT("Failed to register history timer");
+        }
+    }
+
+    // useful for testing job coalescing
+    // and potentially just useful
+	if (-1 == (index =
+		daemonCore->Register_Signal(SIGUSR1,
+				    "Forced Reset Signal",
+				    (SignalHandler)
+				    HandleResetSignal,
+				    "Handler for Reset signals"))) {
+		EXCEPT("Failed to register Reset signal");
+	}
+
+	return TRUE;
+}
+
+void
+init_classad()
+{
+	if ( ad ) {
+		delete ad;
+	}
+	ad = new ClassAd();
+
+	ad->SetMyTypeName("QueryServer");
+	ad->SetTargetTypeName("Daemon");
+
+	char* default_name = default_daemon_name();
+		if( ! default_name ) {
+			EXCEPT( "default_daemon_name() returned NULL" );
+		}
+	ad->Assign(ATTR_NAME, default_name);
+	delete [] default_name;
+
+	ad->Assign(ATTR_MY_ADDRESS, my_ip_string());
+
+	// Initialize all the DaemonCore-provided attributes
+	daemonCore->publish( ad );
+
+}
+
+//-------------------------------------------------------------
+
+int 
+main_config()
+{
+	dprintf(D_ALWAYS, "main_config() called\n");
+
+	return TRUE;
+}
+
+//-------------------------------------------------------------
+
+void Stop()
+{
+	if (param_boolean("DUMP_STATE", false)) {
+		Dump();
+	}
+
+	delete job_server;
+
+	DC_Exit(0);
+}
+
+//-------------------------------------------------------------
+
+int main_shutdown_fast()
+{
+	dprintf(D_ALWAYS, "main_shutdown_fast() called\n");
+
+	Stop();
+
+	DC_Exit(0);
+	return TRUE;	// to satisfy c++
+}
+
+//-------------------------------------------------------------
+
+int main_shutdown_graceful()
+{
+	dprintf(D_ALWAYS, "main_shutdown_graceful() called\n");
+
+	Stop();
+
+	DC_Exit(0);
+	return TRUE;	// to satisfy c++
+}
+
+//-------------------------------------------------------------
+
+void
+main_pre_dc_init( int /* argc */, char* /* argv */ [] )
+{
+		// dprintf isn't safe yet...
+}
+
+
+void
+main_pre_command_sock_init( )
+{
+}
+
+
+int
+HandleTransportSocket(Service *, Stream *)
+{
+	// respond to a transport callback here
+	std::string provider_error;
+    if (!provider->processHttpRequest(provider_error)) {
+        dprintf (D_ALWAYS,"Error processing request: %s\n",provider_error.c_str());
+    }
+
+	return KEEP_STREAM;
+}
+
+int
+HandleResetSignal(Service *, int)
+{
+	consumer->Reset();
+
+    return TRUE;
+}
+
+void ProcessHistoryTimer(Service*) {
+	dprintf(D_FULLDEBUG, "ProcessHistoryTimer() called\n");
+    processHistoryDirectory();
+    processOrphanedIndices();
+    processCurrentHistory();
+}
+
+
+void
+Dump()
+{
+	dprintf(D_ALWAYS|D_NOHEADER, "DUMP called\n");
+}
diff --git a/src/condor_contrib/aviary/src/cmpstr.h b/src/condor_contrib/aviary/src/cmpstr.h
new file mode 100644
index 0000000..a4b2fbe
--- /dev/null
+++ b/src/condor_contrib/aviary/src/cmpstr.h
@@ -0,0 +1,28 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _CMPSTR_H
+#define _CMPSTR_H
+
+struct cmpstr {
+   bool operator()(const char *a, const char *b) const {
+      return strcmp(a, b) < 0;
+   }
+};
+
+#endif /* _CMPSTR_H */
diff --git a/src/condor_contrib/aviary/test/jobcontrol.py b/src/condor_contrib/aviary/test/jobcontrol.py
new file mode 100755
index 0000000..a7c051f
--- /dev/null
+++ b/src/condor_contrib/aviary/test/jobcontrol.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+from suds import *
+from suds.client import Client
+from sys import exit, argv, stdin
+import time
+
+# change these for other default locations and ports
+job_wsdl = 'file:/var/lib/condor/aviary/services/job/aviary-job.wsdl'
+
+cmds = ['holdJob', 'releaseJob', 'removeJob']
+
+cmdarg = len(argv) > 1 and argv[1]
+cproc =  len(argv) > 2 and argv[2]
+job_url = len(argv) > 3 and argv[3] or "http://localhost:9090/services/job/"
+
+if cmdarg not in cmds:
+	print "error unknown command: ", cmdarg
+	print "available commands are: ",cmds
+	exit(1)
+
+client = Client(job_wsdl);
+job_url += cmdarg
+client.set_options(location=job_url)
+
+# set up our JobID
+jobId = client.factory.create('ns0:JobID')
+jobId.job = cproc
+
+try:
+	func = getattr(client.service, cmdarg, None)
+	if callable(func):
+	    result = func(jobId,"test")
+except Exception, e:
+	print "unable to access scheduler at: ", job_url
+	print e
+	exit(1)
+
+if result.code != "OK":
+	print result.code,"; ", result.text
diff --git a/src/condor_contrib/aviary/test/jobquery.py b/src/condor_contrib/aviary/test/jobquery.py
new file mode 100755
index 0000000..f311c38
--- /dev/null
+++ b/src/condor_contrib/aviary/test/jobquery.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+import logging
+from suds import *
+from suds.client import Client
+from sys import exit, argv, stdin
+import time
+
+# enable these to see the SOAP messages
+#logging.basicConfig(level=logging.INFO)
+#logging.getLogger('suds.client').setLevel(logging.DEBUG)
+
+# change these for other default locations and ports
+job_wsdl = 'file:/var/lib/condor/aviary/services/query/aviary-query.wsdl'
+
+cmds = ['getJobStatus', 'getJobSummary', 'getJobDetails']
+
+cmdarg = len(argv) > 1 and argv[1]
+cproc =  len(argv) > 2 and argv[2]
+job_url = len(argv) > 3 and argv[3] or "http://localhost:9091/services/query/"
+
+if cmdarg not in cmds:
+	print "error unknown command: ", cmdarg
+	print "available commands are: ",cmds
+	exit(1)
+
+client = Client(job_wsdl);
+job_url += cmdarg
+client.set_options(location=job_url)
+
+# enable to see service schema
+#print client
+
+# set up our JobID
+if cproc:
+	jobId = client.factory.create("ns0:JobID")
+	jobId.job = cproc
+else:
+	# returns all jobs
+	jobId = None
+
+try:
+	func = getattr(client.service, cmdarg, None)
+	if callable(func):
+	    result = func(jobId)
+except Exception, e:
+	print "invocation failed: ", job_url
+	print e
+	exit(1)
+
+print result
diff --git a/src/condor_contrib/aviary/test/setattr.py b/src/condor_contrib/aviary/test/setattr.py
new file mode 100755
index 0000000..175210c
--- /dev/null
+++ b/src/condor_contrib/aviary/test/setattr.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+from suds import *
+from suds.client import Client
+from sys import exit, argv, stdin
+import time
+
+# change these for other default locations and ports
+job_wsdl = 'file:/var/lib/condor/aviary/services/job/aviary-job.wsdl'
+
+cproc =  len(argv) > 1 and argv[1]
+attr_name = len(argv) > 2 and argv[2]
+attr_value = len(argv) > 3 and argv[3]
+job_url = len(argv) > 4 and argv[4] or "http://localhost:9090/services/job/setJobAttribute"
+
+client = Client(job_wsdl);
+client.set_options(location=job_url)
+
+# set up our JobID
+jobId = client.factory.create('ns0:JobID')
+jobId.job = cproc
+
+# set up the Attribute
+aviary_attr = client.factory.create('ns0:Attribute')
+aviary_attr.name = attr_name
+aviary_attr.type = "STRING";
+aviary_attr.value = '"'+attr_value+'"'
+
+try:
+	result = client.service.setJobAttribute(jobId, aviary_attr)
+except Exception, e:
+	print "unable to access scheduler at: ", job_url
+	print e
+	exit(1)
+
+if result.code != "OK":
+	print result.code,"; ", result.text
diff --git a/src/condor_contrib/aviary/test/submissions.py b/src/condor_contrib/aviary/test/submissions.py
new file mode 100755
index 0000000..1f03d63
--- /dev/null
+++ b/src/condor_contrib/aviary/test/submissions.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+import logging
+from suds import *
+from suds.client import Client
+from sys import exit, argv
+
+# enable these to see the SOAP messages
+#logging.basicConfig(level=logging.INFO)
+#logging.getLogger('suds.client').setLevel(logging.DEBUG)
+
+query_wsdl = 'file:/var/lib/condor/aviary/services/query/aviary-query.wsdl'
+
+sub_name = len(argv) > 1 and argv[1]
+query_url = len(argv) > 2 and argv[2] or 'http://localhost:9091/services/query/getSubmissionSummary'
+
+client = Client(query_wsdl);
+client.set_options(location=query_url)
+
+# enable to see service schema
+#print client
+
+# set up our ID
+if sub_name:
+	subId = client.factory.create("ns0:SubmissionID")
+	subId.name = sub_name
+else:
+	# returns all jobs
+	subId = None
+
+try:
+	submissions = client.service.getSubmissionSummary(subId)
+except Exception, e:
+	print "invocation failed: ", query_url
+	print e
+	exit(1)
+
+print submissions
diff --git a/src/condor_contrib/aviary/test/submit.py b/src/condor_contrib/aviary/test/submit.py
new file mode 100755
index 0000000..a4bfabe
--- /dev/null
+++ b/src/condor_contrib/aviary/test/submit.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+from suds import *
+from suds.client import Client
+from sys import exit, argv
+import time, pwd, os
+
+uid = pwd.getpwuid(os.getuid())[0]
+if not uid:
+    uid = "condor"
+
+quiet = False
+
+# change these for other default locations and ports
+job_wsdl = 'file:/var/lib/condor/aviary/services/job/aviary-job.wsdl'
+job_url = 'http://localhost:9090/services/job/submitJob'
+
+for arg in argv[1:]:
+	if arg == '-q':
+		quiet = True
+	if "http://" in arg:
+		url = arg
+
+client = Client(job_wsdl);
+client.set_options(location=job_url)
+
+if not quiet:
+	print client
+	
+# add specific requirements here
+req1 = client.factory.create("ns0:ResourceConstraint")
+req1.type = 'OS'
+req1.value = 'LINUX'
+reqs = [ req1 ]
+
+# add extra Condor-specific or custom job attributes here
+extra1 = client.factory.create("ns0:Attribute")
+extra1.name = 'RECIPE'
+extra1.type = 'STRING'
+extra1.value = 'SECRET_SAUCE'
+extras = [ extra1 ]
+
+try:
+	result = client.service.submitJob( \
+	# the executable command
+		'/bin/sleep', \
+	# some arguments for the command
+		'120', \
+	# the submitter name
+		uid, \
+	# initial working directory wwhere job will execute
+		'/tmp', \
+	# an arbitrary string identifying the target submission group
+		'python_test_submit', \
+	# special resource requirements
+		reqs,	\
+	# additional attributes
+		extras
+	)
+except Exception, e:
+	print "invocation failed at: ", job_url
+	print e
+	exit(1)	
+
+if result.status.code != "OK":
+	print result.status.code,"; ", result.status.text
+	exit(1)
+
+if not quiet:
+	print result
+else:
+	print result.id.job;
diff --git a/src/condor_contrib/condor_dbq/author.txt b/src/condor_contrib/condor_dbq/author.txt
new file mode 100644
index 0000000..e34989f
--- /dev/null
+++ b/src/condor_contrib/condor_dbq/author.txt
@@ -0,0 +1,3 @@
+author: James Kupsch
+organization: University of Wisconsin-Madison
+e-mail: kupsch@cs.wisc.edu
diff --git a/src/condor_contrib/condor_dbq/condor_dbq.pl b/src/condor_contrib/condor_dbq/condor_dbq.pl
new file mode 100755
index 0000000..dd07292
--- /dev/null
+++ b/src/condor_contrib/condor_dbq/condor_dbq.pl
@@ -0,0 +1,1792 @@
+#!/usr/bin/perl -w
+
+################################################################
+#
+# Copyright (C) 2009-2010, Condor Team, Computer Sciences Department,
+# University of Wisconsin-Madison, WI.
+# 
+# Licensed under the Apache License, Version 2.0 (the "License"); you
+# may not use this file except in compliance with the License.  You may
+# obtain a copy of the License at
+# 
+#    http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+################################################################
+
+
+use strict;
+use DBI;
+use Getopt::Long;
+use Carp;
+
+
+my $condorQCmd		= "condor_q";
+my $condorSubmitCmd	= "condor_submit";
+
+my $condorAttrPrefix	= 'CDBQ_';
+my $cdbqIdAttr		= "${condorAttrPrefix}ID";
+my $cdbqSysAttr		= "${condorAttrPrefix}SYS";
+
+
+package CondorUserLog;
+
+sub new
+{
+    my $invocant = shift;
+
+    my $class = ref($invocant) || $invocant;
+    my $self = {
+		filename	=> undef,
+		fh		=> undef,
+		buf		=> '',
+		bufOffset	=> 0,
+		fileOffset	=> 0,
+		readChunkSize	=> 1024,
+		dev		=> undef,
+		ino		=> undef,
+		fileErrMsg	=> undef,
+		fileErrNum	=> 0,
+		lastUpdateTime	=> 0,
+		@_
+		};
+
+    die "filename required" unless defined $self->{filename};
+
+    if (defined $self->{offset})  {
+	$self->{bufOffset} = $self->{fileOffset} = $self->{offset};
+	delete $self->{offset};
+    }
+
+    bless $self, $class;
+    return $self;
+}
+
+
+sub FileExists
+{
+    my $self = shift;
+
+    return -f $self->{filename};
+}
+
+
+sub Open
+{
+    my $self = shift;
+
+    if (!defined $self->{fh})  {
+	my $fh;
+	my $errMsg = '';
+	my $errNum = 0;
+
+	my $r = open $fh, "<", $self->{filename};
+	if ($r)  {
+	    binmode $fh;
+	    $r = seek $fh, $self->{fileOffset}, 0;
+	    if ($r)  {
+		$self->{fh} = $fh;
+	    }  else  {
+		$errMsg = "seek: $!";
+		$errNum = 0 + $!;
+		close $fh
+	    }
+	}  else  {
+	    $errMsg = "open: $!";
+	    $errNum = 0 + $!;
+	}
+
+	$self->{fileErrMsg} = $errMsg;
+	$self->{fileErrNum} = $errNum;
+    }
+
+    return $self->{fh};
+}
+
+
+sub Close
+{
+    my $self = shift;
+
+    if (defined $self->{fh})  {
+	my $r = close $self->{fh};
+	$self->{fh} = undef if $r;
+	return $r;
+    }
+
+    return 0;
+}
+
+
+sub SetPosition
+{
+    my $self = shift;
+    my $pos = shift;
+
+    $self->{buf} = '';
+    $self->{bufOffset} = $self->{fileOffset} = $pos;
+
+    my $r = seek $self->{fh}, $pos, 0;
+    if (!$r)  {
+	$self->Close;
+    }
+}
+
+
+sub DESTROY
+{
+    my $self = shift;
+
+    $self->Close;
+}
+
+
+sub ReadFileChunk
+{
+    my $self = shift;
+
+    my $fh = $self->Open;
+
+    return unless defined $fh;
+
+    my $fileSize = -s $fh;
+    my $fileOffset = $self->{fileOffset};
+
+    if ($fileOffset > $fileSize)  {
+	$self->{fileErrMsg}
+		= "File truncated size=$fileSize, last read=$fileOffset";
+	$self->{fileErrNum} = -1;
+	return;
+    }
+
+    my $fileBytesRemaining = $fileSize - $fileOffset;
+    my $readSize = $self->{readChunkSize};
+    $readSize = $fileBytesRemaining if $fileBytesRemaining < $readSize; 
+
+    return 0 if $readSize == 0;
+
+    my $buf;
+    my $bytesRead = read $fh, $buf, $readSize;
+
+    if ($bytesRead != $readSize)  {
+	seek $fh, 0, 1;
+	$self->{fileErrMsg}
+		= "Read truncated wanted=$readSize, read=$bytesRead";
+	$self->{fileErrNum} = -1;
+	return;
+    }
+
+    $self->{buf} .= $buf;
+    $self->{fileOffset} += $bytesRead;
+
+    return $bytesRead;
+}
+
+
+#
+# returns (record, recordOffset, nextRecordOffset)	 if record found
+#         (					 )	 if no record available
+#         (undef , recordOffset, undef, errMsg, errNum)  if error
+#
+sub GetNextRecord
+{
+    my $self = shift;
+
+    while (1)  {
+	my ($r, $delim, $rest) = split /^(\.{3}\r?\n)/m, $self->{buf}, 2;
+	my $recordPos = $self->{bufOffset};
+
+	if (defined $delim)  {
+	    # found record
+	    $self->{buf} = $rest;
+	    $self->{bufOffset} += length($r) + length($delim);
+
+	    return ($r, $recordPos, $self->{bufOffset});
+	}  else  {
+	    my $amount = $self->ReadFileChunk;
+
+	    if (!defined $amount)  {
+		# error occurred
+		return (undef, $recordPos, undef,
+			    $self->{fileErrMsg}, $self->{fileErrNum});
+	    }  elsif ($amount == 0)  {
+		# no record found
+		return;
+	    }
+	}
+    }
+}
+
+
+
+
+package CondorWork;
+
+
+sub new
+{
+    my $invocant = shift;
+
+    my $class = ref($invocant) || $invocant;
+    my $self = {
+		workId		=> undef,
+		filename	=> undef,
+		userLog		=> undef,
+		nextPos		=> 0,
+		logErrMsg	=> undef,
+		logErrNum	=> undef,
+		totalJobs	=> 0,
+		completeJobs	=> 0,
+		jobs		=> {},
+		@_
+		};
+
+    die "filename required" unless defined $self->{filename};
+    
+    die "workId required" unless defined $self->{workId};
+
+    $self->{userLog} = new CondorUserLog(
+				filename	=> $self->{filename},
+				offset		=> $self->{nextPos}
+				);
+
+    bless $self, $class;
+    return $self;
+}
+
+
+my $eventRE = qr/^(\d+)\s+			# state
+		\((\d+)\.(\d+)\.(\d+)\)\s+	# cluster,proc.subproc
+		(\d+)\/(\d+)\s+			# MM DD
+		(\d+):(\d+):(\d+)\s+		# hh:mm:ss
+		(.*)$/sx;			# info
+
+my $normalTermRE = qr/Normal termination \(return value (\d+)\)/;
+
+my $abnormalTermRE = qr/Abnormal termination \(signal (\d+)\)/;
+
+# states in this array should go in the database
+# 	true value indicates state is terminal: 5 (terminated) and 9 (removed)
+my %states = map {$_ => ($_ == 5 || $_ == 9)} qw( 0 1 2 4 5 7 9 10 11 12 13);
+
+
+sub Print
+{
+    my $self = shift;
+
+    print "----- CondorWork -------\n";
+    my @keyNames = qw(workId filename nextPos logErrMsg logErrNum
+			totalJobs completeJobs);
+    foreach my $k (@keyNames)  {
+	my $v = $self->{$k};
+	$v = "<undef>" unless defined $v;
+	printf "%15s  %s\n", $k, $v;
+    }
+    printf "%15s  %s\n", "jobsSeen", scalar(keys %{$self->{jobs}});
+    print "------------------------\n";
+}
+
+
+sub RestoreJobs
+{
+    my $self = shift;
+    my $jobs = shift;
+
+    %{$self->{jobs}} = %$jobs;
+}
+
+
+sub MakeCondorId
+{
+    return join '.', @_;
+}
+
+
+sub IsTerminalState
+{
+    my $state = shift;
+    return exists($states{$state}) && $states{$state};
+}
+
+
+sub SetPosition
+{
+    my $self = shift;
+    my $pos = shift;
+
+    $self->{userLog}->SetPosition($pos);
+}
+
+
+sub NumIncompleteJobs
+{
+    my $self = shift;
+
+    return $self->{totalJobs} - $self->{completeJobs};
+}
+
+
+sub ParseRecordToEvent
+{
+    my ($record, $recordPos, $nextPos, $logErrMsg, $logErrNum) = @_;
+    my %e;
+
+    if (!defined $recordPos)  {
+	%e = (
+		type		=> 'none'
+	    );
+    }  elsif (!defined $record)  {
+	%e = (
+		type		=> 'error',
+		recordPos	=> $recordPos,
+		errMsg		=> $logErrMsg,
+		errNum		=> $logErrNum,
+	    );
+    }  elsif ($record =~  $eventRE)  {
+	%e = (
+		type		=> 'event',
+		state		=> 0 + $1,
+		cluster		=> 0 + $2,
+		proc		=> 0 + $3,
+		subproc		=> 0 + $4,
+		mon		=> 0 + $5,
+		day		=> 0 + $6,
+		hr		=> 0 + $7,
+		min		=> 0 + $8,
+		sec		=> 0 + $9,
+		info		=> $10,
+		exitSignal	=> undef,
+		exitCode	=> undef,
+		recordPos	=> $recordPos,
+		nextPos		=> $nextPos
+	    );
+
+	# guess at adjusting the year, since the year isn't in the record :(
+	# 	1 month ahead is the future
+	# 	everything else is in the past
+	my ($mo, $yr) = (localtime time)[4, 5];
+	++$mo;
+	$yr += 1900;
+	++$yr if ($mo == 12 && $e{mo} == 1);
+	--$yr if ($mo + 1 < $e{mon});
+	$e{yr} = $yr;
+
+	$e{terminal} = IsTerminalState($e{state});
+
+	# get how it terminated if state is 5
+	if ($e{state} == 5)  {
+	    if ($e{info} =~ $normalTermRE)  {
+		$e{exitCode} = 0 + $1;
+	    }  elsif ($e{info} =~ $abnormalTermRE)  {
+		$e{exitSignal} = 0 + $1;
+	    }
+	}
+
+	# only certain states get updated in the database
+	$e{recordState} = exists $states{$e{state}};
+
+	# create id to use for printing and key values
+	$e{id} = MakeCondorId(@e{qw(cluster proc subproc)});
+
+	# create ts in database format
+	$e{ts} = "$e{yr}-$e{mon}-$e{day} $e{hr}:$e{min}:$e{sec}";
+    }  else  {
+	%e = (
+		type		=> 'error',
+		recordPos	=> $recordPos,
+		errMsg		=> "invalid record format at offset $recordPos"
+	    );
+    }
+
+    return \%e;
+}
+
+
+sub GetNextEvent
+{
+    my $self = shift;
+
+    my $userLog = $self->{userLog};
+
+    my $event = ParseRecordToEvent($userLog->GetNextRecord());
+
+    return $event;
+}
+
+
+sub GetNewEvents
+{
+    my $self = shift;
+
+    my $errMsg;
+    my $errNum;
+    my $nextPos;
+
+    my %jobs;
+
+    while (1)  {
+	my $e = $self->GetNextEvent;
+	my $type = $e->{type};
+
+	last if $type eq 'none';
+
+	if ($type eq 'event')  {
+	    $nextPos = $e->{nextPos};
+
+	    next unless $e->{recordState};
+
+	    my $id = $e->{id};
+	    $jobs{$id} = $e unless exists $jobs{$id} && $jobs{$id}->{terminal};
+	}  elsif ($type eq 'error')  {
+	    if (scalar(keys %jobs) == 0)  {
+		$errMsg = $e->{errMsg};
+		$errNum = $e->{errNum};
+	    }
+
+	    $self->SetPosition($e->{recordPos});
+
+	    last;
+	}  else  {
+	    die "unknown event type ($type)";
+	}
+    }
+
+    return (\%jobs, $errMsg, $errNum, $nextPos);
+}
+
+
+sub AddCondorIdsFromLog
+{
+    my $self = shift;
+    my $jobs = shift;
+
+    while (1)  {
+	my $e = $self->GetNextEvent;
+
+	if ($e->{type} eq 'event')  {
+	    $jobs->{$e->{id}} = 1;
+	}  else  {
+	    last;
+	}
+    }
+}
+
+
+sub PrintEvent
+{
+    my $e = shift;
+
+    my @attrs = qw( type recordPos nextPos state id cluster proc subproc
+		    yr mon day hr min sec ts info terminal
+		    exitSignal exitCode recordState errMsg errNum );
+
+    print "-------------\n";
+    foreach my $k (@attrs)  {
+	next unless exists $e->{$k};
+	my $v = $e->{$k};
+	$v = "<undef>" unless defined $v;
+	printf "%-14s: %s\n", $k, $v;
+    }
+    print "-------------\n";
+}
+
+
+sub RemoveAlreadyTerminatedJobEvents
+{
+    my $self = shift;
+    my $newJobs = shift;
+    my $currentJobs = $self->{jobs};
+
+    foreach my $j (keys %$newJobs)  {
+	delete $newJobs->{$j} if exists $currentJobs->{$j} && $currentJobs->{$j};
+    }
+}
+
+
+sub ApplyJobUpdates
+{
+    my $self = shift;
+    my ($newJobs, $errMsg, $errNum, $nextPos) = @_;
+    my $currentJobs = $self->{jobs};
+    my $completeJobs = $self->{completeJobs};
+
+    $self->{errMsg} = $errMsg;
+    $self->{errNum} = $errNum;
+    $self->{nextPos} = $nextPos;
+
+    foreach my $j (keys %$newJobs)  {
+	my $jobComplete = $newJobs->{$j}->{terminal};
+	$currentJobs->{$j} = $jobComplete;
+	++$completeJobs if $jobComplete;
+    }
+
+    $self->{completeJobs} = $completeJobs;
+}
+
+
+sub ProcessNewEvents
+{
+    my $self = shift;
+    my ($dbh, $insertJobSth, $updateJobSth, $updateWorkJobsSth,
+		$updateWorkCompleteSth, $updateWorkJobsErrorSth) = @_;
+
+    my $currentJobs = $self->{jobs};
+    my $id = $self->{id};
+    my $success = 1;
+    my $completeJobs = $self->{completeJobs};
+
+    my ($newJobs, $errMsg, $errNum, $nextPos) = $self->GetNewEvents;
+
+    if (scalar keys %$newJobs)  {
+	$self->RemoveAlreadyTerminatedJobEvents($newJobs);
+	my $workId = $self->{workId};
+
+	$dbh->begin_work;
+
+	foreach my $jobId (keys %$newJobs)  {
+	    my $job = $newJobs->{$jobId};
+
+	    if (defined $currentJobs->{$jobId})  {
+		# existing job
+		my @attrs = qw(state info ts exitCode exitSignal	
+				    cluster proc subproc);
+
+		my $rows = $updateJobSth->execute(@{$job}{@attrs}, $workId);
+		if (!defined $rows || $rows != 1)  {
+		    my $dbErr = $dbh->errstr;
+		    $success = 0;
+		    main::LogAndExit("Update work record failed id=$id: $dbErr\n", 1);
+		}
+	    }  else  {
+		# new job
+		my @attrs = qw(state info ts ts
+				    cluster proc subproc);
+
+		my $rows = $insertJobSth->execute(@{$job}{@attrs}, $workId);
+		if (!defined $rows || $rows != 1)  {
+		    my $dbErr = $dbh->errstr;
+		    $success = 0;
+		    main::LogAndExit("Insert work record failed id=$id: $dbErr\n", 1);
+		}
+	    }
+
+	    $currentJobs->{$jobId} = $job->{terminal};
+	    ++$completeJobs if $job->{terminal};
+	}
+
+	my $updateWorkSth;
+	if ($completeJobs >= $self->{totalJobs})  {
+	    # all jobs for work are done
+	    $updateWorkSth = $updateWorkCompleteSth;
+	}  else  {
+	    # still jobs to complete
+	    $updateWorkSth = $updateWorkJobsSth;
+	}
+
+	my $rows = $updateWorkSth->execute($nextPos, $completeJobs, $workId);
+	if (!defined $rows && $rows != 1)  {
+	    my $dbErr = $dbh->errstr;
+	    $success = 0;
+	    main::LogAndExit("update work record failed id=$id: $dbErr\n", 1);
+	}
+
+	if ($success)  {
+	    $dbh->commit;
+	}  else  {
+	    $dbh->rollback;
+	}
+    }  elsif (defined $errMsg || defined $errNum)  {
+	my $rows = $updateWorkJobsErrorSth->execute($nextPos, $errMsg, $errNum, $id);
+	if (!defined $rows || $rows != 1)  {
+	    my $dbErr = $dbh->errstr;
+	    $success = 0;
+	    main::LogAndExit("Updating work record failed id=$id: $dbErr\n", 1);
+	}
+    }
+
+    $self->ApplyJobUpdates($newJobs, $errMsg, $errNum, $nextPos);
+}
+
+
+
+package CondorActiveWork;
+
+
+sub new
+{
+    my $invocant = shift;
+
+    my $class = ref($invocant) || $invocant;
+    my $self = {
+		work			=> {},
+		numIncompleteJobs	=> 0
+		};
+
+    bless $self, $class;
+    return $self;
+}
+
+
+sub AddWork
+{
+    my $self = shift;
+    my ($workId, $filename, $totalJobs, @remain) = @_;
+
+    my $work = new CondorWork(	workId => $workId,
+				filename => $filename,
+				totalJobs => $totalJobs,
+				@remain);
+
+    $self->{work}->{$workId} = $work;
+    $self->{numIncompleteJobs} += $totalJobs;
+}
+
+
+sub NumWork
+{
+    my $self = shift;
+    return scalar keys %{$self->{work}};
+}
+
+
+sub NumIncompleteJobs
+{
+    my $self = shift;
+    return $self->{numIncompleteJobs};
+}
+
+
+sub ProcessWork
+{
+    my $self = shift;
+    my @dbArgs = @_;
+    my $work = $self->{work};
+
+    foreach my $id (keys %$work)  {
+	my $w = $work->{$id};
+	my $prevNumIncompleteJobs = $w->NumIncompleteJobs;
+	my $r = $w->ProcessNewEvents(@dbArgs);
+	my $curNumIncompleteJobs = $w->NumIncompleteJobs;
+	$self->{numIncompleteJobs} -= $prevNumIncompleteJobs - $curNumIncompleteJobs;
+	delete $work->{$id} if $curNumIncompleteJobs == 0;
+    }
+}
+
+
+my $condorQRe = qr/\s*^(?:(\d+)\s+)?(\d+)\s+(\d+)\s*$/;
+
+sub CheckIfWorkSubmitted
+{
+    my $self = shift;
+    my ($workId, $filename) = @_;
+    my %jobs;
+
+    my @cmd = (
+		$condorQCmd,
+		'-format',	'%d ',		'subprocid',
+		'-format',	'%d ',		'procid',
+		'-format',	'%d\n',		'clusterid',
+		'-constraint',	"$cdbqIdAttr == $workId"
+		);
+
+    my ($exitCode, $exitSignal, $out, $err) = main::ExecuteCommand(\@cmd, '');
+    
+    if ($exitCode != 0 || $exitSignal != 0)  {
+	$out = '' unless defined $out;
+	$err = '' unless defined $err;
+	main::LogAndExit("$condorQCmd failed to recover"
+			. "$cdbqIdAttr=$workId\n$out\n---\n$err\n", 1);
+    }
+
+    foreach my $line (split /\n/, $out)  {
+	next if $line =~ /^\s*$/;
+	my ($sp, $p, $c) = ($line =~ /$condorQRe/);
+	$sp = 0 unless defined $sp;
+	main::LogAndExit("$condorQCmd produced invalid line: $line", 1)
+		unless defined $c;
+
+	my $condorId = CondorWork::MakeCondorId($c, $p, $sp);
+	$jobs{$condorId} = 1;
+    }
+
+    my $work = new CondorWork(filename => $filename, workId => $workId);
+    $work->AddCondorIdsFromLog(\%jobs);
+
+    return scalar(keys %jobs);
+}
+
+
+sub RecoverChosenWork
+{
+    my $self = shift;
+    my ($getChosenWorkSth, $submitSuccessSth, $revertChosenSth) = @_;
+
+    my %jobsSeen;
+    my $numJobs = scalar keys %jobsSeen;
+    my $cluster;
+
+    my %work;
+    $getChosenWorkSth->execute();
+    while (my @data = $getChosenWorkSth->fetchrow_array())  {
+	my ($workId, $filename) = @data;
+	$work{$workId} = $filename;
+    }
+    $getChosenWorkSth->finish();
+
+    foreach my $workId (keys %work)  {
+	my $numJobs = $self->CheckIfWorkSubmitted($workId, $work{$workId});
+	if ($numJobs > 0)  {
+	    my $rows = $submitSuccessSth->execute(undef, undef, $numJobs, $workId);
+	    if (!defined $rows || $rows != 1)  {
+		LogAndExit("Error: Updating db for successful submit", 1);
+	    }
+	}  else  {
+	    my $rows = $revertChosenSth->execute($workId);
+	    if (!defined $rows || $rows != 1)  {
+		LogAndExit("Error: Updating db for successful submit", 1);
+	    }
+	}
+    }
+}
+
+
+sub RestoreStateFromDatabase
+{
+    my $self = shift;
+
+    my $getInBatchWorkSth = shift;
+    my $getInBatchJobsSth = shift;
+    my $activeWork = $self->{work};
+
+    $getInBatchWorkSth->execute();
+    while (my @data = $getInBatchWorkSth->fetchrow_array())  {
+	my ($workId, $filename, $nextPos, $logErrMsg, $logErrNum,
+		    $totalJobs, $completeJobs) = @data;
+	my $work = new CondorWork(
+				workId		=> $workId,
+				filename	=> $filename,
+				nextPos		=> $nextPos,
+				logErrMsg	=> $logErrMsg,
+				logErrNum	=> $logErrNum,
+				totalJobs	=> $totalJobs,
+				completeJobs	=> $completeJobs
+				);
+	$activeWork->{$workId} = $work;
+	$self->{numIncompleteJobs} += $totalJobs - $completeJobs;
+	print "Restore $workId totalJobs=$totalJobs completeJobs=$completeJobs\n";
+    }
+    $getInBatchWorkSth->finish();
+
+    my %jobs;
+    $getInBatchJobsSth->execute();
+    while (my @data = $getInBatchJobsSth->fetchrow_array())  {
+	my ($workId, $cluster, $proc, $subproc, $state) = @data;
+	my $condorId = CondorWork::MakeCondorId($cluster, $proc, $subproc);
+	$jobs{$workId}{$condorId} = CondorWork::IsTerminalState($state);
+    }
+    $getInBatchJobsSth->finish();
+
+    foreach my $workId (keys %jobs)  {
+	print "Restore $workId seen-jobs=", scalar(keys %{$jobs{$workId}}), "\n";
+	$activeWork->{$workId}->RestoreJobs($jobs{$workId});
+    }
+}
+
+
+sub Recover
+{
+    my $self = shift;
+    my ($getInBatchWorkSth, $getInBatchJobsSth, $getChosenWorkSth,
+		$submitSuccessSth, $revertChosenSth) = @_;
+
+    $self->RecoverChosenWork($getChosenWorkSth,
+			    $submitSuccessSth, $revertChosenSth);
+    $self->RestoreStateFromDatabase($getInBatchWorkSth, $getInBatchJobsSth);
+}
+
+
+
+package main;
+
+
+my $tablePrefix = '';
+my $workTable = $tablePrefix . 'work';
+my $jobsTable = $tablePrefix . 'jobs';
+
+my %options;
+my %sqlStmts;
+
+my %defaultDbInfoFiles = (
+			admin	=> 'db.admin.conf',
+			submit	=> 'db.submit.conf',
+			worker	=> 'db.worker.conf'
+			);
+
+
+sub InitializeSqlStmts
+{
+    %sqlStmts = (
+
+    createWorkTable => qq{
+CREATE TABLE $workTable  (
+    work_data		TEXT		NOT NULL,
+    create_ts		TIMESTAMP	NOT NULL DEFAULT current_timestamp,
+    id			BIGINT		PRIMARY KEY,
+	    -- DEFAULT NEXTVAL('${workTable}_seq') handled by trigger
+    insert_user		TEXT		NOT NULL DEFAULT user,
+    state		TEXT		NOT NULL DEFAULT 'initial',
+            -- values:  initial  chosen  in_batch  complete  failed
+    cdbq_user		TEXT,
+    batch_sys		TEXT,
+    cmd_stdout		TEXT,
+    cmd_stderr		TEXT,
+    cmd_exit_code	INTEGER,
+    cmd_exit_signal	INTEGER,
+    log_file		TEXT,
+    next_pos		INTEGER,
+    total_jobs		INTEGER,
+    complete_jobs	INTEGER,
+    log_err_msg		TEXT,
+    log_err_num		INTEGER,
+    update_ts		TIMESTAMP,
+    user_id		INTEGER,
+    user_text		TEXT
+)
+    },
+
+    createJobsTable => qq{
+CREATE TABLE $jobsTable  (
+    work_id		BIGINT		REFERENCES $workTable ON DELETE CASCADE,
+    cluster		INTEGER		NOT NULL,
+    proc		INTEGER		NOT NULL,
+    subproc		INTEGER		NOT NULL,
+    state		INTEGER		NOT NULL,
+    info		TEXT		NOT NULL,
+    record_ts		TIMESTAMP	NOT NULL,
+    create_ts		TIMESTAMP	NOT NULL,
+    update_ts		TIMESTAMP	NOT NULL,
+    exit_code		INTEGER,
+    exit_signal		INTEGER,
+
+    PRIMARY KEY (work_id, cluster, proc, subproc)
+)
+    },
+
+    createWorkSeq		=> "CREATE SEQUENCE ${workTable}_seq",
+
+    createWorkFunction => qq{
+CREATE OR REPLACE FUNCTION ${workTable}_trigger() RETURNS trigger AS
+\$\$
+BEGIN
+    IF TG_OP = 'INSERT' THEN
+	NEW.create_ts = current_timestamp;
+	NEW.id = NEXTVAL('${workTable}_seq');
+	NEW.cdbq_user = NULL;
+	NEW.state = 'initial';
+	NEW.insert_user = user;
+    ELSIF TG_OP = 'UPDATE' THEN
+	IF OLD.state = 'initial' THEN
+	    NEW.cdbq_user = user;
+	    NEW.state = 'chosen';
+	ELSIF OLD.cdbq_user <> user THEN
+	    RAISE EXCEPTION 'user ''\%\%'' not allowed to update $workTable id=%%',
+				    user,                             OLD.id;
+	END IF;
+	NEW.create_ts = OLD.create_ts;
+	NEW.id = OLD.id;
+    END IF;
+
+    RETURN NEW;
+END
+\$\$ LANGUAGE plpgsql
+    },
+
+    createWorkTrigger => qq{
+CREATE TRIGGER ${workTable}_trigger
+    BEFORE INSERT OR UPDATE
+    ON $workTable
+    FOR EACH ROW EXECUTE PROCEDURE ${workTable}_trigger()
+    },
+
+
+    createJobsFunction => q{
+CREATE OR REPLACE FUNCTION jobs_trigger() RETURNS trigger AS
+$$
+BEGIN
+    IF TG_OP = 'DELETE' THEN
+	IF OLD.state <> 5 AND OLD.state <> 9 THEN
+	    RAISE EXCEPTION 'job ''%%'' still in batch system', OLD.work_id;
+	END IF;
+
+	RETURN OLD;
+    END IF;
+
+    RETURN NEW;
+END
+$$ LANGUAGE plpgsql
+    },
+
+    createJobsTrigger => qq{
+CREATE TRIGGER jobs_trigger
+    BEFORE DELETE
+    ON $jobsTable
+    FOR EACH ROW EXECUTE PROCEDURE jobs_trigger()
+    },
+
+    createSubmitUser		=> 'CREATE USER %s PASSWORD \'%s\'',
+
+    grantSubmitUserWorkTable	=> "GRANT SELECT, INSERT ON $workTable TO \%s",
+
+    grantSubmitUserJobsTable	=> "GRANT SELECT ON $jobsTable TO \%s",
+
+    grantSubmitUserWorkSeq	=> "GRANT USAGE on ${workTable}_seq TO \%s",
+
+    createExecuteUser		=> 'CREATE USER %s PASSWORD \'%s\'',
+
+    grantExecuteUserWorkTable	=> "GRANT SELECT, UPDATE ON $workTable TO \%s",
+
+    grantExecuteUserJobsTable	=> "GRANT SELECT, INSERT, UPDATE ON $jobsTable TO \%s",
+
+    revokePublicSchemaCreate => qq(
+REVOKE
+    CREATE
+    ON SCHEMA public
+    FROM public
+    CASCADE
+    ),
+
+    createLangPlpgsql		=> "create language plpgsql",
+
+    updateWorkToChosen => qq{
+UPDATE $workTable
+    SET batch_sys = ?, state = 'chosen', log_file = ? || '/work.' || id || '.log'
+    WHERE id in
+	(SELECT id
+	    FROM $workTable
+	    WHERE state = 'initial'
+	    ORDER BY id
+	    LIMIT $options{grabamount})
+    },
+
+    selectChosenWork => qq{
+SELECT id, work_data, log_file
+    FROM $workTable
+    WHERE state = 'chosen' AND batch_sys = ?
+    ORDER BY id
+    },
+
+    updateWorkToInBatch => qq{
+UPDATE $workTable
+    SET state = 'in_batch',
+	cmd_exit_code = 0, cmd_exit_signal = 0,
+	cmd_stdout = ?, cmd_stderr = ?,
+	total_jobs = ?, complete_jobs = 0
+    WHERE id = ?
+    },
+
+    updateWorkToTmpFailed => qq{
+UPDATE $workTable
+    SET state = 'initial',
+	cmd_exit_code = ?, cmd_exit_signal = 0,
+	cmd_stdout = ?, cmd_stderr = ?
+    WHERE id = ?
+    },
+
+    updateWorkToFailed => qq{
+UPDATE $workTable
+    SET state = 'failed',
+	cmd_exit_code = ?, cmd_exit_signal = ?,
+	cmd_stdout = ?, cmd_stderr = ?
+    WHERE id = ?
+    },
+
+    insertJob => qq{
+INSERT INTO $jobsTable
+    (state, info, record_ts, create_ts, update_ts,
+    cluster, proc, subproc, work_id)
+    VALUES  (?, ?, ?, ?, current_timestamp, ?, ?, ?, ?)
+    },
+
+    updateJob => qq{
+UPDATE $jobsTable
+    SET state = ?, info = ?, record_ts = ?, exit_code = ?, exit_signal = ?,
+	update_ts = current_timestamp
+    WHERE cluster = ? AND proc = ? AND subproc = ? AND work_id = ?
+    },
+
+    updateWorkJobs => qq(
+UPDATE $workTable
+    SET next_pos = ?, complete_jobs = ?, update_ts = current_timestamp
+    WHERE id = ?
+    ),
+
+    updateWorkComplete => qq(
+UPDATE $workTable
+    SET state = 'complete', next_pos = ?, complete_jobs = ?,
+	update_ts = current_timestamp
+    WHERE id = ?
+    ),
+
+    updateWorkJobsError => qq(
+UPDATE $workTable
+    SET next_pos = ?, log_err_msg = ?, log_err_num = ?,
+	update_ts = current_timestamp
+    WHERE id = ?
+    ),
+
+    getChosenWork => qq(
+SELECT id, log_file
+    FROM $workTable
+    WHERE state = 'chosen'
+    ),
+
+    updateWorkToInitial => qq(
+UPDATE $workTable
+    SET state = 'initial'
+    WHERE id = ?
+    ),
+
+    updateAllChosenWorkToInitial => qq(
+UPDATE $workTable
+    SET state = 'initial'
+    WHERE state = 'chosen'
+    ),
+
+    getInBatchWork => qq(
+SELECT id, log_file, next_pos, log_err_msg, log_err_num,
+	total_jobs, complete_jobs
+    FROM $workTable
+    WHERE state = 'in_batch'
+    ),
+
+    getInBatchJobs => qq(
+SELECT $workTable.id, $jobsTable.cluster, proc, subproc, $jobsTable.state
+    FROM $workTable, $jobsTable
+    WHERE $workTable.state = 'in_batch' AND id = work_id
+    ORDER BY id
+    )
+
+    );
+}
+
+
+sub GetDbConnectionInfo
+{
+    my ($dbInfoDir, $dbInfoFile, $dbInfoType) = @_;
+
+    my $defaultDbInfoFile = $defaultDbInfoFiles{$dbInfoType};
+
+    die "unknown dbinfotype=$dbInfoType" unless defined $defaultDbInfoFile;
+
+    $dbInfoFile = "$dbInfoDir/$defaultDbInfoFile" if $dbInfoFile eq '';
+
+    if ($dbInfoFile eq '-')  {
+	open DBINFOFILE, '-'
+		or LogAndExit("open db info file '-' failed: $!", 1);
+    }  else  {
+	open DBINFOFILE, '<', $dbInfoFile
+		or LogAndExit("open db info file '$dbInfoFile' failed: $!", 1);
+    }
+
+    my $dataSource = <DBINFOFILE>;
+    my $user = <DBINFOFILE>;
+    my $password =<DBINFOFILE>;
+
+    close DBINFOFILE or LogAndExit("close db info file '$dbInfoFile' failed: $!", 1);
+
+    LogAndExit("db info file '$dbInfoFile' is empty", 1) unless defined $dataSource;
+    chomp $dataSource;
+    LogAndExit("db info file '$dbInfoFile' missing user", 1) unless defined $user;
+    LogAndExit("db info file '$dbInfoFile' bad user '$user' is non-alphanumeric", 1) unless $user =~ /^\w+$/;
+    chomp $user;
+    chomp $password if defined $password;
+
+    return ($dataSource, $user, $password);
+}
+
+
+sub ConnectToDb
+{
+    my ($dbInfoDir, $dbInfoFile, $dbInfoType) = @_;
+    my ($dataSource, $user, $password)
+		= GetDbConnectionInfo($dbInfoDir, $dbInfoFile, $dbInfoType);
+
+    my %dbAttrs = (AutoCommit => 1, PrintError => 0, PrintWarn => 0);
+    my $dbh = DBI->connect($dataSource, $user, $password, \%dbAttrs) or die;
+
+    return $dbh;
+}
+
+
+sub ExecuteDbOperation
+{
+    my ($dbh, $options, $stmtId, @params) = @_;
+
+    die "unknown db stmt '$stmtId'" unless defined $sqlStmts{$stmtId};
+
+    my $stmt = sprintf $sqlStmts{$stmtId}, @params;
+
+    if ($options->{noexecute})  {
+	$stmt =~ s/\s*$//;
+	print "\n$stmt;\n";
+    }  else  {
+	my $rows = $dbh->do($stmt);
+	unless (defined $rows)  {
+	    my $dbErr = $dbh->errstr;
+	    LogAndExit("Db stmt failed: $dbErr\n$stmt", 1);
+	}
+    }
+}
+
+
+my %preparedStmtCache;
+
+sub GetPreparedStmt
+{
+    my ($dbh, $stmtId) = @_;
+    my $sth;
+
+    if (exists $preparedStmtCache{$stmtId})  {
+	$sth = $preparedStmtCache{$stmtId};
+    }  else  {
+	die "unknown db stmt '$stmtId'" unless defined $sqlStmts{$stmtId};
+
+	my $stmt = $sqlStmts{$stmtId};
+
+	$sth = $dbh->prepare($stmt) or die "prepare failed '$stmt'";
+    }
+
+    return $sth;
+}
+
+
+sub DoCreateLangPlpgsql
+{
+    my ($dbh, $options) = @_;
+
+    ExecuteDbOperation($dbh, $options, 'createLangPlpgsql');
+}
+
+
+sub DoRevokePublicSchemaCreate
+{
+    my ($dbh, $options) = @_;
+
+    ExecuteDbOperation($dbh, $options, 'revokePublicSchemaCreate');
+}
+
+
+sub DoInitDb
+{
+    my ($dbh, $options) = @_;
+
+    ExecuteDbOperation($dbh, $options, 'createWorkTable');
+    ExecuteDbOperation($dbh, $options, 'createJobsTable');
+    ExecuteDbOperation($dbh, $options, 'createWorkSeq');
+
+    ExecuteDbOperation($dbh, $options, 'createWorkFunction');
+    ExecuteDbOperation($dbh, $options, 'createWorkTrigger');
+
+    ExecuteDbOperation($dbh, $options, 'createJobsFunction');
+    ExecuteDbOperation($dbh, $options, 'createJobsTrigger');
+}
+
+
+sub DoCreateSubmitUser
+{
+
+    my ($dbh, $options) = @_;
+
+    my $dbInfoFile = $options->{createsubmituser};
+    my $dbInfoDir = $options->{dbinfodir};
+    my ($dataSource, $user, $password) 
+		    = GetDbConnectionInfo($dbInfoDir, $dbInfoFile, 'submit');
+
+    ExecuteDbOperation($dbh, $options, 'createSubmitUser', $user, $password);
+    ExecuteDbOperation($dbh, $options, 'grantSubmitUserWorkTable', $user);
+    ExecuteDbOperation($dbh, $options, 'grantSubmitUserJobsTable', $user);
+    ExecuteDbOperation($dbh, $options, 'grantSubmitUserWorkSeq', $user);
+}
+
+
+sub DoCreateWorkUser
+{
+
+    my ($dbh, $options) = @_;
+
+    my $dbInfoFile = $options->{createworkuser};
+    my $dbInfoDir = $options->{dbinfodir};
+    my ($dataSource, $user, $password) 
+		    = GetDbConnectionInfo($dbInfoDir, $dbInfoFile, 'worker');
+
+    ExecuteDbOperation($dbh, $options, 'createExecuteUser', $user, $password);
+    ExecuteDbOperation($dbh, $options, 'grantExecuteUserWorkTable', $user);
+    ExecuteDbOperation($dbh, $options, 'grantExecuteUserJobsTable', $user);
+}
+
+
+my $progVersion = '1.0b3';
+
+my $progName = $0;
+$progName =~ s/.*[\\\/]//;
+
+
+sub Log
+{
+    my $data = shift;
+
+    print STDERR "$data\n";
+}
+
+
+sub LogAndExit
+{
+    my ($data, $code) = @_;
+
+    Log $data;
+
+    exit $code;
+}
+
+
+
+
+sub Usage
+{
+    print STDERR <<EOF;
+Usage: $progName [options]...
+
+    --dbinfofile      -f  db info file
+    --dbinfodir       -a  db info dir
+    --logdir          -d  user log directory
+    --sleepamount         number of seconds to sleep between iterations
+    --maxwork             maximum number of submitted work (0 is infinite)
+    --maxjobs             maximum number of incomplete jobs (0 is infinite)
+    --grabamount          number of new work pieces to grab at once
+    --id                  id for the queue
+
+    --initdb              initialize database
+    --createlang          create plpgsql language in database
+    --revokepublic        revoke create access to public schema
+    --createsubmituser    add a submit db account from db info file
+    --createworkuser      add an execute db account from db info file
+
+    --submit              submit Condor job to db
+
+    --noexecute       -n  just print sql commands
+
+    --help            -h  print this message
+    --version         -v  print version number
+EOF
+}
+
+
+sub ProcessOptions
+{
+    %options = (
+		    dbinfofile		=> '',
+		    dbinfodir		=> '.',
+		    logdir		=> '.',
+		    sleepamount		=> 10,
+		    maxwork		=> 0,
+		    maxjobs		=> 0,
+		    grabamount		=> 10,
+		    id			=> '',
+		    initdb		=> 0,
+		    createlang		=> 0,
+		    revokepublic	=> 0,
+		    createsubmituser	=> undef,
+		    createworkuser	=> undef,
+		    submit		=> undef,
+		    noexecute		=> 0,
+		    help		=> 0,
+		    version		=> 0
+		);
+
+    my @options = (
+		    "dbinfofile|f=s",
+		    "dbinfodir|a=s",
+		    "logdir|d=s",
+		    "sleepamount=i",
+		    "maxwork=i",
+		    "maxjobs=i",
+		    "grabamount=i",
+		    "id=s",
+		    "initdb!",
+		    "createlang!",
+		    "revokepublic!",
+		    "createsubmituser:s",
+		    "createworkuser:s",
+		    "submit=s",
+		    "noexecute|n!",
+		    "help|h!",
+		    "version|v!"
+		);
+
+    my $ok = GetOptions(\%options, @options);
+    if (!$ok || $options{help})  {
+	Usage();
+	exit !$ok;
+    }
+
+    if ($options{version})  {
+	print "$progName: $progVersion\n";
+	exit 0;
+    }
+
+    $options{id} = `hostname` if $options{id} eq '';
+    chomp $options{id};
+
+    if (!-d $options{logdir})  {
+	print STDERR "User log directory '$options{logdir}' does not exist\n";
+	exit 1;
+    }
+}
+
+
+sub Initialize
+{
+    ProcessOptions();
+    InitializeSqlStmts();
+}
+
+
+sub CheckCondorSubmitRunning
+{
+    my $cmd = "$condorQCmd 2>&1 >/dev/null";
+    `$cmd`;
+
+    return $? == 0;
+}
+
+
+sub GetFileContents
+{
+    my ($filename) = @_;
+
+    local $/;
+    if ($filename eq '-')  {
+	open INFILE, '-' or LogAndExit("open '-': $!", 1);
+    }  else  {
+	open INFILE, '<', $filename or LogAndExit("open < '$filename': $!", 1);
+    }
+    my $data = <INFILE>;
+    close INFILE or LogAndExit("close $filename: $!", 1);
+
+    return $data;
+}
+
+
+sub ShellQuoteArg
+{
+    my $data = shift;
+
+    $data =~ s/'/'\\''/g;
+    $data = "'$data'" if $data =~ tr|A-Za-z0-9/-_||c;
+
+    return $data;
+}
+
+
+sub ExecuteCommand
+{
+    my ($cmdToExec, $inData, $timeout) = @_;
+
+    $inData = '' unless defined $inData;
+
+    use IPC::Open3;
+    use Fcntl;
+    use Errno qw{:POSIX};
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    local (*CMDIN, *CMDOUT, *CMDERR);
+
+    # The following block of code should just be
+    #
+    #   my $cmdPid = open3(\*CMDIN, \*CMDOUT, \*CMDERR, @$cmdToExec);
+    #
+    # A bug in open3 causes die to be called in the event that exec fails
+    # which has the side effect of running all the destructors, which
+    # closes all of our database handles.  open3 should only ever throw
+    # an exception in the child and only if the exec fails, so try and
+    # catch it and exit immediately to work around the open3 bug.
+    #
+    my $cmdPid;
+    eval {
+	$cmdPid = open3(\*CMDIN, \*CMDOUT, \*CMDERR, @$cmdToExec);
+    };
+    if ($@)  {
+	print STDERR "ExecuteCommand: exec failed: '" . join("', '", @$cmdToExec), "'";
+	eval { require POSIX; POSIX::_exit(255); };
+	exit 255;
+    }
+
+    my $cmdinFlags = fcntl(CMDIN, F_GETFL, 0);
+    fcntl(CMDIN, F_SETFL, $cmdinFlags | O_NONBLOCK);
+
+    my $inFileno = fileno(CMDIN);
+    my $outFileno = fileno(CMDOUT);
+    my $errFileno = fileno(CMDERR);
+
+    my $outData = '';
+    my $outLen = 0;
+    my $errData = '';
+    my $errLen = 0;
+
+    my $inLen = length($inData);
+    my $inOffset = 0;
+
+    my $openFds = 3;
+
+    if ($inLen == 0)  {
+	$inFileno = -1;
+	--$openFds;
+	close(CMDIN) or die "close CMDIN: $!";
+    }
+
+    while ($openFds > 0)  {
+	my $readVec = '';
+	my $writeVec = '';
+
+	vec($readVec, $outFileno, 1) = 1 unless $outFileno == -1;
+	vec($readVec, $errFileno, 1) = 1 unless $errFileno == -1;
+	vec($writeVec, $inFileno, 1) = 1 unless $inFileno == -1;
+
+	my $numFds = select($readVec, $writeVec, undef, $timeout);
+	if ($numFds == -1)  {
+	    if ($!{EINTR} || $!{EAGAIN})  {
+		redo;
+	    }  else  {
+		die "select failed: $!";
+	    }
+	}  elsif ($numFds == 0)  {
+	    kill 9, $cmdPid;
+	    waitpid $cmdPid, 0;
+	    die "select timeout expired, retrying";
+	}
+
+	if (vec($readVec, $outFileno, 1))  {
+	    my $bytesRead = sysread(CMDOUT, $outData, 1024, $outLen);
+	    if (defined $bytesRead)  {
+		if ($bytesRead > 0)  {
+		    $outLen += $bytesRead;
+		}  elsif ($bytesRead == 0)  {
+		    $outFileno = -1;
+		    --$openFds;
+		    close(CMDOUT) or die "close CMDOUT: $!";
+		}
+	    }  else  {
+		if (!$!{EINTR} && !$!{EAGAIN})  {
+		    kill 9, $cmdPid;
+		    waitpid $cmdPid, 0;
+		    die "sysread CMDOUT: $!";
+		}
+	    }
+	}
+
+	if (vec($readVec, $errFileno, 1))  {
+	    my $bytesRead = sysread(CMDERR, $errData, 1024, $errLen);
+	    if (defined $bytesRead)  {
+		if ($bytesRead > 0)  {
+		    $errLen += $bytesRead;
+		}  elsif ($bytesRead == 0)  {
+		    $errFileno = -1;
+		    --$openFds;
+		    close(CMDERR) or die "close CMDERR: $!";
+		}
+	    }  else  {
+		if (!$!{EINTR} && !$!{EAGAIN})  {
+		    kill 9, $cmdPid;
+		    waitpid $cmdPid, 0;
+		    die "sysread CMDERR: $!";
+		}
+	    }
+	}
+
+	if (vec($writeVec, $inFileno, 1))  {
+	    my $bytesToWrite = $inLen - $inOffset;
+	    my $bytesWritten = syswrite(CMDIN, $inData, $bytesToWrite, $inOffset);
+	    if (defined $bytesWritten)  {
+		if ($bytesWritten > 0)  {
+		    $inOffset += $bytesWritten;
+		    if ($inOffset >= $inLen)  {
+			$inFileno = -1;
+			--$openFds;
+			close(CMDIN) or die "close CMDIN: $!";
+		    }
+		}
+	    }  else  {
+		if ($!{EPIPE})  {
+		    $inFileno = -1;
+		    --$openFds;
+		    close(CMDIN) or die "close CMDIN: $!";
+		}  elsif (!$!{EINTR} && !$!{EAGAIN})  {
+		    kill 9, $cmdPid;
+		    waitpid $cmdPid, 0;
+		    die "sysread CMDERR: $!";
+		}
+	    }
+	}
+    }
+
+    waitpid $cmdPid, 0;
+
+    my $exitCode = $? >> 8;
+    my $signalValue = $? & 127;
+
+    return ($exitCode, $signalValue, $outData, $errData);
+}
+
+
+my $scheddDownRE = qr/^ERROR: Can't find address of local schedd/m;
+my $parseScheddNumAndCluster = qr/^(\d+) job\(s\) submitted to cluster \d+/m;
+
+sub SubmitToCondor
+{
+    my ($sysId, $workId, $subFile, $logFile) = @_;
+
+    my @cmd = ($condorSubmitCmd,
+		'-a', "log = $logFile",
+		'-a', "+$cdbqIdAttr = $workId",
+		'-a', "+$cdbqSysAttr = \"$sysId\""
+		);
+    my ($exitCode, $exitSignal, $out, $err) = ExecuteCommand(\@cmd, $subFile);
+
+    my $isTmpErr
+	= ($exitSignal == 0 && $exitCode != 0 && $err =~ /$scheddDownRE/);
+
+    my $numJobs = 0;
+    while ($out =~ /$parseScheddNumAndCluster/g)  {
+	$numJobs += $1;
+    }
+
+    return ($exitCode, $exitSignal, $out, $err, $isTmpErr, $numJobs);
+}
+
+
+sub DoAdminCmds
+{
+    my ($options) = @_;
+
+    my $dbh = ConnectToDb($options->{dbinfodir}, $options->{dbinfofile}, 'admin');
+
+    if ($options->{createlang})  {
+	DoCreateLangPlpgsql($dbh, $options);
+    }
+
+    if ($options->{revokepublic})  {
+	DoRevokePublicSchemaCreate($dbh, $options);
+    }
+
+    if ($options->{initdb})  {
+	DoInitDb($dbh, $options);
+    }
+
+    if (defined $options->{createsubmituser})  {
+	DoCreateSubmitUser($dbh, $options);
+    }
+
+    if (defined $options->{createworkuser})  {
+	DoCreateWorkUser($dbh, $options);
+    }
+
+    $dbh->disconnect() or die;
+}
+
+
+sub DoSubmit
+{
+    my ($options) = @_;
+
+    my $dbh = ConnectToDb($options->{dbinfodir}, $options->{dbinfofile}, 'submit');
+
+    my $submit = GetFileContents($options->{submit});
+
+    if ($options->{noexecute})  {
+	$submit =~ s/'/''/g;
+	print "\nINSERT INTO $workTable (work_data) VALUES ('$submit');\n";
+    }  else  {
+	my $stmt = "INSERT INTO $workTable (work_data) VALUES (?);";
+	my $rows = $dbh->do($stmt, undef, $submit);
+	unless (defined $rows)  {
+	    my $dbErr = $dbh->errstr;
+	    LogAndExit("Db stmt failed: $dbErr\n$stmt", 1);
+	}
+    }
+
+    $dbh->disconnect() or die;
+}
+
+
+sub DoGrabWork
+{
+    my ($options, $dbh, $sth) = @_;
+
+    my $id = $options->{id};
+    my $logDir = $options->{logdir};
+
+    my $rows = $sth->execute($id, $logDir);
+    if (!defined $rows)  {
+	LogAndExit("GrabWork failed", 1);
+    }
+}
+
+
+sub DoSubmitWork
+{
+    my ($activeWork, $options, $dbh, $chosenWorkSth, $submitSuccessSth,
+			    $submitFailSth, $submitTmpFailSth,
+			    $updateAllChosenWorkToInitialSth) = @_;
+
+    my $id = $options->{id};
+    my $maxJobs = $options->{maxjobs};
+    my $maxWork = $options->{maxwork};
+
+    my @work;
+
+    $chosenWorkSth->execute($id);
+
+    while (my @data = $chosenWorkSth->fetchrow_array())  {
+	my $w = {work_id => $data[0], work_data => $data[1], log_file => $data[2]};
+
+	push @work, $w;
+    }
+    $chosenWorkSth->finish();
+
+    while (@work)  {
+	my $w = shift @work;
+	my $workId = $w->{work_id};
+	my $workData = $w->{work_data};
+	my $logFile = $w->{log_file};
+
+	if (($maxJobs > 0 && $activeWork->NumIncompleteJobs >= $maxJobs)
+		    || ($maxWork > 0 && $activeWork->NumWork >= $maxWork))  {
+	    my $rows = $updateAllChosenWorkToInitialSth->execute();
+	    print "revert rows = $rows\n";
+	    if (!defined $rows || $rows == 0)  {
+		LogAndExit("Error: Reverting all chosen work to initial", 1);
+	    }
+	    last;
+	}
+
+	# set a temporary error here
+	die "$logFile exists" if -e $logFile;
+
+	my ($exitCode, $exitSignal, $out, $err, $isTmpErr, $numJobs)
+			= SubmitToCondor($id, $workId, $workData, $logFile);
+
+	$err .= "Unable to extract number of jobs from submission output\n"
+		    unless $exitSignal != 0 || $exitCode != 0 || defined $numJobs;
+
+	if ($exitSignal == 0 && $exitCode == 0 && defined $numJobs)  {
+	    my $rows = $submitSuccessSth->execute($out, $err, $numJobs, $workId);
+	    if (!defined $rows || $rows != 1)  {
+		LogAndExit("Error: Updating db for successful submit", 1);
+	    }
+	    $activeWork->AddWork($workId, $logFile, $numJobs);
+	}  elsif ($isTmpErr)  {
+	    my $rows = $submitTmpFailSth->execute($exitCode,
+						    $out, $err, $workId);
+	    if (!defined $rows || $rows != 1)  {
+		LogAndExit("Error: Updating db for temporary failed submit", 1);
+	    }
+	}  else  {
+	    my $rows = $submitFailSth->execute($exitCode, $exitSignal,
+						    $out, $err, $workId);
+	    if (!defined $rows || $rows != 1)  {
+		print $dbh->errstr, "\n";
+		LogAndExit("Error: Updating db for failed submit", 1);
+	    }
+	}
+    }
+}
+
+
+sub DoProcessQueue
+{
+    my ($options) = @_;
+
+    my $id = $options{id};
+    my $sleepAmount = $options{sleepamount};
+    my $maxWork = $options{maxwork};
+    my $maxJobs = $options{maxjobs};
+
+    my $dbh = ConnectToDb($options->{dbinfodir}, $options->{dbinfofile}, 'worker');
+
+    my $grabSth			= GetPreparedStmt($dbh, 'updateWorkToChosen');
+    my $chosenWorkSth		= GetPreparedStmt($dbh, 'selectChosenWork');
+    my $submitSuccessSth	= GetPreparedStmt($dbh, 'updateWorkToInBatch');
+    my $submitFailSth		= GetPreparedStmt($dbh, 'updateWorkToFailed');
+    my $submitTmpFailSth	= GetPreparedStmt($dbh, 'updateWorkToTmpFailed');
+    my $updateAllChosenWorkToInitialSth	= GetPreparedStmt($dbh, 'updateAllChosenWorkToInitial');
+    my $insertJobSth		= GetPreparedStmt($dbh, 'insertJob');
+    my $updateJobSth		= GetPreparedStmt($dbh, 'updateJob');
+    my $updateWorkJobsSth	= GetPreparedStmt($dbh, 'updateWorkJobs');
+    my $updateWorkCompleteSth	= GetPreparedStmt($dbh, 'updateWorkComplete');
+    my $updateWorkJobsErrorSth	= GetPreparedStmt($dbh, 'updateWorkJobsError');
+    my $getInBatchWorkSth	= GetPreparedStmt($dbh, 'getInBatchWork');
+    my $getInBatchJobsSth	= GetPreparedStmt($dbh, 'getInBatchJobs');
+    my $getChosenWorkSth	= GetPreparedStmt($dbh, 'getChosenWork');
+    my $revertChosenSth		= GetPreparedStmt($dbh, 'updateWorkToInitial');
+
+    my $activeWork = new CondorActiveWork;
+
+    $activeWork->Recover($getInBatchWorkSth, $getInBatchJobsSth,
+			$getChosenWorkSth, $submitSuccessSth, $revertChosenSth);
+
+    my $done = 0;
+    while (!$done)  {
+	if (($maxJobs == 0 || $activeWork->NumIncompleteJobs < $maxJobs)
+		    && ($maxWork == 0 || $activeWork->NumWork < $maxWork))  {
+	    DoGrabWork($options, $dbh, $grabSth);
+
+	    DoSubmitWork($activeWork, $options, $dbh, $chosenWorkSth,
+			    $submitSuccessSth, $submitFailSth, $submitTmpFailSth,
+			    $updateAllChosenWorkToInitialSth);
+	}
+
+	$activeWork->ProcessWork($dbh,
+				$insertJobSth, $updateJobSth, $updateWorkJobsSth,
+				$updateWorkCompleteSth, $updateWorkJobsErrorSth);
+
+	sleep $sleepAmount;
+    }
+
+    $dbh->disconnect() or die;
+}
+
+
+sub Main
+{
+    my $processQueue = 1;
+
+    Initialize();
+
+    if (       $options{initdb}
+	    || $options{createlang}
+	    || $options{revokepublic}
+	    || defined $options{createsubmituser}
+	    || defined $options{createworkuser}
+	    )  {
+	DoAdminCmds(\%options);
+	$processQueue = 0;
+    }
+
+    if ($options{submit})  {
+	DoSubmit(\%options);
+	$processQueue = 0;
+    }
+
+    if ($processQueue)  {
+	DoProcessQueue(\%options);
+    }
+}
+
+
+Main();
diff --git a/src/condor_contrib/condor_dbq/condor_dbq.pl.man.tex b/src/condor_contrib/condor_dbq/condor_dbq.pl.man.tex
new file mode 100644
index 0000000..a61c19a
--- /dev/null
+++ b/src/condor_contrib/condor_dbq/condor_dbq.pl.man.tex
@@ -0,0 +1,471 @@
+\begin{ManPage}{\label{man-condor-dbq.pl}\Condor{dbq.pl}}{1}
+{Provides a relational database management system interface to Condor.
+Condor submit file contents are inserted into a table, \Condor{dbq.pl}
+submits the job to Condor, and updates a table with the status of the
+work to allow the monitoring of its progress.}
+\Synopsis
+
+\SynProg{\Condor{dbq.pl}}
+\oOptArg{{-}{-}dbinfofile}{dbinfofile}
+\oOptArg{{-}{-}dbinfodir}{dbinfodir}
+\oOptArg{{-}{-}logdir}{logfiledir}
+\oOptArg{{-}{-}sleepamount}{seconds}
+\oOptArg{{-}{-}maxwork}{numofwork}
+\oOptArg{{-}{-}maxjobs}{numofjobs}
+\oOptArg{{-}{-}grabamount}{numjobs}
+
+\SynProg{\Condor{dbq.pl}}
+\oOpt{{-}{-}initdb}
+\oOpt{{-}{-}createlang}
+\oOpt{{-}{-}revokepublic}
+\oOptArg{{-}{-}createsubmituser}{[dbinfofile]}
+\oOptArg{{-}{-}createworkuser}{[dbinfofile]}
+\oOptArg{{-}{-}submit}{submitfile}
+\oOpt{{-}{-}noexecute}
+
+\SynProg{\Condor{dbq.pl}}
+\oOpt{{-}{-}help}
+
+\SynProg{\Condor{dbq.pl}}
+\oOpt{{-}{-}version}
+
+
+\Description
+\Condor{dbq.pl} provides a relational database interface to submit Condor
+jobs, and monitor their progress as they are executed.
+The user submits work to the system by inserting a row into a database table.
+The user can query the \Condor{dbq.pl} tables to monitor the progress of their
+work.
+
+\Condor{dbq.pl} is careful to submit each piece of work into Condor exactly
+once.
+\Condor{dbq.pl} can be stopped at any time.  Upon restart it will recover its
+state and resume operation.
+
+
+\Condor{dbq.pl} has two main modes of operation.  The first, its normal
+mode, performs the role of taking jobs from the database, submitting them
+to Condor and updating the results of their execution.
+The second mode performs administrative tasks on the database including
+creating the necessary tables and accounts to use \Condor{dbq.pl}.
+
+In the normal mode of operation, \Condor{dbq.pl} alternates between polling
+the database for new work to submit to Condor, and monitoring the submitted
+work's user logs for new events.
+The database is updated to reflect the current state of the system.
+There are several options described in the Options Section that can be used to
+throttle \Condor{dbq.pl}
+
+The submission data for each work is in the same format allowed by
+\Condor{submit}.
+The only limitation is that the user can not specify a user log using the
+\emph{log} attribute as \Condor{dbq.pl} will override this attribute with
+its own value.
+\Condor{dbq.pl} uses \Condor{submit} to perform the submission into Condor.
+The only changes made to the submission are the user log is overridden, and
+attributes with a prefix of \emph{CDBQ\_} are added.
+For correct operation, work submitted to this \Condor{schedd} outside of
+\Condor{dbq.pl} must not add attributes or modify atttibutes with a prefix of
+\emph{CDBQ\_}.
+
+\Condor{dbq.pl} operates by using two tables.
+The \emph{work} table represents each piece of work.
+The \emph{jobs} table represents the individual jobs once the work is submitted
+to Condor.
+Other than inserting the work initially, users should only query the tables,
+and should not otherwise update values unless specified below.  A description
+of the fields and types of each table are described next.
+
+\begin{description}
+\item[work table]
+  Each row represents a piece of work to be executed by Condor.
+  The table's attribute names, their SQL types and descriptions are as follows:
+
+  \begin{description}
+    \item[work\_data TEXT]
+	Stores the Condor submit file data.
+	This is the only attribute that needs to be set when inserting a
+	new piece of work.
+    \item[create\_ts TIMESTAMP]
+	Database timestamp when record was created.
+    \item[id BIGINT]
+	Unique id for this record.
+    \item[insert\_user TEXT]
+	Database user that inserted this record.
+    \item[state TEXT]
+      The state of the piece of work in the system.
+      The possible values are as follows:
+      \begin{description}
+	\item[initial]
+	  Job has not yet been submitted to Condor.
+	\item[chosen]
+	  Job is about to be submitted to Condor.
+	\item[in\_batch]
+	  Job has successfully been submitted to Condor, but has not
+	  yet completed.
+	\item[complete]
+	  All the jobs of this work have completed successfully or
+	  have beeen removed.
+	\item[failed]
+	  The work has failed due to a permanent error.
+      \end{description}
+    \item[cdbq\_user TEXT]
+	Database user that inserted this record into Condor.
+	NULL if \Condor{submit} not executed.
+    \item[cmd\_stdout TEXT]
+	Standard out of \Condor{submit} after submitting this job.
+	NULL if \Condor{submit} not executed.
+    \item[cmd\_stderr TEXT]
+	Standard error of \Condor{submit} after submitting this job.
+	NULL if \Condor{submit} not executed.
+    \item[cmd\_exit\_code INTEGER]
+	Exit code of \Condor{submit}.
+	0 is success, other values indicate failure.
+	NULL if \Condor{submit} not executed.
+    \item[cmd\_exit\_signal INTEGER]
+	Signal causing this \Condor{submit} to fail.
+	0 is non-signal exit, other values represent the signal number.
+	NULL if \Condor{submit} not executed.
+    \item[log\_file TEXT]
+	Path to Condor's user log file for this work.
+    \item[next\_pos INTEGER]
+	Offset between last and next event record to read.
+    \item[total\_jobs INTEGER]
+	Total number of jobs that are represented by this work.
+    \item[complete\_jobs INTEGER]
+	Total number of jobs that have completed or been removed.
+    \item[log\_err\_msg TEXT]
+	Last error message caused by accessing the user log file.
+    \item[log\_err\_num INTEGER]
+	Last error number caused by accessing the user log file.
+    \item[update\_ts TIMESTAMP]
+	Database timestamp when record was last updated.
+    \item[user\_id INTEGER]
+	For use by the user to store an integer value.
+    \item[user\_text TEXT]
+	For use by the user to store a text value.
+  \end{description}
+
+\item[jobs table:]
+  Each row repreents a job of a piece of work.
+  These rows are inserted once the work has been submitted to the Condor system 
+  and Condor has written a submitted event to the user log file.
+  The table's attribute names, their SQL types and descriptions are as follows:
+
+  \begin{description}
+    \item[work\_id BIGINT]
+	Id from the \emph{work} table.
+    \item[cluster INTEGER]
+	Condor cluster id of this job.
+    \item[proc INTEGER]
+	Condor process id of this job.
+    \item[subproc INTEGER]
+	Condor subprocess id of this job.
+    \item[state INTEGER]
+	Condor user log record event type of the last event seen for this job.
+    \item[info TEXT]
+	Additional information from the last log record seen for this job.
+    \item[record\_ts TIMESTAMP]
+	User log timestamp from the last log record event processed.
+    \item[create\_ts TIMESTAMP]
+	Database timestamp when job was first seen.
+    \item[update\_ts TIMESTAMP]
+	Database timestamp when record was last updated.
+    \item[exit\_code INTEGER]
+	Exit code of of this job.
+	0 is success, other values indicate failure.
+	NULL if job not yet complete.
+    \item[exit\_signal INTEGER]
+	Signal causing this job to fail.
+	0 is non-signal exit, other values represent the signal number.
+	NULL if job not yet complete.
+  \end{description}
+\end{description}
+
+The other functions of \Condor{dbq.pl} perform administrative tasks on the
+database.
+These include inserting a new record into the work table given a Condor submit
+file, and creating the tables and accounts required by \Condor{dbq.pl}.
+If any of this functionality is requested, only the administrative tasks are
+performed; the normal processing of work is not started.
+
+If \Opt{{-}{-}noexecute} is used with any of the administrative functions, 
+the SQL statements are printed to standard out instead of being executing.
+This is useful to review the statements for security purposes, or to modify
+them before creating the database objects.
+
+The \OptArg{{-}{-}submit}{filename} option is used to insert a work record into
+the system using the contents of \emph{filename} for the Condor submit file
+data.  If \emph{filename} is `-', the program reads the Condor submit file from
+standard in.
+
+The \Opt{{-}{-}initdb} option causes the tables and other database objects to
+be created.
+
+The \Opt{{-}{-}createlang} option creates the plpgsql language to allow the
+trigger functions created by \Opt{{-}{-}initdb} to be used.
+This is not necessary if the database administrator created the language for
+use when the database was created.
+
+The \Opt{{-}{-}revokepublic} option prevents the database users from creating
+object new tables in the database in the `public' schema that PostgreSQL grants
+by default to all users.
+If the user accounts do not need to create tables this option should be used to
+revoke this unnecessary privilege.
+
+The \OptArg{{-}{-}createsubmituser}{[dbinfofile]} option creates a database user
+that can be used to submit jobs.
+The username and password for this account is obtained from the db information
+file specified, or using the default location for submit db information file
+if none is specified.
+This account has privileges to  insert work into the work table, and read
+values from both tables.
+
+The \OptArg{{-}{-}createworkuser}{[dbinfofile]} option creates a database user
+that can be used by \Condor{dbq.pl} to perform its normal operation.
+The username and password for this account is obtained from the db information
+file specified, or using the default location for worker db information file
+if none is specified.
+This account has privileges to update existing records in the work table, and
+to insert and update records in the jobs table.
+
+There are three types of database accounts required by \Condor{dbq.pl}.
+The first is an administrative database account that can create database
+accounts, tables and other objects.
+The administrative account requires database privileges to create tables and
+users in the database.
+This account is used by the administrative commands except the submit function.
+
+The second account type is used to insert work records into the database by the
+\Opt{{-}{-}submit} option.
+This account requires privileges to insert records into the work table.
+The account can be created using the \Opt{{-}{-}createsubmituser}, which also
+grants access to select records from the two tables allowing this account to
+used to both submit work and to monitor its progress.
+Multiple acconts of this type may be used.
+
+The final account type is used to perform the actual work of the system.
+This account requires privileges to update records in the work table and to
+both insert and update records in the jobs table.
+The account can be created using the \Opt{{-}{-}createworkuser}.
+
+The account information describing an account is stored in a database
+information file that contains three lines:  the perl DBI string describing the
+database, the username, and the password.
+As these files contain sensitive information, only the operating system
+accounts used to run the \Condor{dbq.pl} should be able to read the database
+account information files.
+By default, a separate db information file is used to store each of the three
+accounts with the program selecting the credential information based on the
+selected operation.
+These files are stored in a directory specified by \Opt{{-}{-}dbinfodir}, and are
+named db.admin.conf, db.submit.conf, and db.work.conf for the administrative,
+submit and work accounts respectively.
+If this scheme is used the correct account will be used without having to
+specify the account information file.
+If an account information file is missing \Condor{dbq.pl} will fail if an
+operation is selected that requires the missing account information file.
+
+
+\begin{Options}
+  \OptItem{\OptArg{{-}{-}dbinfofile}{dbinfofile}}{
+    Db information file containing the DBI connection string, username and
+    password one to a line.
+    If not specified this file defaults to files in the \Opt{{-}{-}dbinfodir}
+    directory with the names db.work.conf, db.submit.conf, or db.admin.conf,
+    based on the functionality requested being process the queue, submit a job,
+    or perform administrative database functions respectively.
+    The default value is the current directory.
+    }
+  \OptItem{\OptArg{{-}{-}dbinfodir}{dbinfodir}}{
+    Directory to look for default database information files when
+    \Opt{{-}{-}dbinfofile} is not specified.
+    }
+  \OptItem{\OptArg{{-}{-}logdir}{logfiledir}}{
+    Directory name to place the Condor user log files generated by the Condor
+    system.
+    The default value is the current directory.
+    }
+  \OptItem{\OptArg{{-}{-}sleepamount}{seconds}}{
+    Amount of time to sleep between each iteration of polling the database
+    system for new work and processing new events in the Condor user logs.
+    The default value is 10 seconds.
+    }
+  \OptItem{\OptArg{{-}{-}maxwork}{numofwork}}{
+    Maximum number of inprogress work in the Condor system.
+    If there is less work in the Condor system, new work will be submitted if
+    available.
+    }
+  \OptItem{\OptArg{{-}{-}maxjobs}{numofjobs}}{
+    Maximum number of incomplete jobs in the Condor system.
+    If there are fewer jobs, new work will be submitted if available.
+    }
+  \OptItem{\OptArg{{-}{-}grabamount}{numofwork}}{
+    Maximum amount of work to pull from the database system to insert into the
+    Condor system per iteration.
+    The default value is 10 work records.
+    }
+
+  \OptItem{\Opt{{-}{-}initdb}}{
+    Create the tables and other associated database objects required by the
+    condor\_dbq system.
+    }
+  \OptItem{\Opt{{-}{-}createlang}}{
+    Causes the plpgsql language to created in the database.
+    }
+  \OptItem{\Opt{{-}{-}revokepublic}}{
+    Revokes the default ability of database users to create new tables in the
+    `public' schema in the database.
+    }
+  \OptItem{\OptArg{{-}{-}createsubmituser}{[dbinfofile]}}{
+    Create a database account that has proper permissions to insert a work
+    submission to the database.
+    The username and paosword for the account is taken from the db information
+    file specified or the default submit db information file is used if none is
+    specified.
+    }
+  \OptItem{\OptArg{{-}{-}createworkuser}{[dbinfofile]}}{
+    Create a database account that has proper permissions to allow condor\_dbq
+    to process the queue.
+    The username and paosword for the account is taken from the db information
+    file specified or the default worker db information file is used if none is
+    specified.
+    }
+  \OptItem{\OptArg{{-}{-}submit}{submitfile}}{
+    Insert a row in the database containing the contents of \Arg{submitfile}.
+    A \Arg{submitfile} value of `-' will read the submit file from standard
+    in.
+    }
+  \OptItem{\Opt{{-}{-}noexecute}}{
+    Do not execute any of the administrative database commands.
+    Just print them out to standard out.
+    }
+
+  \OptItem{\Opt{{-}{-}help}}{
+    Print a help message and exit.
+    }
+
+  \OptItem{\Opt{{-}{-}version}}{
+    Print the version and exit.
+    }
+\end{Options}
+
+
+\Examples
+
+This section will present a complete introduction to using \Condor{dbq.pl}
+including setup of the environment, creation of the database accounts and
+tables, inserting work, and querying results.
+This example assumes the database `condor\_dbq\_db' is already created, and
+accessible on the same host via TCP/IP on the standard port.
+It also assumes that the administrative database account,
+`condor\_dbq\_admin\_user,' exists with the password
+`condor\_dbq\_admin\_password,' and that this account has the ability to create
+new database users and tables in the `condor\_dbq\_db' database.
+The example code is written in the bash shell.
+
+Create a secure directory to store the db information files.
+
+\begin{verbatim}
+mkdir condor_dbq_conf
+chmod 0700 condor_dbq_conf
+\end{verbatim}
+
+Create the database account information files for a PostgreSQL database
+named condor\_dbq\_db:
+
+\begin{verbatim}
+cat > condor_dbq_conf/db.admin.conf <<EOF
+DBI:Pg:database=condor_dbq_db;host=localhost
+condor_dbq_admin_user
+condor_dbq_admin_password
+EOF
+
+cat > condor_dbq_conf/db.submit.conf <<EOF
+DBI:Pg:database=condor_dbq_db;host=localhost
+condor_dbq_submit_user
+condor_dbq_submit_password
+EOF
+
+cat > condor_dbq_conf/db.worker.conf <<EOF
+DBI:Pg:database=condor_dbq_db;host=localhost
+condor_dbq_worker_user
+condor_dbq_worker_password
+EOF
+\end{verbatim}
+
+Create the plpgsql language used by objects created by \Opt{{-}{-}initdb}:
+
+\begin{verbatim}
+condor_dbq.pl --dbinfodir=condor_dbq_conf --createlang
+\end{verbatim}
+
+Create the database tables and objects:
+
+\begin{verbatim}
+condor_dbq.pl --dbinfodir=condor_dbq_conf --initdb
+\end{verbatim}
+
+Revoke the default ability of database users to create new tables:
+
+\begin{verbatim}
+condor_dbq.pl --dbinfodir=condor_dbq_conf --revokepublic
+\end{verbatim}
+
+Create the worker account that \Condor{dbq.pl} will use for its normal
+operation using the default db worker information file for account information:
+
+\begin{verbatim}
+condor_dbq.pl --dbinfodir=condor_dbq_conf --createworkuser
+\end{verbatim}
+
+Create the submit account that users can use to insert work into the
+system using the default submit db information file for account information:
+
+\begin{verbatim}
+condor_dbq.pl --dbinfodir=condor_dbq_conf --createsubmituser
+\end{verbatim}
+
+Create the directory to store the user logs:
+
+\begin{verbatim}
+mkdir condor_dbq_logs
+chmod 0722 condor_dbq_logs
+\end{verbatim}
+
+Start the system:
+
+\begin{verbatim}
+condor_dbq.pl --dbinfodir=condor_dbq_conf --logdir=condor_dbq_logs
+\end{verbatim}
+
+Create a Condor submit file containing a simple job:
+
+\begin{verbatim}
+cat > my.submit <<EOF
+Universe = vanilla
+transfer_executable = false
+notification = never
+output = my.out
+error = my.err
+log = my.log
+Executable = /bin/sh
+Arguments = "-c 'exit 0'"
+Queue
+EOF
+\end{verbatim}
+
+Insert the Condor submit file into the work table:
+
+\begin{verbatim}
+condor_dbq.pl --dbinfodir=condor_dbq_conf --submit=my.submit
+\end{verbatim}
+
+
+\ExitStatus
+
+\Condor{dbq.pl} will exit with a status value of 0 (zero) upon success,
+and it will exit with a non-zero value upon failure.
+
+
+\end{ManPage}
diff --git a/src/condor_contrib/condor_dbq/condor_dbq_man.pdf b/src/condor_contrib/condor_dbq/condor_dbq_man.pdf
new file mode 100644
index 0000000..ce8620d
--- /dev/null
+++ b/src/condor_contrib/condor_dbq/condor_dbq_man.pdf
@@ -0,0 +1,658 @@
+%PDF-1.6%
+39 0 obj<</Linearized 1/L 303204/O 42/E 64236/N 8/T 302382/H [ 8176 324]>>endobj                xref39 3940000000016 00000 n
+0000008500 00000 n
+0000008672 00000 n
+0000008797 00000 n
+0000009029 00000 n
+0000009098 00000 n
+0000009132 00000 n
+0000009174 00000 n
+0000010396 00000 n
+0000011383 00000 n
+0000012593 00000 n
+0000013699 00000 n
+0000014852 00000 n
+0000016028 00000 n
+0000017188 00000 n
+0000018171 00000 n
+0000018338 00000 n
+0000018420 00000 n
+0000018512 00000 n
+0000018595 00000 n
+0000018700 00000 n
+0000018781 00000 n
+0000018876 00000 n
+0000018963 00000 n
+0000019018 00000 n
+0000019134 00000 n
+0000019233 00000 n
+0000019349 00000 n
+0000019506 00000 n
+0000019595 00000 n
+0000019688 00000 n
+0000019839 00000 n
+0000019983 00000 n
+0000020085 00000 n
+0000020237 00000 n
+0000020343 00000 n
+0000020435 00000 n
+0000020582 00000 n
+0000020700 00000 n
+0000020816 00000 n
+0000020948 00000 n
+0000021037 00000 n
+0000021171 00000 n
+0000021311 00000 n
+0000021451 00000 n
+0000021601 00000 n
+0000021742 00000 n
+0000021867 00000 n
+0000021998 00000 n
+0000022130 00000 n
+0000022224 00000 n
+0000022354 00000 n
+0000022446 00000 n
+0000022604 00000 n
+0000022693 00000 n
+0000022790 00000 n
+0000022925 00000 n
+0000023028 00000 n
+0000023142 00000 n
+0000023300 00000 n
+0000023397 00000 n
+0000023500 00000 n
+0000023656 00000 n
+0000023771 00000 n
+0000023892 00000 n
+0000024040 00000 n
+0000024146 00000 n
+0000024259 00000 n
+0000024438 00000 n
+0000024562 00000 n
+0000024698 00000 n
+0000024842 00000 n
+0000024961 00000 n
+0000025056 00000 n
+0000025208 00000 n
+0000025306 00000 n
+0000025438 00000 n
+0000025579 00000 n
+0000025697 00000 n
+0000025797 00000 n
+0000025940 00000 n
+0000026058 00000 n
+0000026202 00000 n
+0000026354 00000 n
+0000026454 00000 n
+0000026606 00000 n
+0000026725 00000 n
+0000026827 00000 n
+0000026947 00000 n
+0000027125 00000 n
+0000027267 00000 n
+0000027393 00000 n
+0000027523 00000 n
+0000027637 00000 n
+0000027763 00000 n
+0000027891 00000 n
+0000028011 00000 n
+0000028139 00000 n
+0000028251 00000 n
+0000028381 00000 n
+0000028520 00000 n
+0000028642 00000 n
+0000028761 00000 n
+0000028890 00000 n
+0000029018 00000 n
+0000029163 00000 n
+0000029278 00000 n
+0000029402 00000 n
+0000029532 00000 n
+0000029644 00000 n
+0000029756 00000 n
+0000029862 00000 n
+0000029976 00000 n
+0000030081 00000 n
+0000030218 00000 n
+0000030332 00000 n
+0000030445 00000 n
+0000030556 00000 n
+0000030700 00000 n
+0000030799 00000 n
+0000030917 00000 n
+0000031082 00000 n
+0000031191 00000 n
+0000031299 00000 n
+0000031433 00000 n
+0000031551 00000 n
+0000031665 00000 n
+0000031826 00000 n
+0000031949 00000 n
+0000032078 00000 n
+0000032222 00000 n
+0000032353 00000 n
+0000032465 00000 n
+0000032602 00000 n
+0000032715 00000 n
+0000032838 00000 n
+0000032987 00000 n
+0000033114 00000 n
+0000033226 00000 n
+0000033407 00000 n
+0000033513 00000 n
+0000033648 00000 n
+0000033784 00000 n
+0000033893 00000 n
+0000033999 00000 n
+0000034168 00000 n
+0000034280 00000 n
+0000034381 00000 n
+0000034539 00000 n
+0000034651 00000 n
+0000034749 00000 n
+0000034890 00000 n
+0000035011 00000 n
+0000035139 00000 n
+0000035277 00000 n
+0000035380 00000 n
+0000035484 00000 n
+0000035631 00000 n
+0000035778 00000 n
+0000035882 00000 n
+0000036004 00000 n
+0000036148 00000 n
+0000036281 00000 n
+0000036391 00000 n
+0000036548 00000 n
+0000036690 00000 n
+0000036824 00000 n
+0000036969 00000 n
+0000037126 00000 n
+0000037282 00000 n
+0000037429 00000 n
+0000037577 00000 n
+0000037715 00000 n
+0000037877 00000 n
+0000038017 00000 n
+0000038165 00000 n
+0000038310 00000 n
+0000038456 00000 n
+0000038595 00000 n
+0000038734 00000 n
+0000038879 00000 n
+0000039023 00000 n
+0000039163 00000 n
+0000039304 00000 n
+0000039446 00000 n
+0000039587 00000 n
+0000039728 00000 n
+0000039868 00000 n
+0000040006 00000 n
+0000040148 00000 n
+0000040291 00000 n
+0000040432 00000 n
+0000040568 00000 n
+0000040708 00000 n
+0000040845 00000 n
+0000040958 00000 n
+0000041073 00000 n
+0000041229 00000 n
+0000041339 00000 n
+0000041458 00000 n
+0000041597 00000 n
+0000041727 00000 n
+0000041871 00000 n
+0000042001 00000 n
+0000042119 00000 n
+0000042233 00000 n
+0000042354 00000 n
+0000042498 00000 n
+0000042618 00000 n
+0000042739 00000 n
+0000042863 00000 n
+0000043017 00000 n
+0000043145 00000 n
+0000043261 00000 n
+0000043373 00000 n
+0000043481 00000 n
+0000043590 00000 n
+0000043728 00000 n
+0000043841 00000 n
+0000043960 00000 n
+0000044095 00000 n
+0000044229 00000 n
+0000044393 00000 n
+0000044548 00000 n
+0000044687 00000 n
+0000044815 00000 n
+0000044934 00000 n
+0000045054 00000 n
+0000045180 00000 n
+0000045314 00000 n
+0000045459 00000 n
+0000045590 00000 n
+0000045731 00000 n
+0000045866 00000 n
+0000046001 00000 n
+0000046117 00000 n
+0000046253 00000 n
+0000046395 00000 n
+0000046517 00000 n
+0000046660 00000 n
+0000046792 00000 n
+0000046915 00000 n
+0000047018 00000 n
+0000047122 00000 n
+0000047237 00000 n
+0000047393 00000 n
+0000047491 00000 n
+0000047600 00000 n
+0000047736 00000 n
+0000047844 00000 n
+0000047953 00000 n
+0000048107 00000 n
+0000048219 00000 n
+0000048341 00000 n
+0000048497 00000 n
+0000048607 00000 n
+0000048721 00000 n
+0000048839 00000 n
+0000048955 00000 n
+0000049083 00000 n
+0000049209 00000 n
+0000049358 00000 n
+0000049473 00000 n
+0000049599 00000 n
+0000049712 00000 n
+0000049829 00000 n
+0000049944 00000 n
+0000050066 00000 n
+0000050172 00000 n
+0000050275 00000 n
+0000050388 00000 n
+0000050501 00000 n
+0000050614 00000 n
+0000050705 00000 n
+0000050819 00000 n
+0000050937 00000 n
+0000051039 00000 n
+0000051173 00000 n
+0000051281 00000 n
+0000051415 00000 n
+0000051525 00000 n
+0000051666 00000 n
+0000051810 00000 n
+0000051927 00000 n
+0000052045 00000 n
+0000052208 00000 n
+0000052316 00000 n
+0000052420 00000 n
+0000052539 00000 n
+0000052659 00000 n
+0000052776 00000 n
+0000052893 00000 n
+0000053014 00000 n
+0000053137 00000 n
+0000053278 00000 n
+0000053421 00000 n
+0000053558 00000 n
+0000053681 00000 n
+0000053821 00000 n
+0000053914 00000 n
+0000054007 00000 n
+0000054111 00000 n
+0000054255 00000 n
+0000054366 00000 n
+0000054518 00000 n
+0000054682 00000 n
+0000054805 00000 n
+0000054949 00000 n
+0000055100 00000 n
+0000055239 00000 n
+0000055383 00000 n
+0000055519 00000 n
+0000055641 00000 n
+0000055772 00000 n
+0000055890 00000 n
+0000056001 00000 n
+0000056118 00000 n
+0000056223 00000 n
+0000056328 00000 n
+0000056436 00000 n
+0000056546 00000 n
+0000056653 00000 n
+0000056773 00000 n
+0000056889 00000 n
+0000057010 00000 n
+0000057126 00000 n
+0000057246 00000 n
+0000057360 00000 n
+0000057476 00000 n
+0000057599 00000 n
+0000057702 00000 n
+0000057805 00000 n
+0000057912 00000 n
+0000058016 00000 n
+0000058115 00000 n
+0000058217 00000 n
+0000058322 00000 n
+0000058423 00000 n
+0000058526 00000 n
+0000058628 00000 n
+0000058736 00000 n
+0000058844 00000 n
+0000058949 00000 n
+0000059050 00000 n
+0000059155 00000 n
+0000059256 00000 n
+0000059356 00000 n
+0000059461 00000 n
+0000059568 00000 n
+0000059666 00000 n
+0000059775 00000 n
+0000059872 00000 n
+0000059974 00000 n
+0000060079 00000 n
+0000060181 00000 n
+0000060291 00000 n
+0000060394 00000 n
+0000060494 00000 n
+0000060590 00000 n
+0000060689 00000 n
+0000060789 00000 n
+0000060889 00000 n
+0000060986 00000 n
+0000061084 00000 n
+0000061189 00000 n
+0000061290 00000 n
+0000061397 00000 n
+0000061496 00000 n
+0000061598 00000 n
+0000061700 00000 n
+0000061803 00000 n
+0000061906 00000 n
+0000062007 00000 n
+0000062108 00000 n
+0000062218 00000 n
+0000062322 00000 n
+0000062427 00000 n
+0000062533 00000 n
+0000062635 00000 n
+0000062739 00000 n
+0000062844 00000 n
+0000062942 00000 n
+0000063042 00000 n
+0000063147 00000 n
+0000063256 00000 n
+0000063359 00000 n
+0000063491 00000 n
+0000063583 00000 n
+0000063693 00000 n
+0000063807 00000 n
+0000063910 00000 n
+0000064020 00000 n
+0000064131 00000 n
+0000008176 00000 n
+trailer<</Size 433/Prev 302373/Root 40 0 R/Info 38 0 R/ID[<6F2F6545ACF891F99CB2375770F79DD3><96C4DE4AF4E2484098D79C6703EB75C0>]>>startxref0%%EOF                  432 0 obj<</Length 224/E 266/Filter/FlateDecode/I 282/O 228/S 158/V 244>>stream
+xb```f`PQ  ,@Q	@<ocfa`X3l4Q$;%Q0;{>Hu#2b $F0%@ HXD;YBAPS6:k,E+6EYv($lc2c= y/6#~gXdblq0@ Gendstreamendobj40 0 obj<</PageMode/UseOutlines/ViewerPreferences<<>>/Outlines 62 0 R/Dests 35 0 R/Metadata 37 0 R/AcroForm 41 0 R/Pages 36 0 R/OpenAction[null/Fit]/Type/Catalog>>endobj41 0 obj<</Fields[]/DA(/Helv 0 Tf 0 g )/DR<</Font<</Helv 33 0 R/ZaDb 34 0 R>>/Encoding<</PDFDocEncoding 32 0 R>>>>>>endobj42 0 obj<</CropBox[0 0 612 792]/Parent 36 0 R/Contents[46 0 R 47 0 R 48 0 R 49 0 R 50 0 R 51 0 R 52 0 R 53 0 R]/Rotate 0/MediaBox[0 0 612 792]/Resources<</Font 43 0 R/ProcSet[/PDF/ImageB/Text]/ExtGState 44 0 R>>/Type/Page>>endobj43 0 obj<</R379 55 0 R/R380 57 0 R/R381 59 0 R/R384 61 0 R>>endobj44 0 obj<</R6167 45 0 R>>endobj45 0 obj<</OPM 1/Type/ExtGState>>endobj46 0 obj<</Length 1152/Filter/FlateDecode>>stream
+HWKo7.z_nWAV@I,+m>8]m pDyofBI-!R;VJ3YQ$pbuWu4RFwi2l[P!j>9zSNFmPdC !WOiS]|_UM2#b~H6yQk*w&EBLA'&Wh}`u1 ]n|,ikSgytLP?hTO&NZf$CIQc#1X+M)?Q
+u&pQ#Nb^,dx]).u@h-"kDYlRSR{ugo|)y@Mc}KgROvrWT]Hy+C^h_z{)8TV1@AB}OhIamni,j85[\aUA0sR|wRGn!a!/x)GslA<ix94"E A Xi	SRoi?r=JYP	p^Ml\nC[m38O*(6%^0JCW3lK!pFqRl.\FZY-}5<g}^V2vu,e Z2$d@/oyd<<?DfA&N	D3?
+PC	,	FXf?r'MKYCH&0R->s\CgA}SA[aewGETw]Q=nP=Aj?OH_/;~n(i9+Ee1O
+%7f}>-=e#@8rb_CDHD.?w/ypASO$|(QHK:t&\DMsw@'wo #endstreamendobj47 0 obj<</Length 918/Filter/FlateDecode>>stream
+HMo9Wq0(tl([CCcAq:I?GLM-H=K5`pJz]uws[zq^U}`wg+&Ex[/`BdHYbSnVmTD\0FQdmn5o7?@
+ltb[#QaZPd(v1w9MDY@*:|e8KTDrK|<.}@Y>g0y#wD{d_Ot5c( OFpUn[L|8_eYhOQyKSc|-Qx,F8)XS=*\4fWlUdGWw`Hw7dx9HHD9::"]`|qJ_f2xhB:=J>p%T> 
+}/q3;)ol`vZab]t4`hdRkAl=m6p,iN=#Yp\"#QrvEgEY;btT	}Y-B8,i@4mLv#e;)Xw'7a+<:a,F9fH1l,XT(8pIpdhG*Ew>jC42<f?)<%]o[&L`ehDk/c7n4OEsBEQ6G<^p<(+jO;TT&j  yendstreamendobj48 0 obj<</Length 1140/Filter/FlateDecode>>stream
+HWKo7.r_LEQ/^hz|MvuRgwI08?R7LF`S*9MQuA/D >1q7EzYEhx7-BTNWcckFNiE:W-N~H8jlbvPl)a7rMCsRQ932Z=,mbO[JZ@aZ^$|6[:d?2sQRfYd( n/3{X8m*i#Eh3Ll`mI$b)/I9&h7@9uYvXi Z.Cy8JZf5(j#^{?BrU)4*IF6)=hz[TG':]Aucws9y^(SAgYo0(`n!C!#:|799X1CK#x	2/{]&{=[x3{Ja}3_A[mE?y	|	x=9&$-0b$&X0j1pO`zfZ'6e\bM{O&aG"\2Lv!_^~V#*T'j2G_\5\Epr>'I, 1yL_I"kE2Nib9+]
+c,<\F<@HdmXvY	C8'Uf)i_?-G~8i&M(.w[dXPrI|^)?Ss
+LV1D4 r68.qaQn:BbPb?Yq-<OJrC:|SOQ>8cAz?K',pxszov P[h!ynT&@F1)o
+|
+Lq!or~BS  O)endstreamendobj49 0 obj<</Length 1036/Filter/FlateDecode>>stream
+HW]o;y~<f&MEB-l[Zti3;*QqbcwkUy'vF:|z-7[\ c^-;,byvs0N>1u^{v:J HW-^zUZ1vh`_l)1^SZ.@vQV*
+Q\1bhwxKj$6t{*	z"_SA^{56Q	vuh,N~BRu]dys7A.|F2Y[c*99{.nN^_<?g'4zSlnB^d`E[|~zsA|}di1GY$\ wm2>?WGJe##xx>}+g`8	Vs\k]s^BPhFq~M*"{r<*g
+nl6D#&$0Q	0/zV6Ic)Ke7xUIM.{1eR4XzW*^$\
+83k}*w3iYH*2&r9#v#KqQd28S!rqna(8hL%2!u8^G 8#@R`(EXXy)qd"Qs2dhSweh^,WLQe2POD^pbiPa>M\47]p@R^WhU^K$5@rt~\/2{L5[^!,e 9.	gVL,s&wFtDQaq ^p,/}[ygYj0 Zendstreamendobj50 0 obj<</Length 1083/Filter/FlateDecode>>stream
+HWKo6.zbE^5b=,zHfMdIL"@XI}>R~)Ms]?vu.4V[Oo&:VH@t7}sW^(kyChj}o;":?7>o2:@f4e1rZ&ON>/WDmeR%rQk*h6Ua4x7e4 |8V5yz{}^#QQ"-?q;$R7B )g^i9<L`G&T_^S)Q" 
+e%3cSw}"B|Fj4,T$(*`>ZAn'Ay0hd>"\LR"_OU/4RNyKAxE\FFKi]d532pPlV9KutP])padZo+8z~
+7@Y%c@
+.&L FKd79C b<)zXA[6#I;b~mJ!E{xPM%lKw(HskNWTfhpXO~NL'S6O O
+<J#)JN_|,pO25J4,\N>	wrx(EUTQi&O5Nm}j G<p>MP$&)4&U}/Z# i8RHzX-E_DcAj lC\]V?wxVMu7e~8gC6ujf'*.XOH#hG&7!w &o{tN?6
+N RZuiWG0l=}XP(g3+k-= Kvendstreamendobj51 0 obj<</Length 1106/Filter/FlateDecode>>stream
+HWKo6~njLWEt6o%J\;9y_MZN:y}E?g/gyuWAOUuNyQW(i!Xfvw)Hi!hc\s_hn=X\m$XJJ8<]pZp*L>0SJ6{|6N[o0edWiRqT;*?c|*C/B4oc^%	 )E)VCAn[w6[)A9;xZk~@z#WnY>oHCTJVW:XT,[*QCg
+8:Hmvu|5\ sKne6U]P%YQ&WK-c,Cuc)ze:{F2##3m O<L7{9)`*?NUVVBpm/$-Bdg<h-C"S;h3hq g->#21jo9(Yh{rmI+s`O*j*<>:?o-ZIt@bB^ht|A+w2gc""v%jq\'.A5RO`Q |X>~?s5q%DW/Kss|73r1DwYMl>+eUn]S:9$yH8;-MKe8
+0,4}gHMGH{yYf4&?[2rQ3.bi#XX\[|+]i[u_wR:I2!yit~n28Ct@NCfkKQ.g7Ajl^|:<EcrfUo9RiT=&et=6[DTW #'endstreamendobj52 0 obj<</Length 1090/Filter/FlateDecode>>stream
+HWn6BZ^_h:o.RG+m6-ji.938<by6= Dozb;1usF&<xn?4&bM\mzbq* {xml[5jMnW9}|xn9{?xA.~ki^^d1joW(gU)vuO5R^uh #/s`$=8MmzV`--h}w[^Sk,(yy?* J@Y{t{DP17Pbux+<M ( |][Zf.,5#g8&*~QsZ|JA8QV12YF_Qf!QK=l1r[2JwQSf4jH"sSl
+g~YX^|[DD5]X>`)~C0IPe&-/ODnK<h"xd@~9MoC,2`b<wI[6wAK,cVLPEy0#|'FisPB>T`"Hch*rL%$5*q`1
+bj+?   	 T< F\L
+oA!qcN0*hc\@gv!8$jym'H<3iO;p8Re?5W[KbcBLG<:C*nf s*W	IFGkC\SvAJx({YX'RR[5r^]X49HT;YziUxW|
+et*I;H8HeDmZ]J
+_i7R.>#?
+,* F#;	tfZew? -{VYendstreamendobj53 0 obj<</Length 914/Filter/FlateDecode>>stream
+HV9qSt;%i$iT9 @Pt7b	"[ *3cy9vOy>e#]lhnh9uAmG_6'1-Gn,[7}8G]ldiL)]=5][~(X'F.99{|nNm9Pg?gi`3=.X;-`,~meFO9
+.WDe~r
+qFXoFA@@R]/bI2R_US*	L2:?Mb
+al]ab2}!q>rWQ]0VS/&R3fq<a!M{,Bp7ptAbUBcD~)i'i"ds~BJr(	uI3l
+
+U{Ubq	|.4%Y&fTD%U<h5'dwW G"q
+.?iM)Y z7k*DSI3(!X!y3BmRE"U__tPT-cT{(ha:qbT1v4_#'R\p)/Zr)!grT$d!PJ+j;"f)a
+w2qJL_\S	V9UsQz.n1a}yrQtp_?l+"NTJ^oWmu4cM W(i3	j^P+</dNHfjSa&z/.,8o j^endstreamendobj54 0 obj<</Differences[2/fi/fl 30/grave 136/circumflex 147/quotedblleft/quotedblright/bullet/endash/emdash/tilde 169/copyright 174/registered]/Type/Encoding>>endobj55 0 obj<</Subtype/Type1/BaseFont/Times-Roman/Encoding 54 0 R/Type/Font>>endobj56 0 obj<</Differences[2/fi/fl 148/quotedblright 150/endash/emdash]/Type/Encoding>>endobj57 0 obj<</Subtype/Type1/BaseFont/Times-Italic/Encoding 56 0 R/Type/Font>>endobj58 0 obj<</Differences[2/fi/fl 147/quotedblleft/quotedblright 150/endash/emdash]/Type/Encoding>>endobj59 0 obj<</Subtype/Type1/BaseFont/Times-Bold/Encoding 58 0 R/Type/Font>>endobj60 0 obj<</Differences[2/fi 147/quotedblleft/quotedblright 151/emdash]/Type/Encoding>>endobj61 0 obj<</Subtype/Type1/BaseFont/Times-BoldItalic/Encoding 60 0 R/Type/Font>>endobj62 0 obj<</First 63 0 R/Count 11/Last 64 0 R>>endobj63 0 obj<</First 424 0 R/Parent 62 0 R/Next 87 0 R/Dest/chapter.1/Count -8/Last 425 0 R/Title(1 Overview)>>endobj64 0 obj<</Parent 62 0 R/Dest/chapter.11/Prev 65 0 R/Title(11 Appendix B: Magic Numbers)>>endobj65 0 obj<</Parent 62 0 R/Next 64 0 R/Dest/chapter.10/Prev 66 0 R/Title(10 Appendix A: ClassAd Attributes)>>endobj66 0 obj<</First 67 0 R/Parent 62 0 R/Next 65 0 R/Dest/chapter.9/Count -58/Last 68 0 R/Prev 69 0 R/Title(9 Command Reference Manual \(man pages\))>>endobj67 0 obj<</Parent 66 0 R/Next 423 0 R/Dest/section*.304/Title(cleanup_release)>>endobj68 0 obj<</Parent 66 0 R/Dest/section*.762/Prev 368 0 R/Title(uniq_pid_undertaker)>>endobj69 0 obj<</First 70 0 R/Parent 62 0 R/Next 66 0 R/Dest/chapter.8/Count -7/Last 71 0 R/Prev 72 0 R/Title(8 Version History and Release Notes)>>endobj70 0 obj<</First 365 0 R/Parent 69 0 R/Next 364 0 R/Dest/section.8.1/Count -3/Last 366 0 R/Title(8.1 Introduction to Condor Versions)>>endobj71 0 obj<</Parent 69 0 R/Dest/section.8.7/Prev 360 0 R/Title(8.7 Stable Release Series 7.0)>>endobj72 0 obj<</First 73 0 R/Parent 62 0 R/Next 69 0 R/Dest/chapter.7/Count -7/Last 74 0 R/Prev 75 0 R/Title(7 Frequently Asked Questions \(FAQ\))>>endobj73 0 obj<</Parent 72 0 R/Next 359 0 R/Dest/section.7.1/Title(7.1 Obtaining & Installing Condor)>>endobj74 0 obj<</Parent 72 0 R/Dest/section.7.7/Prev 355 0 R/Title(7.7 Other questions)>>endobj75 0 obj<</First 76 0 R/Parent 62 0 R/Next 72 0 R/Dest/chapter.6/Count -4/Last 77 0 R/Prev 78 0 R/Title(6 Platform-Specific Information)>>endobj76 0 obj<</First 352 0 R/Parent 75 0 R/Next 340 0 R/Dest/section.6.1/Count -3/Last 353 0 R/Title(6.1 Linux)>>endobj77 0 obj<</First 337 0 R/Parent 75 0 R/Dest/section.6.4/Count -2/Last 338 0 R/Prev 339 0 R/Title(6.4 AIX)>>endobj78 0 obj<</First 79 0 R/Parent 62 0 R/Next 75 0 R/Dest/chapter.5/Count -6/Last 80 0 R/Prev 81 0 R/Title(5 Grid Computing)>>endobj79 0 obj<</Parent 78 0 R/Next 323 0 R/Dest/section.5.1/Title(5.1 Introduction)>>endobj80 0 obj<</First 314 0 R/Parent 78 0 R/Dest/section.5.6/Count -5/Last 315 0 R/Prev 316 0 R/Title(5.6 The Condor Job Router)>>endobj81 0 obj<</First 82 0 R/Parent 62 0 R/Next 78 0 R/Dest/chapter.4/Count -6/Last 83 0 R/Prev 84 0 R/Title(4 Miscellaneous Concepts)>>endobj82 0 obj<</First 311 0 R/Parent 81 0 R/Next 292 0 R/Dest/section.4.1/Count -3/Last 312 0 R/Title(4.1  Condor's ClassAd Mechanism)>>endobj83 0 obj<</First 281 0 R/Parent 81 0 R/Dest/section.4.6/Count -10/Last 282 0 R/Prev 283 0 R/Title(4.6  Condor Database Queue condor_dbq.pl)>>endobj84 0 obj<</First 85 0 R/Parent 62 0 R/Next 81 0 R/Dest/chapter.3/Count -16/Last 86 0 R/Prev 87 0 R/Title(3 Administrators' Manual)>>endobj85 0 obj<</First 279 0 R/Parent 84 0 R/Next 192 0 R/Dest/section.3.1/Count -2/Last 280 0 R/Title(3.1 Introduction)>>endobj86 0 obj<</First 154 0 R/Parent 84 0 R/Dest/section.3.16/Count -5/Last 155 0 R/Prev 156 0 R/Title(3.16 Power Management)>>endobj87 0 obj<</First 88 0 R/Parent 62 0 R/Next 84 0 R/Dest/chapter.2/Count -15/Last 89 0 R/Prev 63 0 R/Title(2 Users' Manual)>>endobj88 0 obj<</Parent 87 0 R/Next 125 0 R/Dest/section.2.1/Title(2.1 Welcome to Condor)>>endobj89 0 obj<</First 90 0 R/Parent 87 0 R/Dest/section.2.15/Count -1/Last 90 0 R/Prev 91 0 R/Title(2.15 Potential Problems)>>endobj90 0 obj<</Parent 89 0 R/Dest/subsection.2.15.1/Title(2.15.1 Renaming of argv[0])>>endobj91 0 obj<</First 92 0 R/Parent 87 0 R/Next 89 0 R/Dest/section.2.14/Count -4/Last 93 0 R/Prev 94 0 R/Title(2.14 Special Environment Considerations)>>endobj92 0 obj<</Parent 91 0 R/Next 153 0 R/Dest/subsection.2.14.1/Title(2.14.1 AFS)>>endobj93 0 obj<</Parent 91 0 R/Dest/subsection.2.14.4/Prev 152 0 R/Title(2.14.4  Job Leases)>>endobj94 0 obj<</First 95 0 R/Parent 87 0 R/Next 91 0 R/Dest/section.2.13/Count -5/Last 96 0 R/Prev 97 0 R/Title(2.13 Job Monitor)>>endobj95 0 obj<</Parent 94 0 R/Next 151 0 R/Dest/subsection.2.13.1/Title(2.13.1 Transition States)>>endobj96 0 obj<</Parent 94 0 R/Dest/subsection.2.13.5/Prev 149 0 R/Title(2.13.5 Keyboard and Mouse Shortcuts)>>endobj97 0 obj<</First 98 0 R/Parent 87 0 R/Next 94 0 R/Dest/section.2.12/Count -2/Last 99 0 R/Prev 100 0 R/Title(2.12 Time Scheduling for Job Execution)>>endobj98 0 obj<</Parent 97 0 R/Next 99 0 R/Dest/subsection.2.12.1/Title(2.12.1 Job Deferral)>>endobj99 0 obj<</Parent 97 0 R/Dest/subsection.2.12.2/Prev 98 0 R/Title(2.12.2 CronTab Scheduling)>>endobj100 0 obj<</First 101 0 R/Parent 87 0 R/Next 97 0 R/Dest/section.2.11/Count -4/Last 102 0 R/Prev 103 0 R/Title(2.11 Virtual Machine Applications)>>endobj101 0 obj<</Parent 100 0 R/Next 148 0 R/Dest/subsection.2.11.1/Title(2.11.1 The Submit Description File)>>endobj102 0 obj<</Parent 100 0 R/Dest/subsection.2.11.4/Prev 147 0 R/Title(2.11.4 Job Completion in the vm Universe)>>endobj103 0 obj<</First 104 0 R/Parent 87 0 R/Next 100 0 R/Dest/section.2.10/Count -9/Last 105 0 R/Prev 106 0 R/Title(2.10 DAGMan Applications)>>endobj104 0 obj<</Parent 103 0 R/Next 146 0 R/Dest/subsection.2.10.1/Title(2.10.1 DAGMan Terminology)>>endobj105 0 obj<</Parent 103 0 R/Dest/subsection.2.10.9/Prev 140 0 R/Title(2.10.9 Visualizing DAGs with dot)>>endobj106 0 obj<</First 107 0 R/Parent 87 0 R/Next 103 0 R/Dest/section.2.9/Count -4/Last 108 0 R/Prev 109 0 R/Title(2.9 Parallel Applications \(Including MPI Applications\))>>endobj107 0 obj<</Parent 106 0 R/Next 139 0 R/Dest/subsection.2.9.1/Title(2.9.1 Prerequisites to Running Parallel Jobs)>>endobj108 0 obj<</Parent 106 0 R/Dest/subsection.2.9.4/Prev 138 0 R/Title(2.9.4 MPI Applications Within Condor's Parallel Universe)>>endobj109 0 obj<</First 110 0 R/Parent 87 0 R/Next 106 0 R/Dest/section.2.8/Count -3/Last 111 0 R/Prev 112 0 R/Title(2.8 Java Applications)>>endobj110 0 obj<</Parent 109 0 R/Next 137 0 R/Dest/subsection.2.8.1/Title(2.8.1 A Simple Example Java Application)>>endobj111 0 obj<</Parent 109 0 R/Dest/subsection.2.8.3/Prev 137 0 R/Title(2.8.3 Chirp I/O)>>endobj112 0 obj<</First 113 0 R/Parent 87 0 R/Next 109 0 R/Dest/section.2.7/Count -3/Last 114 0 R/Prev 115 0 R/Title(2.7 Priorities and Preemption)>>endobj113 0 obj<</Parent 112 0 R/Next 136 0 R/Dest/subsection.2.7.1/Title(2.7.1 Job Priority)>>endobj114 0 obj<</Parent 112 0 R/Dest/subsection.2.7.3/Prev 136 0 R/Title(2.7.3  Details About How Condor Jobs Vacate Machines)>>endobj115 0 obj<</First 116 0 R/Parent 87 0 R/Next 112 0 R/Dest/section.2.6/Count -7/Last 117 0 R/Prev 118 0 R/Title(2.6 Managing a Job)>>endobj116 0 obj<</Parent 115 0 R/Next 135 0 R/Dest/subsection.2.6.1/Title(2.6.1 Checking on the progress of jobs)>>endobj117 0 obj<</Parent 115 0 R/Dest/subsection.2.6.7/Prev 131 0 R/Title(2.6.7 Job Completion)>>endobj118 0 obj<</First 119 0 R/Parent 87 0 R/Next 115 0 R/Dest/section.2.5/Count -7/Last 120 0 R/Prev 121 0 R/Title(2.5 Submitting a Job)>>endobj119 0 obj<</Parent 118 0 R/Next 130 0 R/Dest/subsection.2.5.1/Title(2.5.1 Submit Description File Commands)>>endobj120 0 obj<</Parent 118 0 R/Dest/subsection.2.5.7/Prev 126 0 R/Title(2.5.7 Heterogeneous Submit: Execution on Differing Architectures)>>endobj121 0 obj<</First 122 0 R/Parent 87 0 R/Next 118 0 R/Dest/section.2.4/Count -1/Last 122 0 R/Prev 123 0 R/Title(2.4 Road-map for Running Jobs)>>endobj122 0 obj<</Parent 121 0 R/Dest/subsection.2.4.1/Title(2.4.1  Choosing a Condor Universe)>>endobj123 0 obj<</First 124 0 R/Parent 87 0 R/Next 121 0 R/Dest/section.2.3/Count -1/Last 124 0 R/Prev 125 0 R/Title(2.3 Matchmaking with ClassAds)>>endobj124 0 obj<</Parent 123 0 R/Dest/subsection.2.3.1/Title(2.3.1 Inspecting Machine ClassAds with condor_status)>>endobj125 0 obj<</Parent 87 0 R/Next 123 0 R/Dest/section.2.2/Prev 88 0 R/Title(2.2 Introduction)>>endobj126 0 obj<</Parent 118 0 R/Next 120 0 R/Dest/subsection.2.5.6/Prev 127 0 R/Title(2.5.6 Environment Variables)>>endobj127 0 obj<</Parent 118 0 R/Next 126 0 R/Dest/subsection.2.5.5/Prev 128 0 R/Title(2.5.5  Submitting Jobs Without a Shared File System: Condor's File Transfer Mechanism)>>endobj128 0 obj<</Parent 118 0 R/Next 127 0 R/Dest/subsection.2.5.4/Prev 129 0 R/Title(2.5.4  Submitting Jobs Using a Shared File System)>>endobj129 0 obj<</Parent 118 0 R/Next 128 0 R/Dest/subsection.2.5.3/Prev 130 0 R/Title(2.5.3 About Requirements and Rank)>>endobj130 0 obj<</Parent 118 0 R/Next 129 0 R/Dest/subsection.2.5.2/Prev 119 0 R/Title(2.5.2 Sample submit description files)>>endobj131 0 obj<</Parent 115 0 R/Next 117 0 R/Dest/subsection.2.6.6/Prev 132 0 R/Title(2.6.6 In the log file)>>endobj132 0 obj<</Parent 115 0 R/Next 131 0 R/Dest/subsection.2.6.5/Prev 133 0 R/Title(2.6.5 Why is the job not running?)>>endobj133 0 obj<</Parent 115 0 R/Next 132 0 R/Dest/subsection.2.6.4/Prev 134 0 R/Title(2.6.4 Changing the priority of jobs)>>endobj134 0 obj<</Parent 115 0 R/Next 133 0 R/Dest/subsection.2.6.3/Prev 135 0 R/Title(2.6.3 Placing a job on hold)>>endobj135 0 obj<</Parent 115 0 R/Next 134 0 R/Dest/subsection.2.6.2/Prev 116 0 R/Title(2.6.2 Removing a job from the queue)>>endobj136 0 obj<</Parent 112 0 R/Next 114 0 R/Dest/subsection.2.7.2/Prev 113 0 R/Title(2.7.2 User priority)>>endobj137 0 obj<</Parent 109 0 R/Next 111 0 R/Dest/subsection.2.8.2/Prev 110 0 R/Title(2.8.2 Less Simple Java Specifications)>>endobj138 0 obj<</Parent 106 0 R/Next 108 0 R/Dest/subsection.2.9.3/Prev 139 0 R/Title(2.9.3 Parallel Jobs with Separate Requirements)>>endobj139 0 obj<</Parent 106 0 R/Next 138 0 R/Dest/subsection.2.9.2/Prev 107 0 R/Title(2.9.2 Parallel Job Submission)>>endobj140 0 obj<</Parent 103 0 R/Next 105 0 R/Dest/subsection.2.10.8/Prev 141 0 R/Title(2.10.8 File Paths in DAGs)>>endobj141 0 obj<</Parent 103 0 R/Next 140 0 R/Dest/subsection.2.10.7/Prev 142 0 R/Title(2.10.7 Job Recovery: The Rescue DAG)>>endobj142 0 obj<</Parent 103 0 R/Next 141 0 R/Dest/subsection.2.10.6/Prev 143 0 R/Title(2.10.6 Advanced Features of DAGMan)>>endobj143 0 obj<</Parent 103 0 R/Next 142 0 R/Dest/subsection.2.10.5/Prev 144 0 R/Title(2.10.5 Job Monitoring, Job Failure, and Job Removal)>>endobj144 0 obj<</Parent 103 0 R/Next 143 0 R/Dest/subsection.2.10.4/Prev 145 0 R/Title(2.10.4 Job Submission)>>endobj145 0 obj<</Parent 103 0 R/Next 144 0 R/Dest/subsection.2.10.3/Prev 146 0 R/Title(2.10.3 Submit Description File)>>endobj146 0 obj<</Parent 103 0 R/Next 145 0 R/Dest/subsection.2.10.2/Prev 104 0 R/Title(2.10.2 Input File Describing the DAG)>>endobj147 0 obj<</Parent 100 0 R/Next 102 0 R/Dest/subsection.2.11.3/Prev 148 0 R/Title(2.11.3 Disk Images)>>endobj148 0 obj<</Parent 100 0 R/Next 147 0 R/Dest/subsection.2.11.2/Prev 101 0 R/Title(2.11.2 Checkpoints)>>endobj149 0 obj<</Parent 94 0 R/Next 96 0 R/Dest/subsection.2.13.4/Prev 150 0 R/Title(2.13.4 Zooming)>>endobj150 0 obj<</Parent 94 0 R/Next 149 0 R/Dest/subsection.2.13.3/Prev 151 0 R/Title(2.13.3 Selecting Jobs)>>endobj151 0 obj<</Parent 94 0 R/Next 150 0 R/Dest/subsection.2.13.2/Prev 95 0 R/Title(2.13.2 Events)>>endobj152 0 obj<</Parent 91 0 R/Next 93 0 R/Dest/subsection.2.14.3/Prev 153 0 R/Title(2.14.3 Condor Daemons That Do Not Run as root)>>endobj153 0 obj<</Parent 91 0 R/Next 152 0 R/Dest/subsection.2.14.2/Prev 92 0 R/Title(2.14.2 NFS Automounter)>>endobj154 0 obj<</Parent 86 0 R/Next 278 0 R/Dest/subsection.3.16.1/Title(3.16.1 Entering a Low Power State)>>endobj155 0 obj<</Parent 86 0 R/Dest/subsection.3.16.5/Prev 276 0 R/Title(3.16.5 Windows Platform Details)>>endobj156 0 obj<</First 157 0 R/Parent 84 0 R/Next 86 0 R/Dest/section.3.15/Count -1/Last 157 0 R/Prev 158 0 R/Title(3.15 Virtual Machines)>>endobj157 0 obj<</Parent 156 0 R/Dest/subsection.3.15.1/Title(3.15.1 Configuration Parameters)>>endobj158 0 obj<</Parent 84 0 R/Next 156 0 R/Dest/section.3.14/Prev 159 0 R/Title(3.14 Java Support Installation)>>endobj159 0 obj<</First 160 0 R/Parent 84 0 R/Next 158 0 R/Dest/section.3.13/Count -12/Last 161 0 R/Prev 162 0 R/Title(3.13 Setting Up for Special Environments)>>endobj160 0 obj<</Parent 159 0 R/Next 275 0 R/Dest/subsection.3.13.1/Title(3.13.1 Using Condor with AFS)>>endobj161 0 obj<</Parent 159 0 R/Dest/subsection.3.13.12/Prev 266 0 R/Title(3.13.12 Concurrency Limits)>>endobj162 0 obj<</First 163 0 R/Parent 84 0 R/Next 159 0 R/Dest/section.3.12/Count -4/Last 164 0 R/Prev 165 0 R/Title(3.12 Quill)>>endobj163 0 obj<</Parent 162 0 R/Next 265 0 R/Dest/subsection.3.12.1/Title(3.12.1 Installation and Configuration)>>endobj164 0 obj<</Parent 162 0 R/Dest/subsection.3.12.4/Prev 264 0 R/Title(3.12.4 Quill and Its RDBMS Schema)>>endobj165 0 obj<</First 166 0 R/Parent 84 0 R/Next 162 0 R/Dest/section.3.11/Count -2/Last 167 0 R/Prev 168 0 R/Title(3.11 The High Availability of Daemons)>>endobj166 0 obj<</Parent 165 0 R/Next 167 0 R/Dest/subsection.3.11.1/Title(3.11.1  High Availability of the Job Queue)>>endobj167 0 obj<</Parent 165 0 R/Dest/subsection.3.11.2/Prev 166 0 R/Title(3.11.2  High Availability of the Central Manager)>>endobj168 0 obj<</First 169 0 R/Parent 84 0 R/Next 165 0 R/Dest/section.3.10/Count -3/Last 170 0 R/Prev 171 0 R/Title(3.10 Pool Management)>>endobj169 0 obj<</Parent 168 0 R/Next 263 0 R/Dest/subsection.3.10.1/Title(3.10.1  Shutting Down and Restarting a Condor Pool)>>endobj170 0 obj<</Parent 168 0 R/Dest/subsection.3.10.3/Prev 263 0 R/Title(3.10.3 Using Dynamic Attributes)>>endobj171 0 obj<</First 172 0 R/Parent 84 0 R/Next 168 0 R/Dest/section.3.9/Count -2/Last 173 0 R/Prev 174 0 R/Title(3.9 DaemonCore)>>endobj172 0 obj<</Parent 171 0 R/Next 173 0 R/Dest/subsection.3.9.1/Title(3.9.1 DaemonCore and Unix signals)>>endobj173 0 obj<</Parent 171 0 R/Dest/subsection.3.9.2/Prev 172 0 R/Title(3.9.2 DaemonCore and Command-line Arguments)>>endobj174 0 obj<</First 175 0 R/Parent 84 0 R/Next 171 0 R/Dest/section.3.8/Count -4/Last 176 0 R/Prev 177 0 R/Title(3.8  The Checkpoint Server)>>endobj175 0 obj<</Parent 174 0 R/Next 262 0 R/Dest/subsection.3.8.1/Title(3.8.1  Preparing to Install a Checkpoint Server)>>endobj176 0 obj<</Parent 174 0 R/Dest/subsection.3.8.4/Prev 261 0 R/Title(3.8.4  Checkpoint Server Domains)>>endobj177 0 obj<</First 178 0 R/Parent 84 0 R/Next 174 0 R/Dest/section.3.7/Count -5/Last 179 0 R/Prev 180 0 R/Title(3.7 Networking \(includes sections on Port Usage and GCB\))>>endobj178 0 obj<</Parent 177 0 R/Next 260 0 R/Dest/subsection.3.7.1/Title(3.7.1 Port Usage in Condor)>>endobj179 0 obj<</Parent 177 0 R/Dest/subsection.3.7.5/Prev 258 0 R/Title(3.7.5 Using TCP to Send Updates to the condor_collector)>>endobj180 0 obj<</First 181 0 R/Parent 84 0 R/Next 177 0 R/Dest/section.3.6/Count -13/Last 182 0 R/Prev 183 0 R/Title(3.6 Security)>>endobj181 0 obj<</Parent 180 0 R/Next 257 0 R/Dest/subsection.3.6.1/Title(3.6.1 Condor's Security Model)>>endobj182 0 obj<</Parent 180 0 R/Dest/subsection.3.6.13/Prev 247 0 R/Title(3.6.13 Support for glexec)>>endobj183 0 obj<</First 184 0 R/Parent 84 0 R/Next 180 0 R/Dest/section.3.5/Count -9/Last 185 0 R/Prev 186 0 R/Title(3.5 Policy Configuration for the condor_startd)>>endobj184 0 obj<</Parent 183 0 R/Next 246 0 R/Dest/subsection.3.5.1/Title(3.5.1  Startd ClassAd Attributes)>>endobj185 0 obj<</Parent 183 0 R/Dest/subsection.3.5.9/Prev 240 0 R/Title(3.5.9 Policy Settings)>>endobj186 0 obj<</First 187 0 R/Parent 84 0 R/Next 183 0 R/Dest/section.3.4/Count -8/Last 188 0 R/Prev 189 0 R/Title(3.4 User Priorities and Negotiation)>>endobj187 0 obj<</Parent 186 0 R/Next 239 0 R/Dest/subsection.3.4.1/Title(3.4.1 Real User Priority \(RUP\))>>endobj188 0 obj<</Parent 186 0 R/Dest/subsection.3.4.8/Prev 234 0 R/Title(3.4.8 Group Quotas)>>endobj189 0 obj<</First 190 0 R/Parent 84 0 R/Next 186 0 R/Dest/section.3.3/Count -34/Last 191 0 R/Prev 192 0 R/Title(3.3 Configuration)>>endobj190 0 obj<</Parent 189 0 R/Next 233 0 R/Dest/subsection.3.3.1/Title(3.3.1 Introduction to Configuration Files)>>endobj191 0 obj<</Parent 189 0 R/Dest/subsection.3.3.34/Prev 202 0 R/Title(3.3.34 condor_rooster Configuration File Macros)>>endobj192 0 obj<</First 193 0 R/Parent 84 0 R/Next 189 0 R/Dest/section.3.2/Count -9/Last 194 0 R/Prev 85 0 R/Title(3.2 Installation)>>endobj193 0 obj<</Parent 192 0 R/Next 201 0 R/Dest/subsection.3.2.1/Title(3.2.1  Obtaining Condor)>>endobj194 0 obj<</Parent 192 0 R/Dest/subsection.3.2.9/Prev 195 0 R/Title(3.2.9 Dynamic Deployment)>>endobj195 0 obj<</Parent 192 0 R/Next 194 0 R/Dest/subsection.3.2.8/Prev 196 0 R/Title(3.2.8  Installing the CondorView Client Contrib Module)>>endobj196 0 obj<</Parent 192 0 R/Next 195 0 R/Dest/subsection.3.2.7/Prev 197 0 R/Title(3.2.7 Upgrading - Installing a Newer Version of Condor)>>endobj197 0 obj<</Parent 192 0 R/Next 196 0 R/Dest/subsection.3.2.6/Prev 198 0 R/Title(3.2.6  RPMs)>>endobj198 0 obj<</Parent 192 0 R/Next 197 0 R/Dest/subsection.3.2.5/Prev 199 0 R/Title(3.2.5 Installation on Windows)>>endobj199 0 obj<</Parent 192 0 R/Next 198 0 R/Dest/subsection.3.2.4/Prev 200 0 R/Title(3.2.4  Condor is installed Under Unix ... now what?)>>endobj200 0 obj<</Parent 192 0 R/Next 199 0 R/Dest/subsection.3.2.3/Prev 201 0 R/Title(3.2.3  Newer Unix Installation Procedure)>>endobj201 0 obj<</Parent 192 0 R/Next 200 0 R/Dest/subsection.3.2.2/Prev 193 0 R/Title(3.2.2 Preparation)>>endobj202 0 obj<</Parent 189 0 R/Next 191 0 R/Dest/subsection.3.3.33/Prev 203 0 R/Title(3.3.33 Configuration File Entries Relating to condor_ssh_to_job)>>endobj203 0 obj<</Parent 189 0 R/Next 202 0 R/Dest/subsection.3.3.32/Prev 204 0 R/Title(3.3.32  Configuration File Macros Affecting APIs)>>endobj204 0 obj<</Parent 189 0 R/Next 203 0 R/Dest/subsection.3.3.31/Prev 205 0 R/Title(3.3.31 MyProxy Configuration File Macros)>>endobj205 0 obj<</Parent 189 0 R/Next 204 0 R/Dest/subsection.3.3.30/Prev 206 0 R/Title(3.3.30 Configuration File Entries Relating to Quill)>>endobj206 0 obj<</Parent 189 0 R/Next 205 0 R/Dest/subsection.3.3.29/Prev 207 0 R/Title(3.3.29 Configuration File Entries Relating to High Availability)>>endobj207 0 obj<</Parent 189 0 R/Next 206 0 R/Dest/subsection.3.3.28/Prev 208 0 R/Title(3.3.28 Configuration File Entries Relating to Virtual Machines)>>endobj208 0 obj<</Parent 189 0 R/Next 207 0 R/Dest/subsection.3.3.27/Prev 209 0 R/Title(3.3.27 Configuration File Entries Relating to PrivSep)>>endobj209 0 obj<</Parent 189 0 R/Next 208 0 R/Dest/subsection.3.3.26/Prev 210 0 R/Title(3.3.26 Configuration File Entries Relating to Security)>>endobj210 0 obj<</Parent 189 0 R/Next 209 0 R/Dest/subsection.3.3.25/Prev 211 0 R/Title(3.3.25 Configuration File Entries for DAGMan)>>endobj211 0 obj<</Parent 189 0 R/Next 210 0 R/Dest/subsection.3.3.24/Prev 212 0 R/Title(3.3.24 Configuration File Entries Relating to Grid Usage and Glidein)>>endobj212 0 obj<</Parent 189 0 R/Next 211 0 R/Dest/subsection.3.3.23/Prev 213 0 R/Title(3.3.23 Grid Monitor Configuration File Entries)>>endobj213 0 obj<</Parent 189 0 R/Next 212 0 R/Dest/subsection.3.3.22/Prev 214 0 R/Title(3.3.22 condor_lease_manager Configuration File Entries)>>endobj214 0 obj<</Parent 189 0 R/Next 213 0 R/Dest/subsection.3.3.21/Prev 215 0 R/Title(3.3.21 condor_job_router Configuration File Entries)>>endobj215 0 obj<</Parent 189 0 R/Next 214 0 R/Dest/subsection.3.3.20/Prev 216 0 R/Title(3.3.20 condor_gridmanager Configuration File Entries)>>endobj216 0 obj<</Parent 189 0 R/Next 215 0 R/Dest/subsection.3.3.19/Prev 217 0 R/Title(3.3.19 condor_credd Configuration File Macros)>>endobj217 0 obj<</Parent 189 0 R/Next 216 0 R/Dest/subsection.3.3.18/Prev 218 0 R/Title(3.3.18 condor_procd Configuration File Macros)>>endobj218 0 obj<</Parent 189 0 R/Next 217 0 R/Dest/subsection.3.3.17/Prev 219 0 R/Title(3.3.17 condor_negotiator Configuration File Entries)>>endobj219 0 obj<</Parent 189 0 R/Next 218 0 R/Dest/subsection.3.3.16/Prev 220 0 R/Title(3.3.16 condor_collector Configuration File Entries)>>endobj220 0 obj<</Parent 189 0 R/Next 219 0 R/Dest/subsection.3.3.15/Prev 221 0 R/Title(3.3.15 condor_preen Configuration File Entries)>>endobj221 0 obj<</Parent 189 0 R/Next 220 0 R/Dest/subsection.3.3.14/Prev 222 0 R/Title(3.3.14 condor_submit Configuration File Entries)>>endobj222 0 obj<</Parent 189 0 R/Next 221 0 R/Dest/subsection.3.3.13/Prev 223 0 R/Title(3.3.13 condor_starter Configuration File Entries)>>endobj223 0 obj<</Parent 189 0 R/Next 222 0 R/Dest/subsection.3.3.12/Prev 224 0 R/Title(3.3.12 condor_shadow Configuration File Entries)>>endobj224 0 obj<</Parent 189 0 R/Next 223 0 R/Dest/subsection.3.3.11/Prev 225 0 R/Title(3.3.11 condor_schedd Configuration File Entries)>>endobj225 0 obj<</Parent 189 0 R/Next 224 0 R/Dest/subsection.3.3.10/Prev 226 0 R/Title(3.3.10 condor_startd Configuration File Macros)>>endobj226 0 obj<</Parent 189 0 R/Next 225 0 R/Dest/subsection.3.3.9/Prev 227 0 R/Title(3.3.9 condor_master Configuration File Macros)>>endobj227 0 obj<</Parent 189 0 R/Next 226 0 R/Dest/subsection.3.3.8/Prev 228 0 R/Title(3.3.8 Checkpoint Server Configuration File Macros)>>endobj228 0 obj<</Parent 189 0 R/Next 227 0 R/Dest/subsection.3.3.7/Prev 229 0 R/Title(3.3.7 Shared File System Configuration File Macros)>>endobj229 0 obj<</Parent 189 0 R/Next 228 0 R/Dest/subsection.3.3.6/Prev 230 0 R/Title(3.3.6 Network-Related Configuration File Entries)>>endobj230 0 obj<</Parent 189 0 R/Next 229 0 R/Dest/subsection.3.3.5/Prev 231 0 R/Title(3.3.5 DaemonCore Configuration File Entries)>>endobj231 0 obj<</Parent 189 0 R/Next 230 0 R/Dest/subsection.3.3.4/Prev 232 0 R/Title(3.3.4 Daemon Logging Configuration File Entries)>>endobj232 0 obj<</Parent 189 0 R/Next 231 0 R/Dest/subsection.3.3.3/Prev 233 0 R/Title(3.3.3 Condor-wide Configuration File Entries)>>endobj233 0 obj<</Parent 189 0 R/Next 232 0 R/Dest/subsection.3.3.2/Prev 190 0 R/Title(3.3.2 Special Macros)>>endobj234 0 obj<</Parent 186 0 R/Next 188 0 R/Dest/subsection.3.4.7/Prev 235 0 R/Title(3.4.7 Group Accounting)>>endobj235 0 obj<</Parent 186 0 R/Next 234 0 R/Dest/subsection.3.4.6/Prev 236 0 R/Title(3.4.6 The Layperson's Description of the Pie Spin and Pie Slice)>>endobj236 0 obj<</Parent 186 0 R/Next 235 0 R/Dest/subsection.3.4.5/Prev 237 0 R/Title(3.4.5 Negotiation)>>endobj237 0 obj<</Parent 186 0 R/Next 236 0 R/Dest/subsection.3.4.4/Prev 238 0 R/Title(3.4.4 Priority Calculation)>>endobj238 0 obj<</Parent 186 0 R/Next 237 0 R/Dest/subsection.3.4.3/Prev 239 0 R/Title(3.4.3 Priorities in Negotiation and Preemption)>>endobj239 0 obj<</Parent 186 0 R/Next 238 0 R/Dest/subsection.3.4.2/Prev 187 0 R/Title(3.4.2 Effective User Priority \(EUP\))>>endobj240 0 obj<</Parent 183 0 R/Next 185 0 R/Dest/subsection.3.5.8/Prev 241 0 R/Title(3.5.8  State/Activity Transition Expression Summary)>>endobj241 0 obj<</Parent 183 0 R/Next 240 0 R/Dest/subsection.3.5.7/Prev 242 0 R/Title(3.5.7  State and Activity Transitions)>>endobj242 0 obj<</Parent 183 0 R/Next 241 0 R/Dest/subsection.3.5.6/Prev 243 0 R/Title(3.5.6  Machine Activities)>>endobj243 0 obj<</Parent 183 0 R/Next 242 0 R/Dest/subsection.3.5.5/Prev 244 0 R/Title(3.5.5  Machine States)>>endobj244 0 obj<</Parent 183 0 R/Next 243 0 R/Dest/subsection.3.5.4/Prev 245 0 R/Title(3.5.4  The RANK   expression)>>endobj245 0 obj<</Parent 183 0 R/Next 244 0 R/Dest/subsection.3.5.3/Prev 246 0 R/Title(3.5.3 The IS_VALID_CHECKPOINT_PLATFORM   expression)>>endobj246 0 obj<</Parent 183 0 R/Next 245 0 R/Dest/subsection.3.5.2/Prev 184 0 R/Title(3.5.2  The START expression)>>endobj247 0 obj<</Parent 180 0 R/Next 182 0 R/Dest/subsection.3.6.12/Prev 248 0 R/Title(3.6.12 Privilege Separation)>>endobj248 0 obj<</Parent 180 0 R/Next 247 0 R/Dest/subsection.3.6.11/Prev 249 0 R/Title(3.6.11 User Accounts in Condor)>>endobj249 0 obj<</Parent 180 0 R/Next 248 0 R/Dest/subsection.3.6.10/Prev 250 0 R/Title(3.6.10 Using Condor w/ Firewalls, Private Networks, and NATs)>>endobj250 0 obj<</Parent 180 0 R/Next 249 0 R/Dest/subsection.3.6.9/Prev 251 0 R/Title(3.6.9 Host-Based Security in Condor)>>endobj251 0 obj<</Parent 180 0 R/Next 250 0 R/Dest/subsection.3.6.8/Prev 252 0 R/Title(3.6.8 Security Sessions)>>endobj252 0 obj<</Parent 180 0 R/Next 251 0 R/Dest/subsection.3.6.7/Prev 253 0 R/Title(3.6.7 Authorization)>>endobj253 0 obj<</Parent 180 0 R/Next 252 0 R/Dest/subsection.3.6.6/Prev 254 0 R/Title(3.6.6 Integrity)>>endobj254 0 obj<</Parent 180 0 R/Next 253 0 R/Dest/subsection.3.6.5/Prev 255 0 R/Title(3.6.5 Encryption)>>endobj255 0 obj<</Parent 180 0 R/Next 254 0 R/Dest/subsection.3.6.4/Prev 256 0 R/Title(3.6.4 The Unified Map File for Authentication)>>endobj256 0 obj<</Parent 180 0 R/Next 255 0 R/Dest/subsection.3.6.3/Prev 257 0 R/Title(3.6.3 Authentication)>>endobj257 0 obj<</Parent 180 0 R/Next 256 0 R/Dest/subsection.3.6.2/Prev 181 0 R/Title(3.6.2 Security Negotiation)>>endobj258 0 obj<</Parent 177 0 R/Next 179 0 R/Dest/subsection.3.7.4/Prev 259 0 R/Title(3.7.4 Generic Connection Brokering \(GCB\))>>endobj259 0 obj<</Parent 177 0 R/Next 258 0 R/Dest/subsection.3.7.3/Prev 260 0 R/Title(3.7.3 Condor Connection Brokering \(CCB\))>>endobj260 0 obj<</Parent 177 0 R/Next 259 0 R/Dest/subsection.3.7.2/Prev 178 0 R/Title(3.7.2 Configuring Condor for Machines With Multiple Network Interfaces )>>endobj261 0 obj<</Parent 174 0 R/Next 176 0 R/Dest/subsection.3.8.3/Prev 262 0 R/Title(3.8.3  Configuring the Pool to Use Multiple Checkpoint Servers)>>endobj262 0 obj<</Parent 174 0 R/Next 261 0 R/Dest/subsection.3.8.2/Prev 175 0 R/Title(3.8.2  Installing the Checkpoint Server Module)>>endobj263 0 obj<</Parent 168 0 R/Next 170 0 R/Dest/subsection.3.10.2/Prev 169 0 R/Title(3.10.2 Reconfiguring a Condor Pool)>>endobj264 0 obj<</Parent 162 0 R/Next 164 0 R/Dest/subsection.3.12.3/Prev 265 0 R/Title(3.12.3 Quill and Security)>>endobj265 0 obj<</Parent 162 0 R/Next 264 0 R/Dest/subsection.3.12.2/Prev 163 0 R/Title(3.12.2 Four Usage Examples)>>endobj266 0 obj<</Parent 159 0 R/Next 161 0 R/Dest/subsection.3.13.11/Prev 267 0 R/Title(3.13.11 Limiting Resource Usage)>>endobj267 0 obj<</Parent 159 0 R/Next 266 0 R/Dest/subsection.3.13.10/Prev 268 0 R/Title(3.13.10 Group ID-Based Process Tracking)>>endobj268 0 obj<</Parent 159 0 R/Next 267 0 R/Dest/subsection.3.13.9/Prev 269 0 R/Title(3.13.9 Configuring Condor for Running Backfill Jobs)>>endobj269 0 obj<</Parent 159 0 R/Next 268 0 R/Dest/subsection.3.13.8/Prev 270 0 R/Title(3.13.8  Condor's Dedicated Scheduling)>>endobj270 0 obj<</Parent 159 0 R/Next 269 0 R/Dest/subsection.3.13.7/Prev 271 0 R/Title(3.13.7  Configuring The Startd for SMP Machines)>>endobj271 0 obj<</Parent 159 0 R/Next 270 0 R/Dest/subsection.3.13.6/Prev 272 0 R/Title(3.13.6  Running Jobs within VMware or Xen)>>endobj272 0 obj<</Parent 159 0 R/Next 271 0 R/Dest/subsection.3.13.5/Prev 273 0 R/Title(3.13.5  Configuring The CondorView Server)>>endobj273 0 obj<</Parent 159 0 R/Next 272 0 R/Dest/subsection.3.13.4/Prev 274 0 R/Title(3.13.4 The condor_kbdd)>>endobj274 0 obj<</Parent 159 0 R/Next 273 0 R/Dest/subsection.3.13.3/Prev 275 0 R/Title(3.13.3 Full Installation of condor_compile)>>endobj275 0 obj<</Parent 159 0 R/Next 274 0 R/Dest/subsection.3.13.2/Prev 160 0 R/Title(3.13.2 Configuring Condor for Multiple Platforms)>>endobj276 0 obj<</Parent 86 0 R/Next 155 0 R/Dest/subsection.3.16.4/Prev 277 0 R/Title(3.16.4 Linux Platform Details)>>endobj277 0 obj<</Parent 86 0 R/Next 276 0 R/Dest/subsection.3.16.3/Prev 278 0 R/Title(3.16.3 Keeping a ClassAd for a Hibernating Machine)>>endobj278 0 obj<</Parent 86 0 R/Next 277 0 R/Dest/subsection.3.16.2/Prev 154 0 R/Title(3.16.2 Returning From a Low Power State)>>endobj279 0 obj<</Parent 85 0 R/Next 280 0 R/Dest/subsection.3.1.1/Title(3.1.1 The Different Roles a Machine Can Play)>>endobj280 0 obj<</Parent 85 0 R/Dest/subsection.3.1.2/Prev 279 0 R/Title(3.1.2 The Condor Daemons)>>endobj281 0 obj<</Parent 83 0 R/Next 310 0 R/Dest/subsection.4.6.1/Title(4.6.1 Client Interactions)>>endobj282 0 obj<</Parent 83 0 R/Dest/subsection.4.6.10/Prev 303 0 R/Title(4.6.10 Checkpoint Library Interface)>>endobj283 0 obj<</First 284 0 R/Parent 81 0 R/Next 83 0 R/Dest/section.4.5/Count -5/Last 285 0 R/Prev 286 0 R/Title(4.5 Application Program Interfaces)>>endobj284 0 obj<</Parent 283 0 R/Next 302 0 R/Dest/subsection.4.5.1/Title(4.5.1  Web Service)>>endobj285 0 obj<</Parent 283 0 R/Dest/subsection.4.5.5/Prev 300 0 R/Title(4.5.5  The Condor Perl Module)>>endobj286 0 obj<</First 287 0 R/Parent 81 0 R/Next 283 0 R/Dest/section.4.4/Count -2/Last 288 0 R/Prev 289 0 R/Title(4.4 Job Hooks)>>endobj287 0 obj<</Parent 286 0 R/Next 288 0 R/Dest/subsection.4.4.1/Title(4.4.1  Hooks that Fetch Work)>>endobj288 0 obj<</Parent 286 0 R/Dest/subsection.4.4.2/Prev 287 0 R/Title(4.4.2  Hooks for a Job Router)>>endobj289 0 obj<</First 290 0 R/Parent 81 0 R/Next 286 0 R/Dest/section.4.3/Count -5/Last 291 0 R/Prev 292 0 R/Title(4.3 Computing On Demand \(COD\))>>endobj290 0 obj<</Parent 289 0 R/Next 299 0 R/Dest/subsection.4.3.1/Title(4.3.1  Overview of How COD Works)>>endobj291 0 obj<</Parent 289 0 R/Dest/subsection.4.3.5/Prev 297 0 R/Title(4.3.5 Limitations of COD Support in Condor)>>endobj292 0 obj<</First 293 0 R/Parent 81 0 R/Next 289 0 R/Dest/section.4.2/Count -4/Last 294 0 R/Prev 82 0 R/Title(4.2  Condor's Checkpoint Mechanism)>>endobj293 0 obj<</Parent 292 0 R/Next 296 0 R/Dest/subsection.4.2.1/Title(4.2.1 Standalone Checkpointing)>>endobj294 0 obj<</Parent 292 0 R/Dest/subsection.4.2.4/Prev 295 0 R/Title(4.2.4 Checkpoint Library Interface)>>endobj295 0 obj<</Parent 292 0 R/Next 294 0 R/Dest/subsection.4.2.3/Prev 296 0 R/Title(4.2.3 Checkpoint Warnings)>>endobj296 0 obj<</Parent 292 0 R/Next 295 0 R/Dest/subsection.4.2.2/Prev 293 0 R/Title(4.2.2 Checkpoint Safety)>>endobj297 0 obj<</Parent 289 0 R/Next 291 0 R/Dest/subsection.4.3.4/Prev 298 0 R/Title(4.3.4  Managing COD Resource Claims)>>endobj298 0 obj<</Parent 289 0 R/Next 297 0 R/Dest/subsection.4.3.3/Prev 299 0 R/Title(4.3.3  Defining a COD Application)>>endobj299 0 obj<</Parent 289 0 R/Next 298 0 R/Dest/subsection.4.3.2/Prev 290 0 R/Title(4.3.2  Authorizing Users to Create and Manage COD Claims)>>endobj300 0 obj<</Parent 283 0 R/Next 285 0 R/Dest/subsection.4.5.4/Prev 301 0 R/Title(4.5.4  The Condor GAHP)>>endobj301 0 obj<</Parent 283 0 R/Next 300 0 R/Dest/subsection.4.5.3/Prev 302 0 R/Title(4.5.3  The Command Line Interface)>>endobj302 0 obj<</Parent 283 0 R/Next 301 0 R/Dest/subsection.4.5.2/Prev 284 0 R/Title(4.5.2  The DRMAA API)>>endobj303 0 obj<</Parent 83 0 R/Next 282 0 R/Dest/subsection.4.6.9/Prev 304 0 R/Title(4.6.9 Checkpoint Warnings)>>endobj304 0 obj<</Parent 83 0 R/Next 303 0 R/Dest/subsection.4.6.8/Prev 305 0 R/Title(4.6.8 Checkpoint Safety)>>endobj305 0 obj<</Parent 83 0 R/Next 304 0 R/Dest/subsection.4.6.7/Prev 306 0 R/Title(4.6.7 Standalone Checkpointing)>>endobj306 0 obj<</Parent 83 0 R/Next 305 0 R/Dest/subsection.4.6.6/Prev 307 0 R/Title(4.6.6 Recovery)>>endobj307 0 obj<</Parent 83 0 R/Next 306 0 R/Dest/subsection.4.6.5/Prev 308 0 R/Title(4.6.5 Setup)>>endobj308 0 obj<</Parent 83 0 R/Next 307 0 R/Dest/subsection.4.6.4/Prev 309 0 R/Title(4.6.4 Database Schema)>>endobj309 0 obj<</Parent 83 0 R/Next 308 0 R/Dest/subsection.4.6.3/Prev 310 0 R/Title(4.6.3 Monitoring Work)>>endobj310 0 obj<</Parent 83 0 R/Next 309 0 R/Dest/subsection.4.6.2/Prev 281 0 R/Title(4.6.2 Submitting Work)>>endobj311 0 obj<</Parent 82 0 R/Next 313 0 R/Dest/subsection.4.1.1/Title(4.1.1 Syntax)>>endobj312 0 obj<</Parent 82 0 R/Dest/subsection.4.1.3/Prev 313 0 R/Title(4.1.3 ClassAds in the Condor System)>>endobj313 0 obj<</Parent 82 0 R/Next 312 0 R/Dest/subsection.4.1.2/Prev 311 0 R/Title(4.1.2 Evaluation Semantics)>>endobj314 0 obj<</Parent 80 0 R/Next 336 0 R/Dest/subsection.5.6.1/Title(5.6.1 Routing Mechanism)>>endobj315 0 obj<</Parent 80 0 R/Dest/subsection.5.6.5/Prev 334 0 R/Title(5.6.5 Example: constructing the routing table from ReSS)>>endobj316 0 obj<</Parent 78 0 R/Next 80 0 R/Dest/section.5.5/Prev 317 0 R/Title(5.5 Dynamic Deployment)>>endobj317 0 obj<</First 318 0 R/Parent 78 0 R/Next 316 0 R/Dest/section.5.4/Count -3/Last 319 0 R/Prev 320 0 R/Title(5.4 Glidein)>>endobj318 0 obj<</Parent 317 0 R/Next 333 0 R/Dest/subsection.5.4.1/Title(5.4.1 What condor_glidein Does)>>endobj319 0 obj<</Parent 317 0 R/Dest/subsection.5.4.3/Prev 333 0 R/Title(5.4.3 Running Jobs on the Remote Grid Resource After Glidein )>>endobj320 0 obj<</First 321 0 R/Parent 78 0 R/Next 317 0 R/Dest/section.5.3/Count -9/Last 322 0 R/Prev 323 0 R/Title(5.3 The Grid Universe)>>endobj321 0 obj<</Parent 320 0 R/Next 332 0 R/Dest/subsection.5.3.1/Title(5.3.1 Condor-C, The condor Grid Type )>>endobj322 0 obj<</Parent 320 0 R/Dest/subsection.5.3.9/Prev 326 0 R/Title(5.3.9 Matchmaking in the Grid Universe)>>endobj323 0 obj<</First 324 0 R/Parent 78 0 R/Next 320 0 R/Dest/section.5.2/Count -2/Last 325 0 R/Prev 79 0 R/Title(5.2 Connecting Condor Pools with Flocking)>>endobj324 0 obj<</Parent 323 0 R/Next 325 0 R/Dest/subsection.5.2.1/Title(5.2.1 Flocking Configuration)>>endobj325 0 obj<</Parent 323 0 R/Dest/subsection.5.2.2/Prev 324 0 R/Title(5.2.2 Job Considerations)>>endobj326 0 obj<</Parent 320 0 R/Next 322 0 R/Dest/subsection.5.3.8/Prev 327 0 R/Title(5.3.8 The cream Grid Type )>>endobj327 0 obj<</Parent 320 0 R/Next 326 0 R/Dest/subsection.5.3.7/Prev 328 0 R/Title(5.3.7 The amazon Grid Type )>>endobj328 0 obj<</Parent 320 0 R/Next 327 0 R/Dest/subsection.5.3.6/Prev 329 0 R/Title(5.3.6 The lsf Grid Type )>>endobj329 0 obj<</Parent 320 0 R/Next 328 0 R/Dest/subsection.5.3.5/Prev 330 0 R/Title(5.3.5 The pbs Grid Type )>>endobj330 0 obj<</Parent 320 0 R/Next 329 0 R/Dest/subsection.5.3.4/Prev 331 0 R/Title(5.3.4 The unicore Grid Type )>>endobj331 0 obj<</Parent 320 0 R/Next 330 0 R/Dest/subsection.5.3.3/Prev 332 0 R/Title(5.3.3 The nordugrid Grid Type )>>endobj332 0 obj<</Parent 320 0 R/Next 331 0 R/Dest/subsection.5.3.2/Prev 321 0 R/Title(5.3.2 Condor-G, the gt2, gt4, and gt5 Grid Types)>>endobj333 0 obj<</Parent 317 0 R/Next 319 0 R/Dest/subsection.5.4.2/Prev 318 0 R/Title(5.4.2 Configuration Requirements in the Local Pool)>>endobj334 0 obj<</Parent 80 0 R/Next 315 0 R/Dest/subsection.5.6.4/Prev 335 0 R/Title(5.6.4  Routing Table Entry ClassAd Attributes)>>endobj335 0 obj<</Parent 80 0 R/Next 334 0 R/Dest/subsection.5.6.3/Prev 336 0 R/Title(5.6.3  An Example Configuration)>>endobj336 0 obj<</Parent 80 0 R/Next 335 0 R/Dest/subsection.5.6.2/Prev 314 0 R/Title(5.6.2 Job Submission with Job Routing Capability)>>endobj337 0 obj<</Parent 77 0 R/Next 338 0 R/Dest/subsection.6.4.1/Title(6.4.1 AIX 5.2L)>>endobj338 0 obj<</Parent 77 0 R/Dest/subsection.6.4.2/Prev 337 0 R/Title(6.4.2 AIX 5.1L)>>endobj339 0 obj<</Parent 75 0 R/Next 77 0 R/Dest/section.6.3/Prev 340 0 R/Title(6.3 Macintosh OS X)>>endobj340 0 obj<</First 341 0 R/Parent 75 0 R/Next 339 0 R/Dest/section.6.2/Count -11/Last 342 0 R/Prev 76 0 R/Title(6.2 Microsoft Windows)>>endobj341 0 obj<</Parent 340 0 R/Next 351 0 R/Dest/subsection.6.2.1/Title(6.2.1 Limitations under Windows)>>endobj342 0 obj<</Parent 340 0 R/Dest/subsection.6.2.11/Prev 343 0 R/Title(6.2.11 Some differences between Condor for Unix -vs- Condor for Windows)>>endobj343 0 obj<</Parent 340 0 R/Next 342 0 R/Dest/subsection.6.2.10/Prev 344 0 R/Title(6.2.10 Interoperability between Condor for Unix and Condor for Windows)>>endobj344 0 obj<</Parent 340 0 R/Next 343 0 R/Dest/subsection.6.2.9/Prev 345 0 R/Title(6.2.9 Network files and Condor)>>endobj345 0 obj<</Parent 340 0 R/Next 344 0 R/Dest/subsection.6.2.8/Prev 346 0 R/Title(6.2.8 Security Considerations in Condor for Windows)>>endobj346 0 obj<</Parent 340 0 R/Next 345 0 R/Dest/subsection.6.2.7/Prev 347 0 R/Title(6.2.7 Details on how Condor for Windows starts/stops a job)>>endobj347 0 obj<</Parent 340 0 R/Next 346 0 R/Dest/subsection.6.2.6/Prev 348 0 R/Title(6.2.6 Using Windows Scripts as Job Executables)>>endobj348 0 obj<</Parent 340 0 R/Next 347 0 R/Dest/subsection.6.2.5/Prev 349 0 R/Title(6.2.5 Executing Jobs with the User's Profile Loaded)>>endobj349 0 obj<</Parent 340 0 R/Next 348 0 R/Dest/subsection.6.2.4/Prev 350 0 R/Title(6.2.4 Executing Jobs as the Submitting User)>>endobj350 0 obj<</Parent 340 0 R/Next 349 0 R/Dest/subsection.6.2.3/Prev 351 0 R/Title(6.2.3 Secure Password Storage)>>endobj351 0 obj<</Parent 340 0 R/Next 350 0 R/Dest/subsection.6.2.2/Prev 341 0 R/Title(6.2.2 Supported Features under Windows)>>endobj352 0 obj<</Parent 76 0 R/Next 354 0 R/Dest/subsection.6.1.1/Title(6.1.1 Linux Kernel-specific Information)>>endobj353 0 obj<</Parent 76 0 R/Dest/subsection.6.1.3/Prev 354 0 R/Title(6.1.3 Red Hat Fedora 1, 2, and 3)>>endobj354 0 obj<</Parent 76 0 R/Next 353 0 R/Dest/subsection.6.1.2/Prev 352 0 R/Title(6.1.2 Red Hat Version 9.x)>>endobj355 0 obj<</Parent 72 0 R/Next 74 0 R/Dest/section.7.6/Prev 356 0 R/Title(7.6 Troubleshooting)>>endobj356 0 obj<</Parent 72 0 R/Next 355 0 R/Dest/section.7.5/Prev 357 0 R/Title(7.5 Grid Computing)>>endobj357 0 obj<</Parent 72 0 R/Next 356 0 R/Dest/section.7.4/Prev 358 0 R/Title(7.4 Condor on Windows)>>endobj358 0 obj<</Parent 72 0 R/Next 357 0 R/Dest/section.7.3/Prev 359 0 R/Title(7.3 Running Condor Jobs)>>endobj359 0 obj<</Parent 72 0 R/Next 358 0 R/Dest/section.7.2/Prev 73 0 R/Title(7.2 Setting up Condor)>>endobj360 0 obj<</Parent 69 0 R/Next 71 0 R/Dest/section.8.6/Prev 361 0 R/Title(8.6 Development Release Series 7.1)>>endobj361 0 obj<</Parent 69 0 R/Next 360 0 R/Dest/section.8.5/Prev 362 0 R/Title(8.5 Stable Release Series 7.2)>>endobj362 0 obj<</Parent 69 0 R/Next 361 0 R/Dest/section.8.4/Prev 363 0 R/Title(8.4 Development Release Series 7.3)>>endobj363 0 obj<</Parent 69 0 R/Next 362 0 R/Dest/section.8.3/Prev 364 0 R/Title(8.3 Stable Release Series 7.4)>>endobj364 0 obj<</Parent 69 0 R/Next 363 0 R/Dest/section.8.2/Prev 70 0 R/Title(8.2 Development Release Series 7.5)>>endobj365 0 obj<</Parent 70 0 R/Next 367 0 R/Dest/subsection.8.1.1/Title(8.1.1  Condor Version Number Scheme)>>endobj366 0 obj<</Parent 70 0 R/Dest/subsection.8.1.3/Prev 367 0 R/Title(8.1.3  The Development Release Series)>>endobj367 0 obj<</Parent 70 0 R/Next 366 0 R/Dest/subsection.8.1.2/Prev 365 0 R/Title(8.1.2 The Stable Release Series)>>endobj368 0 obj<</Parent 66 0 R/Next 68 0 R/Dest/section*.754/Prev 369 0 R/Title(uniq_pid_midwife)>>endobj369 0 obj<</Parent 66 0 R/Next 368 0 R/Dest/section*.746/Prev 370 0 R/Title(install_release)>>endobj370 0 obj<</Parent 66 0 R/Next 369 0 R/Dest/section*.738/Prev 371 0 R/Title(filelock_undertaker)>>endobj371 0 obj<</Parent 66 0 R/Next 370 0 R/Dest/section*.730/Prev 372 0 R/Title(filelock_midwife)>>endobj372 0 obj<</Parent 66 0 R/Next 371 0 R/Dest/section*.721/Prev 373 0 R/Title(condor_wait)>>endobj373 0 obj<</Parent 66 0 R/Next 372 0 R/Dest/section*.714/Prev 374 0 R/Title(condor_version)>>endobj374 0 obj<</Parent 66 0 R/Next 373 0 R/Dest/section*.705/Prev 375 0 R/Title(condor_vacate_job)>>endobj375 0 obj<</Parent 66 0 R/Next 374 0 R/Dest/section*.697/Prev 376 0 R/Title(condor_vacate)>>endobj376 0 obj<</Parent 66 0 R/Next 375 0 R/Dest/section*.690/Prev 377 0 R/Title(condor_userprio)>>endobj377 0 obj<</Parent 66 0 R/Next 376 0 R/Dest/section*.682/Prev 378 0 R/Title(condor_userlog)>>endobj378 0 obj<</Parent 66 0 R/Next 377 0 R/Dest/section*.674/Prev 379 0 R/Title(condor_updates_stats)>>endobj379 0 obj<</Parent 66 0 R/Next 378 0 R/Dest/section*.667/Prev 380 0 R/Title(condor_transfer_data)>>endobj380 0 obj<</Parent 66 0 R/Next 379 0 R/Dest/section*.658/Prev 381 0 R/Title(condor_submit_dag)>>endobj381 0 obj<</Parent 66 0 R/Next 380 0 R/Dest/section*.648/Prev 382 0 R/Title(condor_submit)>>endobj382 0 obj<</Parent 66 0 R/Next 381 0 R/Dest/section*.641/Prev 383 0 R/Title(condor_store_cred)>>endobj383 0 obj<</Parent 66 0 R/Next 382 0 R/Dest/section*.632/Prev 384 0 R/Title(condor_status)>>endobj384 0 obj<</Parent 66 0 R/Next 383 0 R/Dest/section*.623/Prev 385 0 R/Title(condor_stats)>>endobj385 0 obj<</Parent 66 0 R/Next 384 0 R/Dest/section*.615/Prev 386 0 R/Title(condor_ssh_to_job)>>endobj386 0 obj<</Parent 66 0 R/Next 385 0 R/Dest/section*.607/Prev 387 0 R/Title(condor_set_shutdown)>>endobj387 0 obj<</Parent 66 0 R/Next 386 0 R/Dest/section*.597/Prev 388 0 R/Title(condor_run)>>endobj388 0 obj<</Parent 66 0 R/Next 387 0 R/Dest/section*.590/Prev 389 0 R/Title(condor_router_history)>>endobj389 0 obj<</Parent 66 0 R/Next 388 0 R/Dest/section*.581/Prev 390 0 R/Title(condor_rm)>>endobj390 0 obj<</Parent 66 0 R/Next 389 0 R/Dest/section*.573/Prev 391 0 R/Title(condor_restart)>>endobj391 0 obj<</Parent 66 0 R/Next 390 0 R/Dest/section*.565/Prev 392 0 R/Title(condor_reschedule)>>endobj392 0 obj<</Parent 66 0 R/Next 391 0 R/Dest/section*.556/Prev 393 0 R/Title(condor_release)>>endobj393 0 obj<</Parent 66 0 R/Next 392 0 R/Dest/section*.549/Prev 394 0 R/Title(condor_reconfig_schedd)>>endobj394 0 obj<</Parent 66 0 R/Next 393 0 R/Dest/section*.541/Prev 395 0 R/Title(condor_reconfig)>>endobj395 0 obj<</Parent 66 0 R/Next 394 0 R/Dest/section*.532/Prev 396 0 R/Title(condor_qedit)>>endobj396 0 obj<</Parent 66 0 R/Next 395 0 R/Dest/section*.523/Prev 397 0 R/Title(condor_q)>>endobj397 0 obj<</Parent 66 0 R/Next 396 0 R/Dest/section*.516/Prev 398 0 R/Title(condor_prio)>>endobj398 0 obj<</Parent 66 0 R/Next 397 0 R/Dest/section*.509/Prev 399 0 R/Title(condor_preen)>>endobj399 0 obj<</Parent 66 0 R/Next 398 0 R/Dest/section*.502/Prev 400 0 R/Title(condor_power)>>endobj400 0 obj<</Parent 66 0 R/Next 399 0 R/Dest/section*.494/Prev 401 0 R/Title(condor_on)>>endobj401 0 obj<</Parent 66 0 R/Next 400 0 R/Dest/section*.486/Prev 402 0 R/Title(condor_off)>>endobj402 0 obj<</Parent 66 0 R/Next 401 0 R/Dest/section*.479/Prev 403 0 R/Title(condor_master_off)>>endobj403 0 obj<</Parent 66 0 R/Next 402 0 R/Dest/section*.473/Prev 404 0 R/Title(condor_master)>>endobj404 0 obj<</Parent 66 0 R/Next 403 0 R/Dest/section*.466/Prev 405 0 R/Title(condor_load_history)>>endobj405 0 obj<</Parent 66 0 R/Next 404 0 R/Dest/section*.457/Prev 406 0 R/Title(condor_hold)>>endobj406 0 obj<</Parent 66 0 R/Next 405 0 R/Dest/section*.449/Prev 407 0 R/Title(condor_history)>>endobj407 0 obj<</Parent 66 0 R/Next 406 0 R/Dest/section*.438/Prev 408 0 R/Title(condor_glidein)>>endobj408 0 obj<</Parent 66 0 R/Next 407 0 R/Dest/section*.429/Prev 409 0 R/Title(condor_findhost)>>endobj409 0 obj<</Parent 66 0 R/Next 408 0 R/Dest/section*.421/Prev 410 0 R/Title(condor_fetchlog)>>endobj410 0 obj<</Parent 66 0 R/Next 409 0 R/Dest/section*.413/Prev 411 0 R/Title(condor_dbq.pl)>>endobj411 0 obj<</Parent 66 0 R/Next 410 0 R/Dest/section*.405/Prev 412 0 R/Title(condor_dagman)>>endobj412 0 obj<</Parent 66 0 R/Next 411 0 R/Dest/section*.399/Prev 413 0 R/Title(condor_convert_history)>>endobj413 0 obj<</Parent 66 0 R/Next 412 0 R/Dest/section*.391/Prev 414 0 R/Title(condor_configure)>>endobj414 0 obj<</Parent 66 0 R/Next 413 0 R/Dest/section*.383/Prev 415 0 R/Title(condor_config_val)>>endobj415 0 obj<</Parent 66 0 R/Next 414 0 R/Dest/section*.376/Prev 416 0 R/Title(condor_config_bind)>>endobj416 0 obj<</Parent 66 0 R/Next 415 0 R/Dest/section*.370/Prev 417 0 R/Title(condor_compile)>>endobj417 0 obj<</Parent 66 0 R/Next 416 0 R/Dest/section*.361/Prev 418 0 R/Title(condor_cold_stop)>>endobj418 0 obj<</Parent 66 0 R/Next 417 0 R/Dest/section*.352/Prev 419 0 R/Title(condor_cold_start)>>endobj419 0 obj<</Parent 66 0 R/Next 418 0 R/Dest/section*.343/Prev 420 0 R/Title(condor_cod)>>endobj420 0 obj<</Parent 66 0 R/Next 419 0 R/Dest/section*.335/Prev 421 0 R/Title(condor_chirp)>>endobj421 0 obj<</Parent 66 0 R/Next 420 0 R/Dest/section*.327/Prev 422 0 R/Title(condor_checkpoint)>>endobj422 0 obj<</Parent 66 0 R/Next 421 0 R/Dest/section*.321/Prev 423 0 R/Title(condor_check_userlogs)>>endobj423 0 obj<</Parent 66 0 R/Next 422 0 R/Dest/section*.312/Prev 67 0 R/Title(condor_advertise)>>endobj424 0 obj<</Parent 63 0 R/Next 431 0 R/Dest/section.1.1/Title(1.1 High-Throughput Computing \(HTC\) and its Requirements)>>endobj425 0 obj<</Parent 63 0 R/Dest/section.1.8/Prev 426 0 R/Title(1.8 Privacy Notice)>>endobj426 0 obj<</Parent 63 0 R/Next 425 0 R/Dest/section.1.7/Prev 427 0 R/Title(1.7 Contact Information)>>endobj427 0 obj<</Parent 63 0 R/Next 426 0 R/Dest/section.1.6/Prev 428 0 R/Title(1.6 Contributions to Condor)>>endobj428 0 obj<</Parent 63 0 R/Next 427 0 R/Dest/section.1.5/Prev 429 0 R/Title(1.5 Availability)>>endobj429 0 obj<</Parent 63 0 R/Next 428 0 R/Dest/section.1.4/Prev 430 0 R/Title(1.4 Current Limitations)>>endobj430 0 obj<</Parent 63 0 R/Next 429 0 R/Dest/section.1.3/Prev 431 0 R/Title(1.3 Exceptional Features)>>endobj431 0 obj<</Parent 63 0 R/Next 430 0 R/Dest/section.1.2/Prev 424 0 R/Title(1.2 Condor's Power)>>endobj1 0 obj<</CropBox[0 0 612 792]/Parent 36 0 R/Contents 3 0 R/Rotate 0/MediaBox[0 0 612 792]/Resources<</Font 23 0 R/ProcSet[/PDF/ImageB/Text]/ExtGState 2 0 R>>/Type/Page>>endobj2 0 obj<</R6173 45 0 R>>endobj3 0 obj<</Length 5115/Filter/FlateDecode>>stream
+x]Ys$G~nX}q$SX9rh%w&
+($}PvC!U]U y|~\	'}ozuX}	?UO]tY	wS7g~9sVBQ__Y?=8J.Si g7ngyjt|tEdWaE\uX/7*:\#Nhako,S9Mw&'|-Ji~G',RRjSR
+)J9=c%3wgBeOK:0zcZ%H6ZH_DtA]}g>26Rvk25dQu| 0xivN>9>r2>}?~hk>"[.;_dd2"dy~N,^TL\@zwc#.F.8-.}"}_/	U67l.n=
+:cO&;,c'ct]V1"o{JWjTJc5P
+t^}he*N4-|(	#6<Ro|{Bx&@P1>=U%(Nk/K!jxnh }/tMe&:k9'\:7h}N?ns* w'p0oeDhr]?rAN@xtsy!P&'<1$xg%mY=Te $Di`A@A9HR0Nr*{"fgHWyFFs3D:/j}wB	TC-}!A-zG)R$"15Ci:<;(-:3I~"(N?n>[R7 i7l<V6kXM/y'A<r%n$(IMc_)S6&01	V c;:J"FnpU(YJD.SA%Z6f0=DM5Wej YSwQ%*Ri0WUEaxG)r#AY,^^e^37aBh+IC_"-QK
+v+5Z>a` $zvUw<("9Xnw93taH`!fCU3Io4(JIPnfv @5 
+4	YYl9Cd|&\ix9,l?oFBcTaP
+$ph!+c
+~AnAMJ"z4o3%e~II=x7%bs
+~=<hC0_]jp.Xiq+J+2@_J1==Zx6|_EDw:!Y@,\bf EYOpU!\Eo^.F5k^X
+*fT:LF 5`%;a:*Gd3:u`6L4S`,,	(q]eLl'V6-R3MeMyXM9	B d
+%	`<I{e	Hin"Sf@r#|XYx) E0x0Q{\usU xMn`3w8)xoOP !c['&'t@PaeXP/- P"1/8r\?M9e}#jJ0:H;&yG`4kx+kK}G8t	uM}m M{%)8^w=5:W	{H;qgM`<3gL2VZ_0lHTV`cT]N1}$55:7ei7 {-qX;/W}HG.D+I>Q%k!|F;n,6d6Bz#"#VS2 m"eM#xJlY1QH.!gda6b,Bga'_q1|?ww>y/%)	Lvg&$
+}[!=Sdmvw3op|BSxR=gP!Lc4.FO!=I:T|b7PqdHHS=O4#25a}`rP	cT>x;VuO[wfQLN^Y\L3#iDh-#>=6U^8t\"G4>+rK]8O;e	I;:XU" !w`T2p'AJGzZ?~O[-LE{>'I#Mjo#k2X=!aT:8>Es<d_?;)fdn6 MmESep6wS0O7:SC; O&HAhX=RI:XdCT3"iOgW'Yl ?4a@;Vp`@[;eC}H.L4'&q|I<)<#_m-P:8MqTX'&MP0V@v*$$N"yY5lW;R^/VSXXe}3mSUhzSHnK:PS'al6{f6kJ*JF]i^+b_}uG(S2f\]d&/hT8jk6$#ia:<-@J'b<V(hg[SO<' =*e8
+`N[^hM0AZub!8'	|Mfy/$pmo,yQf>*w%aa'0K d@yBL\,p]*>'=.EKs8-&I	F*lD:U+.yf^#|kf4V5Ojf^+y:H|Vse~fzf
+
+SMYS`-Zb9dXKAch|5mP!3Oang'U3E##F&[{K2|Qn2+%ciwE:`]BQePNMY+Tz=44udjaN#>t:(o:rIH3x5sz4KzDn$qYtMzm=Mj3ucW3;&[itluIcQ Gsvjpy>TN=#rXosE}mu=f8G
+
+5-xvY4ZH?XU#Eyoz`_@OKkes+=NQ$h'_zasTh!x$
++(.@z!qwC&jt!s@M |R7s$N/08Fu&K#R|XI73\uT>	ob]-pvIB+:UxR03*y\)S*>3Y% C421aZ'3WyC%0IT@ZSTDr{ZCHcI}mgpCt-VTRz;FTXJMWJx}MrwnW$)sxQo^e_9X(5UA*>{\.L
+fvz*q\wnS>9%m9|TN7H9nQ		1@'<6@L`)n<N$3$SWy"lG=rOrjDEJf9+^ n00EO s<vo>l\Qm_RGn	4<c49o{.
+KRk0d[9J8H-`c]Vfz$E}j'L5Rx/Hx}IO>"uKp^6Q;h]A:M`o_&O4>zaIpOH?fUg (	-Vx]=_wa]RG}T3
+..PT 8+'z{4kKYTc7X<cbA)"itVfJOMVn0Tcc
+:!=Rs6@^Oq!c96:E&q8n=*~^|!9n ;1xl[}cZY3k;?*<0'Fy8n8(2[#"]A.N(endstreamendobj4 0 obj<</CropBox[0 0 612 792]/Parent 36 0 R/Contents 6 0 R/Rotate 0/MediaBox[0 0 612 792]/Resources<</Font 24 0 R/ProcSet[/PDF/ImageB/Text]/ExtGState 5 0 R>>/Type/Page>>endobj5 0 obj<</R6179 45 0 R>>endobj6 0 obj<</Length 5892/Filter/FlateDecode>>stream
+x]s7rO#v9:IUDJNI=hY}1x40qR._wyI}.l.>?GDg|}
+)?ozshA]~c_g'b:>1!yH&c;G?'z<";YWOWG_?Ool~jT\tEdweE6m73e"xN`naj++zI!VahgC]aMPRQxE	*0#c)wg%l
+=: {e}{|&4ieW/q2zgY:n?2nhuUAZ5**5;I!`"NOj9+_y/fmuJ@dNguNVXI9cugNnOz+xeeV(v8c4Qfgo2I3uqN5W//UB4jq23Ihc[wh3!.NJRk`--+K)qu^qYKk:^L	,=r=KdypCV"*E~UWx4Wim]H%"".$?/"	}YxSz2["%3fG>_ybE8{m/3,%C =f	[78iWZJV ,tU`Kat	T`_5J~C~|\)QDF_1KPl/*<H1KDVcc.2
+X:e%`7q"pfKM	gK3Cjvn?1te~,Q6!	$>lTpFiRv
+]s4}2Q[|/A	5\VvvYl~_nM}'y Q2/N|7ueD@/`V=fpQk'=`\;l|J9T#!YxD03+VUY*(m@[}T('/n$REfC7Mn/c7Q./"12.Q*&Co0h|Hr/eiF(yCtH64'+D~+n bbu[w?E6lc }",Y*HD zhkJ~6&omD[iEyC/M.=E}M'0IkE,|NY2c{&XLEax 6(?Y)Psz9rqkTy7]t>DccBevO.&:GkYP	[^!T+(]&n vaa%)q1I\zxe( 0Q*.=ES8`"9i<y<H*?xTcurqG|ViPLcL=&`[\o>\pLsVESNk1	"Vq]LiNhq1+Dv3l%@W2,/!xfP
+ t\D|}L:XUx<u]Nt;0FfAcgdy}~:x3,'EVKcA GT!,|XA_T!!.4]%m!U*)Rv_fu #1*kYe!.w$>uAn%<F{L)[6]$pqO`O`naId4dNP*bS~8#. D H$RU)Thr8l_(TU
+rvML9k/Iz;C!%Cq!T3x*$PF_
+P_$A$UbN6NedYCi[M%A"].|~pjWB'W/FKc@
+RrHs1K%5@x@euh@Z3WGR(Z(#`jm&3pso0G2D\pbbNqN35D1/5sH,I0n^tt$k!/ l=%%ZxJx' 
+^xR]n$v.FCH;L[+:EV/2=iguyJelyI@I	a/JthtkT4}"J]D2KFBVs>T/iU/OmP5fP6~h$>4)0'`$8\3Afq^M	^6Zmo{~^P*c	*sw#]M=ceTVRv
+/mvS{:5C)d+?#-*u<g7fM&\%zf4MPR\jT^ izV0!3cf#hVnRg5yy;>tlEQ!)^O/N K|OX7^o={kmC2@tReGsyjzps	Z (O4!du=U8{MQLsz(q#.(k_>zdjw6bduhD	t<^uZt*#k=UyY=? ]9`auK9&\>R[2)4F+E,Zjd	TCs-Cs8DqiZ[Eb&dMX;km`WGRr9h#J!]P6i;`AZ~v)/^SZ\.mgwVUXii01fK]5}hI)/[gAlSwc8o$:_a@?&Hbv)'iZwb9/,#U]lCrCfi|[KD4ae[[N\:E1TPPv"KmN~i|:G)ll2uA{:nh\I
+v:B{s`?X_>,#
+J5VQT.c+^"c.z*qD] DZ~4w5OB:+gMVj]bPk-<+x
+aX	> t]x0Q$r:}UE6f`aR/~Fd/:H89_8kW(o)A
+vEt{_JNvgv&[^?c&3
+zw1Z%.r]GZDu[$(|PB9T:YX$^VS{0qP%Z\3>xquM!tMwORsk2'K
+DAJ%o
+)	6vP`IpWE^I:Y#=Dhzmk)%:-RpXJ`3_b.Rk\6Gw/99mh=IlW"Pww@$!)/vN&]`I|`U/>_-Qbv`;
+=uiyPnA|-yw +(kjC[&dHlIpzp\!8@N%IvPH99P)pV< )/K} \0/6i7e^xjY<)5tn4<"j}jHqXP"a`&&e=6ogJaZIxU~W/7y,4\rCprAZuQ~k1a8BN9!s.VW%b>/&`+Z!UC1K XD"Z33sQl1UHfwH&{lX,&-Pg*?h2#e"-T`kv@GZI/)*X>fwG` lAHZE0[oZO:"G?I78.Xi-ZgtQN 1ivzY$Az6Y\kc9:m9z9^>34x@`:Fsx<k8B#Z*C{hliI
+7M9l&^:1,z mw@ QT ]p6jj&]2
+EkcYr-!n{XVXG:qvk
+8+eKt<wd	*-1}rVr%Wc!` pAe_w<CTh~qY#^,R,g,3VAo\~[RmBK4'nbSM)TF	DR<[Fxsy X: #NcU=q1S+Pu<#[P/Iql-%h&Z09>Aj8{}p45JkwsSI/e"Q}1=}iX`C_JA"H3yVa/#E4;7+Wo\%imsiQxt"W;4J [eVgyZ;OQmvNYD"uUp&ogu1/c-1+Y|6aKHRaa/`3^`Yko#U;T R7jfmR#385~8$N0<%"x*K/LL.zmu6s*?ak/"5YzV~v4BN8za==aBp8m/;
+&hg|p.hm	IZpy)bs{vbA980K}Db f.n%rw[kGt|RqbucP~I'R	Vh*(T~3NV[u=4[\==V\nz64V*?A\A$ieW^/b\;rE#3J~pX0 Y2(\ Rendstreamendobj7 0 obj<</CropBox[0 0 612 792]/Parent 36 0 R/Contents 9 0 R/Rotate 0/MediaBox[0 0 612 792]/Resources<</Font 25 0 R/ProcSet[/PDF/ImageB/Text]/ExtGState 8 0 R>>/Type/Page>>endobj8 0 obj<</R6185 45 0 R>>endobj9 0 obj<</Length 5767/Filter/FlateDecode>>stream
+x][sqNb)[J+9.`A%JPw}Ah,rR.[}aaI|w4pb>?/~nrkyz}[`=hg&~zwVL_~8ds}huQLJ9)voAOr&<xu`?w?{6M9<#4eF''2/o34.~Fq;n&.^a\.z62sKQ>ZG)8^8h&(4*P+,$&o_-13YDiY		#'G^>/-/Ih'ky\MNY^~]>}M0&.SoB:kD#f._~XM#siX0V9)L"eTw]8* 9:oK'#,`ZX
+Y//b*~]8weoE+ma$/r23<PbE]z=<mHsne4J=9g`0+&yz2v3LJ92d#y]T5qp'y6b/g5[?*`&s-99I ,%ZWVbjjI>Pgf;/JZmCyOr*dhSIOGt1nH;-2peHif{d66=RXdT8brYav-b%%iW,atu=]aaL?mE-699$r	M.fits6mUZEx3%y/ejEoMZZhf]tcz}4>I-6gI9F'e<px2kkQRb9Be!^ mQ[2akXuQPfI,W4UU-_?u>R.7q!#%.iv|:4MIJ_vE@vChe;4GN
+pK!(|WiA49-NC; M2BU?j&\'U"Tlt3~h$05ghw9Vw!Ml]uE)F#mqHj}ErKT;A6'ic&/8^SG96.\./qY]&_F)z)Z3$*0qOw[E
+C0u-6j\T7iNtJk57!B=iH-x1'}G	dg9uDMrRm80a8V BvA
+^^.ABEXGuHMdvbh dCfmQS) YHB
+>0^hOBz$`b 7}Y^X> !R~KXv- kH)&01Pt 3	^6;pY-ZkkVuO!\Hls[ 4nc\#0?X@|aX"U1b>QD?zriYls;1>P^*"v3gQI-~NS@RB.0le74Kdci!O68 )@DcmGQdY	E,;Ra3m}:
+i0EgV7Bp'(E^"6|}#W,Q4]TyQl
+'i41c@,=ff<*K[;`hA9Yj,4xRpuEbWK%8{#wdTn wNA&`A8=aZa4Hsy2CUg@Q6vPIIMqjlI*+3hxTd}kKzrj$xu5hIc2@<EM49bZJn{koYmV<) +N>=={e XIG#~(CdDn4.YRFHuy)!U^C+X:sZ9
+ %#DCTEl\{Iw-zp0t
+,]~BPvlH,Y~g3(h;
+ch|Z bkbQ8gL'Io,0 \<Xd'WcC#niEL	X/9Gsn[pa:%v<YGO{,IzY'ASHU|[aR6a"JM_&36r2%xg'_a#U]x})_IaRMJ,S`;,ht
+9ha6PZbnSN17wbwrrKyk0MhC~sc49W4LbLa>Bot+IF{KQ"P}Q[9NT\[E/ySc^2	4f	:99k-k0`gY&M|VGNVFd[hf)<Mv|Y L^)l
+.<j	/ZXU=\ly770P8H@8Wj8<=O@lSTa'qY_ncgiy</m=Bt\We	lUxNf\og?z|?#EA\K	*	1[NmyD`NQ(XjI'Yf_ .L!\)YJrq6:W%YQJs=*AZ}H;S*	U{JDIzn[o6$""Q-Vb-bKs!9
+3ZrX0}"<eC8KfYo+BtP
+W
+p~.O~D]AG	uTVty"#Zu}9h[`UmWU4}D%aLhLkYYx%J0?0VC?d]x-o%Y\(jE]kmudxz<D QwV*2)3N("M@bIQJ[EO])7mwXzeaUt/ `0[Y(M-){]M6s{l8|t3QH@*F7ZxWE:']bV)>	Bw#pNAYE$N-jtD,[T:U+1o)qUiAaJqR;nM^|MTW<Pt)8}cpB7sdP]p]ge|T[PhiF@D5?<8]T;9<
+SoiP&YBiT|G2ulyP\;Ijc`yZT)t$y%19@u	-V/ijtr
+i37*?n=SQl%h	@gNOz3ub$MmUKM#HwoZ)bMFmwHPe29)Sbte &`asnvL5(h9caH=5>	-s2M)lJ!wz&MP%C<:*uTS$m2(E<rwXgS
+ljl4#);-"bzXy*0PgVokKmXRJXwm{~sqR.VZlek\>i7P#qS57g3dPTD_x??Rd5/Ha Qpp~o$5@P*POSGp-Q*!dEf_
+FyCh
+91P<TC ;	3(}*)J"&KT7#{\2Fv2|&)7"gf,|-A3U#K 9TAg`kt<U9.H^
+YE8f& f.%eY_#}]mJc$We[h~k<]}VLBiv.P-1-fX" -aj.lMw<r
+#%_	~%9A*2 )q2G[RO{VPN6_zO8m3	kswx8WJ>0V]Kf+U4%mC#EO4MsMKXGyu8j5U]6^`WnN+4	<;e;W
+3JS9A?3GKWDc.LW>:.,keE\GAx:] )!Oi*9=~;#q37l6&@4(x_"S2T6'E#ytypW]{1;O=%3qMTb`C1vY*e!~E"LS2]v}Sl
+a r$J<_NT<@[(`Hi	5 U]lj)Jb.<(	R$Pf 5.hTHytMtHjNDmjTP)#luc\G?IO|LVU+`W7 Nfk'b# ([:xc/hn$B2-0r TJ7[c"oO%"fJ!:Sgc&<rS6~ 4!R1-e,~n>(Q4]2h0pc&=O_zk.;9%QB#4!i2F^JHOCendstreamendobj10 0 obj<</CropBox[0 0 612 792]/Parent 36 0 R/Contents 12 0 R/Rotate 0/MediaBox[0 0 612 792]/Resources<</Font 26 0 R/ProcSet[/PDF/ImageB/Text]/ExtGState 11 0 R>>/Type/Page>>endobj11 0 obj<</R6191 45 0 R>>endobj12 0 obj<</Length 3849/Filter/FlateDecode>>stream
+x\[o.bti/u !	,[Js8+(!yxws5Y= V|/j%37'|XO/`a7a6oK6g&V1cdxuV;Z(Yf=NG?w-VoGWs!?)Wv'Y-k,s's"ueJF!~e>cAQrx9XnT>,P9#I10FHbK,W'y#h|,(HAKu	$%(]~
+gd&E[&EOjj-#%@uy(u\gsofZ`=rgp9fyQ;yQKe%L*7,r59~^.-}de'wYFUI^O4	_{iiwb/*!5\]@1[] Qmy"t|yy|Z$-_dzw^%$S
+$z'dkq=/4sWpR2nNRpK%R6(L9T<4Dp%~2kRM)x1ZroX4bBX%lyd7?29&?(d0[cU($:7@Hf_2e( OAnNtk[@\*>g[A@5k8E<L-t/%Db8r9.Q^0e?\w
+>s\Vhnl8Uv]
+S|f3i]30q|](0&?nw)@d|,{DV@H '.,5[GA$bkxSg*PT3xWYQ2
+tWQGqP>589KDae@n Q mpmQ,yFj4>-h;@/'>oPwW.uz53H$ZahS3t?p"
+{YVu@eK.Of~TFlFB zP_+
+PUK#J[x1/0px=q(8ev>.f`4(?  C]mOaCz	hGjsOd6NUT&B(J#=s,(~"/ EZQmpgPg1c#f84\qyJKj/`ES2:j-/  MtD\|LPz\.R4[m
+Q0
+x.b!0 #:Ze
+C\V-%* mY!7QA6G|mD Lj*b`h9D=*=9oP4YAi	)Ddtg=I~X7_yQr_TLOXI,;p`V=,BlcLc!zblB9wQjTZz)eOl?lyeq/;U [3Z5lw&J}l5>%h;Uif{[\&3SF,jP#kVmlp.[/PQRl0dm>jQ
+S&JG1>4h"H'?zQC~	nX31nz~Q
+AN&b]CAR;uTPm0bF9q]
+u"+`m-YxPN<wBj0mTR z>v4qVO	ITiL8ZG~~P$9soURJaK{u1te
+oaJDvLRLr>fPUNo&oiZ	^4Q7R,F7]:%a<wfJ[eS2%^2N=fMb}pZfKWjD/mZ 
+!'4iTUPBO@%^|&K ;C;B4JB;`"vXVJv]xR:_MsY5:d<Ed!d1i?+
+)'$5p/m~J[}'d_N`ZJ[ V*btdJQ }VCMsIum7$LRx1aE,:l`H`0Bq%W-.*l :F(06!)3-S Q.u"}'>;V(?4]TIwMDl)f$~WPwEX8k3I,t?c!Chd_1=Sb>\Mjejrw":8rgqjb:J2f+$ r!c4sNg
+^X	0fvL2Bhw9"L!"EJ@/7$"Akv=!J9Kc-XTf4JM;@giPk`q`l:e_5(t%3.&[G!1L9dSyrPD445csV'Y)cHuU? .OWMM}5r]!idBz8`TteM54z
+Nc{OK2LT9;yoFX- ;c+u0-Li4uw
+'QTIL@w /N)#G'=xMMvCfVm{I?C~R1;M6OD1G}_8Y<EgvxN\v]rrvh4C} aKwc	:A&@ru"f9qK]lHWeMc*9U~|	16	hEK'K}-w5BURA%miPdy~+,4,sa"){wNmJnTMO\yR[lVNIO8-ne0>aO=V5m{+J5jl3#
+T`akkd_SB^mKI$vyqT9b~J{]
+=G#yx"g]"^(i1o\!e3E-x,!`endstreamendobj13 0 obj<</CropBox[0 0 612 792]/Parent 36 0 R/Contents 15 0 R/Rotate 0/MediaBox[0 0 612 792]/Resources<</Font 29 0 R/ProcSet[/PDF/ImageB/Text]/ExtGState 14 0 R>>/Type/Page>>endobj14 0 obj<</R6197 45 0 R>>endobj15 0 obj<</Length 3022/Filter/FlateDecode>>stream
+x\YsNqy7qJrSV`KQJHQ3.)QRQb1@w^9sV7?dv1q8:?>qy`J/gilhZ#|2MjzXNR1c8b+\(Yf=xls1#W'gFBK-Wm[;O&2Xs.'s"X`KXreP1.B*M"G$$wc|;za8s6qXZ?--8.jsYW[x3R Mk*K)n9f5F(k	j]f?U J6q`Zq h.]b .E4(ZHX /8SH;QE!;	,rYegOyQ>QgJ+#5J1nx@%S(^u,87?,pTD\8LII}T$w]dR $Lc	-o)R=)lcQF i(QiA ;By3 U#8{<d7F*E]24q +Wz[yVyjdZftNi4IK9HIUBi&Be	W&BQWB*_doq5SkAXPAbsr
+ne
+iv:bh#	P ,]P\	HV2 #ZzEOM)>_-O%Dt4,j"(4%io/4Ihuj1D!>FYp7	B |m8RS1(rC,op1ntx		$XDfc`R
+*R}x*o+!Fb!4 bBF.4;KC*N-vbB~u?S0-Z'wJb -%^w0JI
+2:A%&rH,EUy:P%6 Uwe7~7JXaL,Fd@<TUpD+Lw	,`m@f`$:]2:Q^yj+
+bRe~FlA1 (!n(Pd0 ;,HPg)[(+V*[([3Da6Uy@)<u]-P:>'V5tEHh"0n(@c"  iYH&y<tQ;TRA;&Ubne)5dd{*	K4.MaYpW|Y\j	CLFFWZJ]AI)9&_FOa
+ # teHJ:QWI/G)=;FfEw	AijBMvMS9F}heMwT9\Q:2]	v%`7XTpiI/>[]2#/dZ }nYJv]zDI>?hTX
+TPAA*eYp}kwVGvP g2q"f@u4n{d]2vE.91j"X*	| snX]NbXX`
+l::+-8b	 B.`)O:wpOM(M$Jn&UGMZZt1 *r]"2YY0 }5^wPg :("UGH<zui.KH x|{KMsj|{X~7_Ysua^Wj~jB{4v%xo!$-TRj&fm<c0@N='Gg)1!RW8y_HU?}Fm0'Fv2N,n/b2$R["\soBb;\&7.T_HddgbIm$;q6hxqvS+	W3(_,L}
+pkrLZ7Kh2$`+4RN8o_Jii4nz=$W4DUm,dZy-Cm:km\*vFquoeo-?56'j6mbyC1R7D=Msl{?<wwh[.`>@M#qIn~	?# 8;ZDg2#]&7[}AJdSoMYB6]L@w>w1)y/|euc-T7>y~Wg,`\eUu?Kuua|TC5Lia~`M53%P`siv5e#I 9^%$<aBPGMr296=YJhU^yw`n"-`>?0hwza6F(gq`oK>^V7]W,_q.'k2A]'gFxw.=[jg4!rdso$Sf#endstreamendobj16 0 obj<</CropBox[0 0 612 792]/Parent 36 0 R/Contents 18 0 R/Rotate 0/MediaBox[0 0 612 792]/Resources<</Font 30 0 R/ProcSet[/PDF/ImageB/Text]/ExtGState 17 0 R>>/Type/Page>>endobj17 0 obj<</R6203 45 0 R>>endobj18 0 obj<</Length 2015/Filter/FlateDecode>>stream
+xZs4gx~Pf()>L'<]Z#-NzYv+4~c(gNgYSt?ep8,f-WB;Cx=)UEU+bs<i{i<?QIGi!Z$`PFh98m^w?6.>=,np85ijNT/EE=qyvAv,<e%O8he,sR5URphIj$zK(z,kw4IL7DNcTT=54w-:j0F^LH6BSs??}R>jJQrHXbpJ3x^ik\r^4gQZe*Wt=VXZ i-xRW$E<fw]5_<Uh	 &F8*c/C?u%?p;IS 9--_(!*{P; f%<0G:yZZwaa?_>G]79*\ju${WjLRn r DVE^j+E^]%~FDC1Z+""^L{!s  UPc).BV^$5i|1kEH_k(:f;0y23KuL	/yG{t5`;tjx`
+:`(l;V0_:IiX(V~kD	67L 8\&A1.j>sS)Wn?hR2pWAO05^=99Aj}GrB ,XV=xF&$+
+ze#!@sML9mVeNWL}	uH@tQ RLW9|9t	A[^FF}zjtE)w\M0:AeC	\#y5LaL.w44n'w'I.t?P71{}EvZooJ5 2]zK ;OW,Q^>Yo @|(/:TlRcR
++9x8"oOwB9; E8Vw@b^gipK4kg(IQ~3E;Xq7)as?.KKm$K!7BIy*Q%X-SG'~)Z]WM1'(C2MrvaZ^EUk*+F,~fQ$_Q$;QPp'K
+d=/ts+TvL4F@cGw5
+Au:FYdC52<nh1Q dNqC3Y&|GS:f&A>?5kxE0:Qe'2"n'S5]p/Ww-Th<YMT3Yg4N4` w/zW-:T#SwqbCVh :HoRl$NJ o$5UGt?)SsFl[oHG>b"T]W,A$gAGhkEvwvBS&k{oFsendstreamendobj19 0 obj<</CropBox[0 0 612 792]/Annots[20 0 R]/Parent 36 0 R/Contents 22 0 R/Rotate 0/MediaBox[0 0 612 792]/Resources<</Font 31 0 R/ProcSet[/PDF/ImageB/Text]/ExtGState 21 0 R>>/Type/Page>>endobj20 0 obj<</Rect[278.724 449.484 429.276 460.476]/Subtype/Link/A<</URI(http://www.condorproject.org/license)/S/URI>>/C[0 1 1]/H/I/Border[0 0 0.12]/Type/Annot>>endobj21 0 obj<</R6209 45 0 R>>endobj22 0 obj<</Length 1693/Filter/FlateDecode>>stream
+xX4_G/VTR<@}3!I,[$JsN|r&ZY7w4"i}u6`w68&Es5vW`!rzm$y~+fLwusj4?h[g2z<fu}s;nVZ~_4{s!P#mZ99LzpSZ:MYCpqYt*88j%i$?8'61rciDx~to \ hI9+Kyr7/$h+H.+5*vYA*< ~.27|2.&i8HH;gCz3-soEZ3eN:4 $o!KK[GcfX#eJm/<8G^:t/ W	N83/daTW8o{D^t	y%./dCih[qdWx~Ak6%@2Cc"0	0D	$$D[{ {IZQuIN\ep)_N9`|avrw(.3aFI	[ I?.45PfK7yo%=LzYPkQBnUgU^ui)I:<Pc`8j[$F u%)	zqVdQW<JNBpG!K=|)k6R$j#)g&u-X\_4??CT";M{BdyOI^Qx0bE(r$BZxD
+K(Z
+Ig-$:E
+mQ9PRHfoc@yd-OX=qA
+Idd	p,.h~OXy_JH|+J]}GRm<0o.xI|EY,K!
+khAth 2Al}@l6<w9/qt`pdQ}b</iBBT9*z:jI}| wx3+D3v@FqwTg>n pXxs|n\xoI @eti)j:'e4$0TVvlIVoxM	NN`0fx)k4 L(pijZ^
+YbvGU\'B{7'W*~TiO_U*{N96S?f^WEPGT4"@O
+rWTWgRE.VPuB
+Pm.))Ks>2~
+$j03(Cc|cKB:Hhrp1KYZy[qY$s#h*ote:Vb_1*vzV$>I&I~Fa/4endstreamendobj23 0 obj<</R379 55 0 R/R380 57 0 R/R381 59 0 R>>endobj24 0 obj<</R379 55 0 R/R380 57 0 R/R381 59 0 R>>endobj25 0 obj<</R379 55 0 R/R380 57 0 R/R381 59 0 R/R384 61 0 R>>endobj26 0 obj<</R379 55 0 R/R380 57 0 R/R381 59 0 R/R384 61 0 R>>endobj27 0 obj<</Subtype/Type1/BaseFont/Courier/Encoding 28 0 R/Type/Font>>endobj28 0 obj<</Differences[30/grave/quotesingle 136/circumflex 152/tilde]/Type/Encoding>>endobj29 0 obj<</R379 55 0 R/R380 57 0 R/R381 59 0 R/R382 27 0 R>>endobj30 0 obj<</R379 55 0 R/R380 57 0 R/R382 27 0 R>>endobj31 0 obj<</R379 55 0 R/R380 57 0 R/R381 59 0 R>>endobj32 0 obj<</Differences[24/breve/caron/circumflex/dotaccent/hungarumlaut/ogonek/ring/tilde 39/quotesingle 96/grave 128/bullet/dagger/daggerdbl/ellipsis/emdash/endash/florin/fraction/guilsinglleft/guilsinglright/minus/perthousand/quotedblbase/quotedblleft/quotedblright/quoteleft/quoteright/quotesinglbase/trademark/fi/fl/Lslash/OE/Scaron/Ydieresis/Zcaron/dotlessi/lslash/oe/scaron/zcaron 160/Euro 164/currency 166/brokenbar 168/dieresis/copyright/ordfeminine 172/logicalnot/.notdef/registered/macron/degree/plusminus/twosuperior/threesuperior/acute/mu 183/periodcentered/cedilla/onesuperior/ordmasculine 188/onequarter/onehalf/threequarters 192/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis/yacute/thorn/ydieresis]/Type/Encoding>>endobj33 0 obj<</Subtype/Type1/Name/Helv/BaseFont/Helvetica/Encoding 32 0 R/Type/Font>>endobj34 0 obj<</Subtype/Type1/Name/ZaDb/BaseFont/ZapfDingbats/Type/Font>>endobj35 0 obj<</table.3.1<</Rect[1532.7 1084.3 1549.3 1067.7]/D[null/XYZ 185.613 590.396 null]>>/table.3.2<</Rect[1587.7 1957.3 1604.3 1940.7]/D[null/XYZ 192.238 485.243 null]>>/subsection.2.14.1<</Rect[291.695 720.301 299.997 628.977]/D[null/XYZ 36.1346 644.24 null]>>/subsection.2.14.2<</Rect[291.695 3399.3 299.997 3307.98]/D[null/XYZ 36.1346 321.554 null]>>/subsection.2.14.3<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.2.14.4<</Rect[291.695 3515.3 299.997 3423.98]/D[null/XYZ 36.1346 307.582 null]>>/subsection.2.11.1<</Rect[291.695 4145.3 299.997 4053.98]/D[null/XYZ 36.1346 231.698 null]>>/subsection.2.11.2<</Rect[291.695 2125.3 299.997 2033.98]/D[null/XYZ 36.1346 475.008 null]>>/subsection.2.11.3<</Rect[291.695 2692.3 299.997 2600.98]/D[null/XYZ 36.1346 406.712 null]>>/subsection.2.11.4<</Rect[291.695 4046.3 299.997 3954.98]/D[null/XYZ 36.1346 243.623 null]>>/subsection.6.2.10<</Rect[291.695 2909.3 299.997 2817.98]/D[null/XYZ 36.1346 380.575 null]>>/subsection.6.2.11<</Rect[291.695 4503.3 299.997 4411.98]/D[null/XYZ 36.1346 188.578 null]>>/page.10<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.11<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.12<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.13<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.300<</Rect[291.695 3975.3 299.997 3883.98]/D[null/XYZ 36.1346 252.175 null]>>/page.14<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.301<</Rect[291.695 4556.3 299.997 4464.98]/D[null/XYZ 36.1346 182.194 null]>>/page.15<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.302<</Rect[291.695 4706.3 299.997 4614.98]/D[null/XYZ 36.1346 164.126 null]>>/page.16<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.303<</Rect[291.695 4888.3 299.997 4796.98]/D[null/XYZ 36.1346 142.204 null]>>/page.17<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.304<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.18<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.19<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.vii<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.20<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.21<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.22<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.23<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.24<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.25<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.26<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.27<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.28<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.29<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.viii<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.1<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.2<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.3<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.4<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.5<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.6<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.7<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.8<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.9<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.30<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.31<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.32<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.33<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.34<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.35<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.36<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.37<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.38<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.39<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.40<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.41<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.42<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.43<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.44<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.45<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.46<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.47<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.48<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.49<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.i<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.v<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.x<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.50<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.51<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.52<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.53<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.54<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.55<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.56<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.57<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.58<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.59<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.60<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.61<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.62<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.63<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.64<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.65<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.66<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.67<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.68<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.69<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.4.4.1<</Rect[291.695 4278.3 299.997 4186.98]/D[null/XYZ 36.1346 215.679 null]>>/subsection.4.4.2<</Rect[291.695 2294.3 299.997 2202.98]/D[null/XYZ 36.1346 454.651 null]>>/subsection.4.1.1<</Rect[291.695 2861.3 299.997 2769.98]/D[null/XYZ 36.1346 386.356 null]>>/subsection.3.6.10<</Rect[291.695 1947.3 299.997 1855.98]/D[null/XYZ 36.1346 496.448 null]>>/subsection.4.1.2<</Rect[291.695 2428.3 299.997 2336.97]/D[null/XYZ 36.1346 438.511 null]>>/subsection.3.6.11<</Rect[291.695 2556.3 299.997 2464.98]/D[null/XYZ 36.1346 423.094 null]>>/subsection.4.1.3<</Rect[291.695 2544.3 299.997 2452.98]/D[null/XYZ 36.1346 424.539 null]>>/subsection.3.6.12<</Rect[291.695 2484.3 299.997 2392.98]/D[null/XYZ 36.1346 431.766 null]>>/subsection.3.6.13<</Rect[291.695 1537.3 299.997 1445.98]/D[null/XYZ 36.1346 545.832 null]>>/page.70<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Doc-Start<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.71<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.72<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.73<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.74<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.75<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.76<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.77<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.78<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.79<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.80<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.81<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.82<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.83<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.84<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.85<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.86<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.87<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.88<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.89<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.90<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.91<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.92<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.93<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.94<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.95<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.96<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.97<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.98<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.99<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/chapter.10<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.11<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.900<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.901<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.902<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.903<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.904<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.905<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.906<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.600<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.907<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.601<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.908<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.602<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.909<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.603<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.604<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.605<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.606<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.300<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.607<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.301<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.608<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.302<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.609<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.7.1<</Rect[291.695 2627.3 299.997 2535.98]/D[null/XYZ 36.1346 414.542 null]>>/page.303<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.7.2<</Rect[291.695 2078.3 299.997 1986.97]/D[null/XYZ 36.1346 480.669 null]>>/page.304<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.7.3<</Rect[291.695 2128.3 299.997 2036.97]/D[null/XYZ 36.1346 474.646 null]>>/page.305<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.7.4<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.306<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.7.5<</Rect[291.695 1221.3 299.997 1129.98]/D[null/XYZ 36.1346 583.894 null]>>/page.307<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.7.6<</Rect[291.695 2408.3 299.997 2316.97]/D[null/XYZ 36.1346 440.92 null]>>/page.308<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.7.7<</Rect[291.695 2588.3 299.997 2496.97]/D[null/XYZ 36.1346 419.239 null]>>/page.309<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.4.1<</Rect[291.695 3391.3 299.997 3299.98]/D[null/XYZ 36.1346 322.518 null]>>/section.4.2<</Rect[291.695 2672.3 299.997 2580.98]/D[null/XYZ 36.1346 409.122 null]>>/section.4.3<</Rect[291.695 3654.3 299.997 3562.98]/D[null/XYZ 36.1346 290.839 null]>>/section.4.4<</Rect[291.695 2808.3 299.997 2716.97]/D[null/XYZ 36.1346 392.74 null]>>/section.4.5<</Rect[291.695 1215.3 299.997 1123.98]/D[null/XYZ 36.1346 584.617 null]>>/section.4.6<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.1.1<</Rect[291.695 2314.3 299.997 2222.98]/D[null/XYZ 36.1346 452.242 null]>>/section.1.2<</Rect[291.695 1331.3 299.997 1239.98]/D[null/XYZ 36.1346 570.645 null]>>/page.910<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.1.3<</Rect[291.695 1430.3 299.997 1338.98]/D[null/XYZ 36.1346 558.72 null]>>/page.911<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.1.4<</Rect[291.695 2344.3 299.997 2252.98]/D[null/XYZ 36.1346 448.629 null]>>/page.912<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.1.5<</Rect[291.695 3615.3 299.997 3523.98]/D[null/XYZ 36.1346 295.537 null]>>/page.913<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.1.6<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.914<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.1.7<</Rect[291.695 2635.3 299.997 2543.98]/D[null/XYZ 36.1346 413.578 null]>>/page.915<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.1.8<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.916<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.610<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.917<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.611<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.918<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.612<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.919<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.613<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.614<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.615<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.616<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.310<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.617<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.311<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.618<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.312<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.619<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.313<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.314<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.315<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.316<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.317<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.318<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.319<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.920<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.921<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.922<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.923<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.924<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.925<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.10<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.926<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.11<</Rect[291.695 1284.3 299.997 1192.98]/D[null/XYZ 36.1346 576.306 null]>>/page.620<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.927<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.12<</Rect[291.695 3444.3 299.997 3352.98]/D[null/XYZ 36.1346 316.134 null]>>/page.621<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.928<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/table.11.1<</Rect[1686.69 1589.3 1703.3 1572.7]/D[null/XYZ 204.162 529.569 null]>>/subsection.3.3.13<</Rect[291.695 4493.3 299.997 4401.98]/D[null/XYZ 36.1346 189.782 null]>>/page.622<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.929<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/table.11.2<</Rect[1763.7 777.3 1780.3 760.695]/D[null/XYZ 213.437 627.374 null]>>/subsection.3.3.14<</Rect[291.695 1023.3 299.997 931.975]/D[null/XYZ 36.1346 607.744 null]>>/page.623<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/table.11.3<</Rect[1685.7 4337.3 1702.3 4320.7]/D[null/XYZ 204.042 198.572 null]>>/subsection.3.3.15<</Rect[291.695 1023.3 299.997 931.975]/D[null/XYZ 36.1346 607.744 null]>>/page.624<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/table.11.4<</Rect[1719.7 1141.3 1736.3 1124.7]/D[null/XYZ 208.137 583.53 null]>>/subsection.3.3.16<</Rect[291.695 2628.3 299.997 2536.97]/D[null/XYZ 36.1346 414.421 null]>>/page.625<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/table.11.5<</Rect[1574.7 4281.3 1591.3 4264.7]/D[null/XYZ 190.672 205.317 null]>>/subsection.3.3.17<</Rect[291.695 1272.3 299.997 1180.98]/D[null/XYZ 36.1346 577.752 null]>>/page.626<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.18<</Rect[291.695 4408.3 299.997 4316.98]/D[null/XYZ 36.1346 200.02 null]>>/page.320<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.627<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.19<</Rect[291.695 2895.3 299.997 2803.98]/D[null/XYZ 36.1346 382.261 null]>>/page.321<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.628<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.322<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.629<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.323<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.324<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.325<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.326<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.500<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.327<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.501<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/page.328<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.502<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.329<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.503<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.504<</Rect[291.695 1935.3 299.997 1843.98]/D[null/XYZ 36.1346 497.893 null]>>/section*.505<</Rect[291.695 3524.3 299.997 3432.98]/D[null/XYZ 36.1346 306.498 null]>>/section*.506<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.200<</Rect[291.695 4631.3 299.997 4539.98]/D[null/XYZ 36.1346 173.16 null]>>/section*.507<</Rect[291.695 1279.3 299.997 1187.98]/D[null/XYZ 36.1346 576.908 null]>>/section*.201<</Rect[291.695 3610.3 299.997 3518.98]/D[null/XYZ 36.1346 296.139 null]>>/section*.508<</Rect[291.695 1825.3 299.997 1733.98]/D[null/XYZ 36.1346 511.143 null]>>/section*.202<</Rect[291.695 3115.3 299.997 3023.98]/D[null/XYZ 36.1346 355.762 null]>>/section*.509<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.203<</Rect[291.695 4646.3 299.997 4554.98]/D[null/XYZ 36.1346 171.353 null]>>/section*.204<</Rect[291.695 1155.3 299.997 1063.98]/D[null/XYZ 36.1346 591.844 null]>>/section*.205<</Rect[291.695 4052.3 299.997 3960.98]/D[null/XYZ 36.1346 242.901 null]>>/section*.206<</Rect[291.695 4334.3 299.997 4242.98]/D[null/XYZ 36.1346 208.933 null]>>/section*.207<</Rect[291.695 3187.3 299.997 3095.98]/D[null/XYZ 36.1346 347.09 null]>>/section*.208<</Rect[291.695 4457.3 299.997 4365.98]/D[null/XYZ 36.1346 194.118 null]>>/section*.209<</Rect[291.695 1044.3 299.997 952.977]/D[null/XYZ 36.1346 605.214 null]>>/subsection.3.3.20<</Rect[291.695 4106.3 299.997 4014.98]/D[null/XYZ 36.1346 236.396 null]>>/subsection.3.3.21<</Rect[291.695 3746.3 299.997 3654.98]/D[null/XYZ 36.1346 279.758 null]>>/page.630<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.22<</Rect[291.695 2085.3 299.997 1993.98]/D[null/XYZ 36.1346 479.826 null]>>/page.631<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.23<</Rect[291.695 3360.3 299.997 3268.98]/D[null/XYZ 36.1346 326.252 null]>>/page.632<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.24<</Rect[291.695 1949.3 299.997 1857.98]/D[null/XYZ 36.1346 496.207 null]>>/page.633<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.25<</Rect[291.695 3333.3 299.997 3241.97]/D[null/XYZ 36.1346 329.504 null]>>/page.634<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.15.1<</Rect[291.695 1321.3 299.997 1229.98]/D[null/XYZ 36.1346 571.849 null]>>/subsection.3.3.26<</Rect[291.695 4607.3 299.997 4515.98]/D[null/XYZ 36.1346 176.051 null]>>/page.635<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.27<</Rect[291.695 4239.3 299.997 4147.98]/D[null/XYZ 36.1346 220.376 null]>>/page.636<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.28<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.330<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.637<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.29<</Rect[291.695 4028.3 299.997 3936.98]/D[null/XYZ 36.1346 245.791 null]>>/page.331<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.638<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.332<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.639<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.333<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.334<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.12.1<</Rect[291.695 4590.3 299.997 4498.98]/D[null/XYZ 36.1346 178.098 null]>>/page.335<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.12.2<</Rect[291.695 2230.3 299.997 2138.98]/D[null/XYZ 36.1346 462.36 null]>>/page.336<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.510<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/subsection.3.12.3<</Rect[291.695 1404.3 299.997 1312.98]/D[null/XYZ 36.1346 561.852 null]>>/page.337<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.511<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/subsection.3.12.4<</Rect[291.695 4222.3 299.997 4130.98]/D[null/XYZ 36.1346 222.424 null]>>/page.338<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.512<</Rect[291.695 3657.3 299.997 3565.98]/D[null/XYZ 36.1346 290.478 null]>>/page.339<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.513<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.514<</Rect[291.695 1279.3 299.997 1187.98]/D[null/XYZ 36.1346 576.908 null]>>/section*.515<</Rect[291.695 1825.3 299.997 1733.98]/D[null/XYZ 36.1346 511.143 null]>>/section*.516<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.210<</Rect[291.695 1074.3 299.997 982.977]/D[null/XYZ 36.1346 601.6 null]>>/section*.517<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.211<</Rect[291.695 4772.3 299.997 4680.98]/D[null/XYZ 36.1346 156.177 null]>>/section*.518<</Rect[291.695 1869.3 299.997 1777.98]/D[null/XYZ 36.1346 505.843 null]>>/section*.212<</Rect[291.695 3581.3 299.997 3489.98]/D[null/XYZ 36.1346 299.632 null]>>/section*.519<</Rect[291.695 3657.3 299.997 3565.98]/D[null/XYZ 36.1346 290.478 null]>>/section*.213<</Rect[291.695 3284.3 299.997 3192.98]/D[null/XYZ 36.1346 335.406 null]>>/section*.214<</Rect[291.695 649.302 299.997 557.977]/D[null/XYZ 36.1346 652.792 null]>>/section*.215<</Rect[291.695 4745.3 299.997 4653.98]/D[null/XYZ 36.1346 159.428 null]>>/section*.216<</Rect[291.695 3742.3 299.997 3650.98]/D[null/XYZ 36.1346 280.24 null]>>/section*.217<</Rect[291.695 3152.3 299.997 3060.98]/D[null/XYZ 36.1346 351.306 null]>>/section*.218<</Rect[291.695 3696.3 299.997 3604.98]/D[null/XYZ 36.1346 285.781 null]>>/section*.219<</Rect[291.695 4422.3 299.997 4330.98]/D[null/XYZ 36.1346 198.334 null]>>/subsection.3.3.30<</Rect[291.695 4203.3 299.997 4111.98]/D[null/XYZ 36.1346 224.713 null]>>/subsection.3.3.31<</Rect[291.695 1737.3 299.997 1645.98]/D[null/XYZ 36.1346 521.742 null]>>/page.640<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.32<</Rect[291.695 3027.3 299.997 2935.98]/D[null/XYZ 36.1346 366.362 null]>>/page.641<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.33<</Rect[291.695 3148.3 299.997 3056.97]/D[null/XYZ 36.1346 351.787 null]>>/page.642<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.34<</Rect[291.695 1521.3 299.997 1429.98]/D[null/XYZ 36.1346 547.759 null]>>/page.643<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.644<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.645<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.646<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.340<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.647<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.341<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.648<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.342<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.649<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.343<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.344<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.345<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.346<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.520<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.347<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.521<</Rect[291.695 1279.3 299.997 1187.98]/D[null/XYZ 36.1346 576.908 null]>>/page.348<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.522<</Rect[291.695 1825.3 299.997 1733.98]/D[null/XYZ 36.1346 511.143 null]>>/page.349<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.523<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.524<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.525<</Rect[291.695 2334.3 299.997 2242.98]/D[null/XYZ 36.1346 449.833 null]>>/section*.526<</Rect[291.695 2476.3 299.997 2384.98]/D[null/XYZ 36.1346 432.73 null]>>/section*.220<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/section*.527<</Rect[291.695 4633.3 299.997 4541.98]/D[null/XYZ 36.1346 172.919 null]>>/section*.221<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/section*.528<</Rect[291.695 1795.3 299.997 1703.98]/D[null/XYZ 36.1346 514.756 null]>>/section*.222<</Rect[291.695 1825.3 299.997 1733.98]/D[null/XYZ 36.1346 511.143 null]>>/section*.529<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.223<</Rect[291.695 4830.3 299.997 4738.98]/D[null/XYZ 36.1346 149.19 null]>>/section*.224<</Rect[291.695 1158.3 299.997 1066.97]/D[null/XYZ 36.1346 591.483 null]>>/section*.225<</Rect[291.695 1328.3 299.997 1236.97]/D[null/XYZ 36.1346 571.006 null]>>/section*.226<</Rect[291.695 3266.3 299.997 3174.98]/D[null/XYZ 36.1346 337.574 null]>>/subsection.3.9.1<</Rect[291.695 3663.3 299.997 3571.98]/D[null/XYZ 36.1346 289.756 null]>>/section*.227<</Rect[291.695 2718.3 299.997 2626.97]/D[null/XYZ 36.1346 403.581 null]>>/subsection.3.9.2<</Rect[291.695 2380.3 299.997 2288.98]/D[null/XYZ 36.1346 444.293 null]>>/section*.228<</Rect[291.695 3263.3 299.997 3171.97]/D[null/XYZ 36.1346 337.936 null]>>/section*.229<</Rect[291.695 3889.3 299.997 3797.98]/D[null/XYZ 36.1346 262.534 null]>>/page.650<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.651<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.1<</Rect[291.695 2036.3 299.997 1944.98]/D[null/XYZ 36.1346 485.728 null]>>/page.652<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.2<</Rect[291.695 2840.3 299.997 2748.98]/D[null/XYZ 36.1346 388.886 null]>>/page.653<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.3<</Rect[291.695 3711.3 299.997 3619.98]/D[null/XYZ 36.1346 283.974 null]>>/page.654<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.4<</Rect[291.695 1432.3 299.997 1340.98]/D[null/XYZ 36.1346 558.479 null]>>/page.655<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.5<</Rect[291.695 2607.3 299.997 2515.98]/D[null/XYZ 36.1346 416.951 null]>>/page.656<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.6<</Rect[291.695 4591.3 299.997 4499.98]/D[null/XYZ 36.1346 177.978 null]>>/page.657<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.350<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.7<</Rect[291.695 4607.3 299.997 4515.98]/D[null/XYZ 36.1346 176.051 null]>>/page.658<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.351<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.8<</Rect[291.695 1587.3 299.997 1495.98]/D[null/XYZ 36.1346 539.81 null]>>/page.659<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.1<</Rect[291.695 3609.3 299.997 3517.98]/D[null/XYZ 36.1346 296.26 null]>>/page.352<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.6.9<</Rect[291.695 1886.3 299.997 1794.98]/D[null/XYZ 36.1346 503.795 null]>>/subsection.3.3.2<</Rect[291.695 3309.3 299.997 3217.98]/D[null/XYZ 36.1346 332.395 null]>>/page.353<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.3<</Rect[291.695 2790.3 299.997 2698.98]/D[null/XYZ 36.1346 394.908 null]>>/page.354<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.3.4<</Rect[291.695 2085.3 299.997 1993.98]/D[null/XYZ 36.1346 479.826 null]>>/page.355<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.530<</Rect[291.695 1279.3 299.997 1187.98]/D[null/XYZ 36.1346 576.908 null]>>/subsection.3.3.5<</Rect[291.695 4377.3 299.997 4285.98]/D[null/XYZ 36.1346 203.754 null]>>/page.356<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.531<</Rect[291.695 1825.3 299.997 1733.98]/D[null/XYZ 36.1346 511.143 null]>>/subsection.3.3.6<</Rect[291.695 1487.3 299.997 1395.98]/D[null/XYZ 36.1346 551.855 null]>>/page.357<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.532<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/subsection.3.3.7<</Rect[291.695 4310.3 299.997 4218.98]/D[null/XYZ 36.1346 211.824 null]>>/page.358<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.533<</Rect[291.695 1242.3 299.997 1150.98]/D[null/XYZ 36.1346 581.365 null]>>/subsection.3.3.8<</Rect[291.695 4177.3 299.997 4085.98]/D[null/XYZ 36.1346 227.844 null]>>/page.359<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.534<</Rect[291.695 1866.3 299.997 1774.98]/D[null/XYZ 36.1346 506.204 null]>>/subsection.3.3.9<</Rect[291.695 1637.3 299.997 1545.98]/D[null/XYZ 36.1346 533.787 null]>>/section*.535<</Rect[291.695 4784.3 299.997 4692.98]/D[null/XYZ 36.1346 154.731 null]>>/section*.536<</Rect[291.695 1331.3 299.997 1239.98]/D[null/XYZ 36.1346 570.645 null]>>/section*.230<</Rect[291.695 4415.3 299.997 4323.98]/D[null/XYZ 36.1346 199.177 null]>>/section*.537<</Rect[291.695 2370.3 299.997 2278.98]/D[null/XYZ 36.1346 445.497 null]>>/section*.231<</Rect[291.695 3067.3 299.997 2975.98]/D[null/XYZ 36.1346 361.544 null]>>/section*.538<</Rect[291.695 3129.3 299.997 3037.98]/D[null/XYZ 36.1346 354.076 null]>>/section*.232<</Rect[291.695 1400.3 299.997 1308.98]/D[null/XYZ 36.1346 562.334 null]>>/section*.539<</Rect[291.695 3754.3 299.997 3662.98]/D[null/XYZ 36.1346 278.794 null]>>/section*.233<</Rect[291.695 2323.3 299.997 2231.97]/D[null/XYZ 36.1346 451.159 null]>>/subsection.6.4.1<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section*.234<</Rect[291.695 4370.3 299.997 4278.98]/D[null/XYZ 36.1346 204.597 null]>>/subsection.6.4.2<</Rect[291.695 1118.3 299.997 1026.97]/D[null/XYZ 36.1346 596.301 null]>>/section*.235<</Rect[291.695 2671.3 299.997 2579.98]/D[null/XYZ 36.1346 409.242 null]>>/section*.236<</Rect[291.695 3313.3 299.997 3221.97]/D[null/XYZ 36.1346 331.913 null]>>/section*.237<</Rect[291.695 4038.3 299.997 3946.98]/D[null/XYZ 36.1346 244.587 null]>>/section*.238<</Rect[291.695 770.301 299.997 678.977]/D[null/XYZ 36.1346 638.217 null]>>/section*.239<</Rect[291.695 2327.3 299.997 2235.98]/D[null/XYZ 36.1346 450.677 null]>>/subsection.6.1.1<</Rect[291.695 1271.3 299.997 1179.98]/D[null/XYZ 36.1346 577.872 null]>>/subsection.6.1.2<</Rect[291.695 3043.3 299.997 2951.97]/D[null/XYZ 36.1346 364.435 null]>>/subsection.6.1.3<</Rect[291.695 3669.3 299.997 3577.98]/D[null/XYZ 36.1346 289.033 null]>>/page.660<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.661<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.662<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.663<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.664<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.665<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.666<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.360<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.667<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.361<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.668<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.362<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.669<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.363<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.364<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.365<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.540<</Rect[291.695 4299.3 299.997 4207.98]/D[null/XYZ 36.1346 213.149 null]>>/page.366<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.541<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.367<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.542<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.368<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.543<</Rect[291.695 2499.3 299.997 2407.98]/D[null/XYZ 36.1346 429.959 null]>>/page.369<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.544<</Rect[291.695 4353.3 299.997 4261.98]/D[null/XYZ 36.1346 206.645 null]>>/section*.545<</Rect[291.695 3470.3 299.997 3378.98]/D[null/XYZ 36.1346 313.002 null]>>/section*.546<</Rect[291.695 4114.3 299.997 4022.98]/D[null/XYZ 36.1346 235.432 null]>>/section*.240<</Rect[291.695 3264.3 299.997 3172.98]/D[null/XYZ 36.1346 337.815 null]>>/section*.547<</Rect[291.695 1477.3 299.997 1385.98]/D[null/XYZ 36.1346 553.059 null]>>/section*.241<</Rect[291.695 1560.3 299.997 1468.98]/D[null/XYZ 36.1346 543.062 null]>>/section*.548<</Rect[291.695 2022.3 299.997 1930.98]/D[null/XYZ 36.1346 487.414 null]>>/section*.242<</Rect[291.695 3600.3 299.997 3508.98]/D[null/XYZ 36.1346 297.344 null]>>/section*.549<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.243<</Rect[291.695 4284.3 299.997 4192.98]/D[null/XYZ 36.1346 214.956 null]>>/section*.244<</Rect[291.695 2603.3 299.997 2511.97]/D[null/XYZ 36.1346 417.433 null]>>/section*.245<</Rect[291.695 3936.3 299.997 3844.98]/D[null/XYZ 36.1346 256.873 null]>>/section*.246<</Rect[291.695 2058.3 299.997 1966.97]/D[null/XYZ 36.1346 483.078 null]>>/section*.247<</Rect[291.695 1529.3 299.997 1437.98]/D[null/XYZ 36.1346 546.796 null]>>/section*.248<</Rect[291.695 2985.3 299.997 2893.98]/D[null/XYZ 36.1346 371.421 null]>>/section*.249<</Rect[291.695 4557.3 299.997 4465.98]/D[null/XYZ 36.1346 182.073 null]>>/page.670<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.671<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.672<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.673<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.674<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.675<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.676<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.370<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.677<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.371<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.678<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.372<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.679<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.373<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.374<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.375<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.376<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.550<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.377<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.551<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/page.378<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.552<</Rect[291.695 2277.3 299.997 2185.98]/D[null/XYZ 36.1346 456.699 null]>>/page.379<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.553<</Rect[291.695 3268.3 299.997 3176.97]/D[null/XYZ 36.1346 337.333 null]>>/section*.554<</Rect[291.695 3794.3 299.997 3702.98]/D[null/XYZ 36.1346 273.976 null]>>/section*.555<</Rect[291.695 4339.3 299.997 4247.98]/D[null/XYZ 36.1346 208.331 null]>>/section*.556<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/section*.250<</Rect[291.695 1566.3 299.997 1474.98]/D[null/XYZ 36.1346 542.339 null]>>/section*.557<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.251<</Rect[291.695 2391.3 299.997 2299.98]/D[null/XYZ 36.1346 442.968 null]>>/section*.558<</Rect[291.695 2301.3 299.997 2209.98]/D[null/XYZ 36.1346 453.808 null]>>/section*.252<</Rect[291.695 936.3 299.997 844.976]/D[null/XYZ 36.1346 618.223 null]>>/section*.559<</Rect[291.695 3225.3 299.997 3133.98]/D[null/XYZ 36.1346 342.513 null]>>/section*.253<</Rect[291.695 3106.3 299.997 3014.98]/D[null/XYZ 36.1346 356.846 null]>>/section*.254<</Rect[291.695 3749.3 299.997 3657.98]/D[null/XYZ 36.1346 279.397 null]>>/section*.255<</Rect[291.695 1476.3 299.997 1384.98]/D[null/XYZ 36.1346 553.18 null]>>/section*.256<</Rect[291.695 2598.3 299.997 2506.97]/D[null/XYZ 36.1346 418.035 null]>>/section*.257<</Rect[291.695 3980.3 299.997 3888.98]/D[null/XYZ 36.1346 251.573 null]>>/section*.258<</Rect[291.695 790.301 299.997 698.977]/D[null/XYZ 36.1346 635.808 null]>>/section*.259<</Rect[291.695 2378.3 299.997 2286.97]/D[null/XYZ 36.1346 444.534 null]>>/page.680<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.681<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.682<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.683<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.684<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.685<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.686<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.380<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.687<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.381<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.688<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.382<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.689<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.383<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.384<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.385<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.386<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.560<</Rect[291.695 2110.3 299.997 2018.98]/D[null/XYZ 36.1346 476.814 null]>>/page.387<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.561<</Rect[291.695 2654.3 299.997 2562.98]/D[null/XYZ 36.1346 411.289 null]>>/page.388<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.562<</Rect[291.695 3353.3 299.997 3261.97]/D[null/XYZ 36.1346 327.095 null]>>/page.389<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.563<</Rect[291.695 3978.3 299.997 3886.98]/D[null/XYZ 36.1346 251.814 null]>>/section*.564<</Rect[291.695 4523.3 299.997 4431.98]/D[null/XYZ 36.1346 186.169 null]>>/section*.565<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/section*.566<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.260<</Rect[291.695 3351.3 299.997 3259.98]/D[null/XYZ 36.1346 327.336 null]>>/section*.567<</Rect[291.695 2499.3 299.997 2407.98]/D[null/XYZ 36.1346 429.959 null]>>/section*.261<</Rect[291.695 4012.3 299.997 3920.98]/D[null/XYZ 36.1346 247.719 null]>>/section*.568<</Rect[291.695 3988.3 299.997 3896.98]/D[null/XYZ 36.1346 250.609 null]>>/section*.262<</Rect[291.695 2603.3 299.997 2511.97]/D[null/XYZ 36.1346 417.433 null]>>/section*.569<</Rect[291.695 2188.3 299.997 2096.97]/D[null/XYZ 36.1346 467.419 null]>>/section*.263<</Rect[291.695 4098.3 299.997 4006.98]/D[null/XYZ 36.1346 237.36 null]>>/section*.264<</Rect[291.695 789.302 299.997 697.977]/D[null/XYZ 36.1346 635.929 null]>>/section*.265<</Rect[291.695 2753.3 299.997 2661.97]/D[null/XYZ 36.1346 399.365 null]>>/section*.266<</Rect[291.695 902.3 299.997 810.975]/D[null/XYZ 36.1346 622.318 null]>>/section*.267<</Rect[291.695 3739.3 299.997 3647.98]/D[null/XYZ 36.1346 280.601 null]>>/section*.268<</Rect[291.695 1414.3 299.997 1322.98]/D[null/XYZ 36.1346 560.647 null]>>/section*.269<</Rect[291.695 1763.3 299.997 1671.97]/D[null/XYZ 36.1346 518.611 null]>>/page.690<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.691<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.692<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.693<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.694<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.695<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.696<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.390<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.697<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.391<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.698<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.392<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.699<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.393<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.394<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.395<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.396<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.570<</Rect[291.695 2831.3 299.997 2739.98]/D[null/XYZ 36.1346 389.97 null]>>/page.397<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.571<</Rect[291.695 4305.3 299.997 4213.98]/D[null/XYZ 36.1346 212.427 null]>>/page.398<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.572<</Rect[291.695 4848.3 299.997 4756.98]/D[null/XYZ 36.1346 147.022 null]>>/page.399<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.573<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/section*.574<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.575<</Rect[291.695 2500.3 299.997 2408.98]/D[null/XYZ 36.1346 429.839 null]>>/section*.576<</Rect[291.695 4421.3 299.997 4329.98]/D[null/XYZ 36.1346 198.454 null]>>/section*.270<</Rect[291.695 2800.3 299.997 2708.98]/D[null/XYZ 36.1346 393.704 null]>>/section*.577<</Rect[291.695 3144.3 299.997 3052.98]/D[null/XYZ 36.1346 352.269 null]>>/section*.271<</Rect[291.695 3543.3 299.997 3451.98]/D[null/XYZ 36.1346 304.21 null]>>/section*.578<</Rect[291.695 3785.3 299.997 3693.98]/D[null/XYZ 36.1346 275.06 null]>>/section*.272<</Rect[291.695 4848.3 299.997 4756.98]/D[null/XYZ 36.1346 147.022 null]>>/section*.579<</Rect[291.695 944.302 299.997 852.977]/D[null/XYZ 36.1346 617.259 null]>>/section*.273<</Rect[291.695 2961.3 299.997 2869.98]/D[null/XYZ 36.1346 374.311 null]>>/section*.274<</Rect[291.695 4251.3 299.997 4159.98]/D[null/XYZ 36.1346 218.931 null]>>/section*.275<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/section*.276<</Rect[291.695 2910.3 299.997 2818.98]/D[null/XYZ 36.1346 380.454 null]>>/section*.277<</Rect[291.695 3851.3 299.997 3759.98]/D[null/XYZ 36.1346 267.111 null]>>/section*.278<</Rect[291.695 4483.3 299.997 4391.98]/D[null/XYZ 36.1346 190.987 null]>>/section*.279<</Rect[291.695 1483.3 299.997 1391.97]/D[null/XYZ 36.1346 552.337 null]>>/section*.580<</Rect[291.695 1489.3 299.997 1397.98]/D[null/XYZ 36.1346 551.614 null]>>/section*.581<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/section*.582<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.583<</Rect[291.695 2400.3 299.997 2308.98]/D[null/XYZ 36.1346 441.884 null]>>/section*.584<</Rect[291.695 3890.3 299.997 3798.98]/D[null/XYZ 36.1346 262.413 null]>>/section*.585<</Rect[291.695 3106.3 299.997 3014.98]/D[null/XYZ 36.1346 356.846 null]>>/section*.586<</Rect[291.695 3750.3 299.997 3658.98]/D[null/XYZ 36.1346 279.276 null]>>/section*.280<</Rect[291.695 3136.3 299.997 3044.98]/D[null/XYZ 36.1346 353.233 null]>>/section*.587<</Rect[291.695 4681.3 299.997 4589.98]/D[null/XYZ 36.1346 167.137 null]>>/section*.281<</Rect[291.695 4061.3 299.997 3969.98]/D[null/XYZ 36.1346 241.816 null]>>/section*.588<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.282<</Rect[291.695 4457.3 299.997 4365.98]/D[null/XYZ 36.1346 194.118 null]>>/section*.589<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/section*.283<</Rect[291.695 3901.3 299.997 3809.98]/D[null/XYZ 36.1346 261.088 null]>>/section*.284<</Rect[291.695 2252.3 299.997 2160.98]/D[null/XYZ 36.1346 459.71 null]>>/section*.285<</Rect[291.695 1195.3 299.997 1103.98]/D[null/XYZ 36.1346 587.026 null]>>/section*.286<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.287<</Rect[291.695 3604.3 299.997 3512.98]/D[null/XYZ 36.1346 296.862 null]>>/section*.288<</Rect[291.695 1517.3 299.997 1425.98]/D[null/XYZ 36.1346 548.241 null]>>/section*.289<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.590<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.591<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.592<</Rect[291.695 2035.3 299.997 1943.98]/D[null/XYZ 36.1346 485.848 null]>>/section*.593<</Rect[291.695 2761.3 299.997 2669.98]/D[null/XYZ 36.1346 398.401 null]>>/section*.594<</Rect[291.695 4663.3 299.997 4571.98]/D[null/XYZ 36.1346 169.306 null]>>/section*.595<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.596<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/section*.290<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.597<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/section*.291<</Rect[291.695 2676.3 299.997 2584.98]/D[null/XYZ 36.1346 408.64 null]>>/section*.598<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.292<</Rect[291.695 2540.3 299.997 2448.98]/D[null/XYZ 36.1346 425.021 null]>>/section*.599<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/section*.293<</Rect[291.695 3238.3 299.997 3146.97]/D[null/XYZ 36.1346 340.947 null]>>/section*.294<</Rect[291.695 2739.3 299.997 2647.98]/D[null/XYZ 36.1346 401.051 null]>>/section*.295<</Rect[291.695 2943.3 299.997 2851.97]/D[null/XYZ 36.1346 376.48 null]>>/section*.296<</Rect[291.695 2806.3 299.997 2714.98]/D[null/XYZ 36.1346 392.981 null]>>/section*.297<</Rect[291.695 3979.3 299.997 3887.98]/D[null/XYZ 36.1346 251.693 null]>>/section*.298<</Rect[291.695 2639.3 299.997 2547.98]/D[null/XYZ 36.1346 413.096 null]>>/section*.299<</Rect[291.695 2091.3 299.997 1999.98]/D[null/XYZ 36.1346 479.103 null]>>/chapter.1<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.2<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.3<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.4<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.5<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.6<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.7<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.8<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/chapter.9<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.3.10<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.3.11<</Rect[291.695 3071.3 299.997 2979.98]/D[null/XYZ 36.1346 361.062 null]>>/section.3.12<</Rect[291.695 3808.3 299.997 3716.98]/D[null/XYZ 36.1346 272.29 null]>>/section.3.13<</Rect[291.695 3682.3 299.997 3590.98]/D[null/XYZ 36.1346 287.467 null]>>/section.3.14<</Rect[291.695 4236.3 299.997 4144.98]/D[null/XYZ 36.1346 220.738 null]>>/section.3.15<</Rect[291.695 3679.3 299.997 3587.98]/D[null/XYZ 36.1346 287.828 null]>>/section.3.16<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/figure.3.1<</Rect[1842.7 2585.3 1859.3 2568.7]/D[null/XYZ 222.953 409.601 null]>>/figure.3.2<</Rect[1565.7 4974.3 1582.3 4957.7]/D[null/XYZ 189.588 121.845 null]>>/subsection.2.8.1<</Rect[291.695 2683.3 299.997 2591.97]/D[null/XYZ 36.1346 407.797 null]>>/figure.3.3<</Rect[1881.69 3471.3 1898.3 3454.7]/D[null/XYZ 227.65 302.882 null]>>/subsection.2.8.2<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/figure.3.4<</Rect[1640.7 4027.3 1657.3 4010.7]/D[null/XYZ 198.622 235.912 null]>>/subsection.2.8.3<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.2.5.1<</Rect[291.695 807.3 299.997 715.975]/D[null/XYZ 36.1346 633.761 null]>>/subsection.2.5.2<</Rect[291.695 4109.3 299.997 4017.98]/D[null/XYZ 36.1346 236.035 null]>>/subsection.2.5.3<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.2.5.4<</Rect[291.695 2897.3 299.997 2805.98]/D[null/XYZ 36.1346 382.02 null]>>/subsection.2.5.5<</Rect[291.695 3826.3 299.997 3734.98]/D[null/XYZ 36.1346 270.122 null]>>/subsection.2.5.6<</Rect[291.695 2728.3 299.997 2636.97]/D[null/XYZ 36.1346 402.376 null]>>/subsection.2.5.7<</Rect[291.695 2218.3 299.997 2126.97]/D[null/XYZ 36.1346 463.806 null]>>/subsection.5.6.1<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.5.6.2<</Rect[291.695 4411.3 299.997 4319.98]/D[null/XYZ 36.1346 199.659 null]>>/subsection.5.6.3<</Rect[291.695 4491.3 299.997 4399.98]/D[null/XYZ 36.1346 190.023 null]>>/subsection.5.6.4<</Rect[291.695 780.301 299.997 688.977]/D[null/XYZ 36.1346 637.013 null]>>/subsection.5.6.5<</Rect[291.695 824.302 299.997 732.977]/D[null/XYZ 36.1346 631.713 null]>>/subsection.5.3.1<</Rect[291.695 1818.3 299.997 1726.97]/D[null/XYZ 36.1346 511.986 null]>>/subsection.5.3.2<</Rect[291.695 1978.3 299.997 1886.97]/D[null/XYZ 36.1346 492.714 null]>>/subsection.5.3.3<</Rect[291.695 1139.3 299.997 1047.98]/D[null/XYZ 36.1346 593.771 null]>>/subsection.5.3.4<</Rect[291.695 3984.3 299.997 3892.98]/D[null/XYZ 36.1346 251.091 null]>>/subsection.5.3.5<</Rect[291.695 1870.3 299.997 1778.98]/D[null/XYZ 36.1346 505.722 null]>>/subsection.5.3.6<</Rect[291.695 4580.3 299.997 4488.98]/D[null/XYZ 36.1346 179.303 null]>>/subsection.5.3.7<</Rect[291.695 2548.3 299.997 2456.97]/D[null/XYZ 36.1346 424.057 null]>>/subsection.5.3.8<</Rect[291.695 4494.3 299.997 4402.98]/D[null/XYZ 36.1346 189.661 null]>>/subsection.5.3.9<</Rect[291.695 3379.3 299.997 3287.98]/D[null/XYZ 36.1346 323.963 null]>>/subsection.8.1.1<</Rect[291.695 3206.3 299.997 3114.98]/D[null/XYZ 36.1346 344.801 null]>>/subsection.8.1.2<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.8.1.3<</Rect[291.695 1620.3 299.997 1528.98]/D[null/XYZ 36.1346 535.835 null]>>/table.4.1<</Rect[1684.7 1725.3 1701.3 1708.7]/D[null/XYZ 203.922 513.187 null]>>/table.4.2<</Rect[1526.69 667.3 1543.3 650.695]/D[null/XYZ 184.89 640.624 null]>>/table.4.3<</Rect[1544.7 667.3 1561.3 650.695]/D[null/XYZ 187.059 640.624 null]>>/table.1.1<</Rect[1420.7 3807.3 1437.3 3790.7]/D[null/XYZ 172.123 262.411 null]>>/table.1.2<</Rect[1331.69 1004.3 1348.3 987.697]/D[null/XYZ 161.403 600.032 null]>>/page.xiii<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/table.1.3<</Rect[1293.7 2225.3 1310.3 2208.7]/D[null/XYZ 156.826 452.962 null]>>/table.1.4<</Rect[967.697 4659.3 984.302 4642.7]/D[null/XYZ 117.559 159.787 null]>>/subsection.2.15.1<</Rect[291.695 3011.3 299.997 2919.98]/D[null/XYZ 36.1346 368.289 null]>>/subsection.2.12.1<</Rect[291.695 2717.3 299.997 2625.98]/D[null/XYZ 36.1346 403.701 null]>>/subsection.2.12.2<</Rect[291.695 4404.3 299.997 4312.98]/D[null/XYZ 36.1346 200.502 null]>>/Item.100<</Rect[291.695 1648.3 299.997 1556.97]/D[null/XYZ 36.1346 532.462 null]>>/Item.101<</Rect[291.695 2312.3 299.997 2220.98]/D[null/XYZ 36.1346 452.484 null]>>/Item.102<</Rect[291.695 2479.3 299.997 2387.98]/D[null/XYZ 36.1346 432.368 null]>>/Item.103<</Rect[291.695 2645.3 299.997 2553.98]/D[null/XYZ 36.1346 412.374 null]>>/Item.104<</Rect[291.695 2535.3 299.997 2443.98]/D[null/XYZ 36.1346 425.623 null]>>/Item.105<</Rect[291.695 2701.3 299.997 2609.98]/D[null/XYZ 36.1346 405.628 null]>>/Item.106<</Rect[291.695 3453.3 299.997 3361.98]/D[null/XYZ 36.1346 315.05 null]>>/Item.107<</Rect[291.695 4108.3 299.997 4016.98]/D[null/XYZ 36.1346 236.155 null]>>/Item.108<</Rect[291.695 1853.3 299.997 1761.97]/D[null/XYZ 36.1346 507.77 null]>>/Item.109<</Rect[291.695 2008.3 299.997 1916.97]/D[null/XYZ 36.1346 489.1 null]>>/Item.110<</Rect[291.695 2162.3 299.997 2070.98]/D[null/XYZ 36.1346 470.551 null]>>/Item.111<</Rect[291.695 2310.3 299.997 2218.98]/D[null/XYZ 36.1346 452.724 null]>>/Item.112<</Rect[291.695 1377.3 299.997 1285.98]/D[null/XYZ 36.1346 565.104 null]>>/Item.113<</Rect[291.695 2329.3 299.997 2237.98]/D[null/XYZ 36.1346 450.436 null]>>/Item.114<</Rect[291.695 2695.3 299.997 2603.98]/D[null/XYZ 36.1346 406.351 null]>>/Item.115<</Rect[291.695 2837.3 299.997 2745.98]/D[null/XYZ 36.1346 389.247 null]>>/Item.116<</Rect[291.695 3309.3 299.997 3217.98]/D[null/XYZ 36.1346 332.395 null]>>/Item.117<</Rect[291.695 732.3 299.997 640.975]/D[null/XYZ 36.1346 642.794 null]>>/Item.118<</Rect[291.695 1315.3 299.997 1223.98]/D[null/XYZ 36.1346 572.572 null]>>/Item.119<</Rect[291.695 2593.3 299.997 2501.97]/D[null/XYZ 36.1346 418.637 null]>>/Item.120<</Rect[291.695 2235.3 299.997 2143.98]/D[null/XYZ 36.1346 461.758 null]>>/Item.121<</Rect[291.695 2395.3 299.997 2303.98]/D[null/XYZ 36.1346 442.486 null]>>/Item.122<</Rect[291.695 2556.3 299.997 2464.98]/D[null/XYZ 36.1346 423.094 null]>>/Item.123<</Rect[291.695 4305.3 299.997 4213.98]/D[null/XYZ 36.1346 212.427 null]>>/Item.124<</Rect[291.695 4466.3 299.997 4374.98]/D[null/XYZ 36.1346 193.034 null]>>/Item.125<</Rect[291.695 4632.3 299.997 4540.98]/D[null/XYZ 36.1346 173.04 null]>>/Item.126<</Rect[291.695 4798.3 299.997 4706.98]/D[null/XYZ 36.1346 153.045 null]>>/Item.127<</Rect[291.695 3690.3 299.997 3598.98]/D[null/XYZ 36.1346 286.503 null]>>/Item.128<</Rect[291.695 3935.3 299.997 3843.98]/D[null/XYZ 36.1346 256.993 null]>>/Item.129<</Rect[291.695 4172.3 299.997 4080.98]/D[null/XYZ 36.1346 228.447 null]>>/Item.130<</Rect[291.695 2071.3 299.997 1979.98]/D[null/XYZ 36.1346 481.512 null]>>/Item.131<</Rect[291.695 2253.3 299.997 2161.97]/D[null/XYZ 36.1346 459.59 null]>>/Item.132<</Rect[291.695 2417.3 299.997 2325.98]/D[null/XYZ 36.1346 439.836 null]>>/Item.133<</Rect[291.695 2681.3 299.997 2589.98]/D[null/XYZ 36.1346 408.037 null]>>/Item.134<</Rect[291.695 3738.3 299.997 3646.98]/D[null/XYZ 36.1346 280.722 null]>>/Item.135<</Rect[291.695 3953.3 299.997 3861.98]/D[null/XYZ 36.1346 254.825 null]>>/Item.136<</Rect[291.695 4151.3 299.997 4059.98]/D[null/XYZ 36.1346 230.976 null]>>/Item.137<</Rect[291.695 4383.3 299.997 4291.98]/D[null/XYZ 36.1346 203.032 null]>>/Item.138<</Rect[291.695 4947.3 299.997 4855.98]/D[null/XYZ 36.1346 135.098 null]>>/Item.139<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.140<</Rect[291.695 619.302 299.997 527.977]/D[null/XYZ 36.1346 656.405 null]>>/Item.141<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.142<</Rect[291.695 917.3 299.997 825.975]/D[null/XYZ 36.1346 620.511 null]>>/Item.143<</Rect[291.695 1248.3 299.997 1156.97]/D[null/XYZ 36.1346 580.642 null]>>/Item.144<</Rect[291.695 1579.3 299.997 1487.98]/D[null/XYZ 36.1346 540.773 null]>>/Item.145<</Rect[291.695 4427.3 299.997 4335.98]/D[null/XYZ 36.1346 197.732 null]>>/Item.146<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.147<</Rect[291.695 1688.3 299.997 1596.97]/D[null/XYZ 36.1346 527.644 null]>>/Item.148<</Rect[291.695 946.3 299.997 854.976]/D[null/XYZ 36.1346 617.018 null]>>/Item.149<</Rect[291.695 2535.3 299.997 2443.98]/D[null/XYZ 36.1346 425.623 null]>>/subsection.4.5.1<</Rect[291.695 1523.3 299.997 1431.97]/D[null/XYZ 36.1346 547.519 null]>>/subsection.4.5.2<</Rect[291.695 1875.3 299.997 1783.98]/D[null/XYZ 36.1346 505.12 null]>>/Item.150<</Rect[291.695 2335.3 299.997 2243.98]/D[null/XYZ 36.1346 449.713 null]>>/subsection.4.5.3<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.151<</Rect[291.695 2501.3 299.997 2409.98]/D[null/XYZ 36.1346 429.718 null]>>/subsection.4.5.4<</Rect[291.695 985.301 299.997 893.977]/D[null/XYZ 36.1346 612.32 null]>>/Item.152<</Rect[291.695 2667.3 299.997 2575.98]/D[null/XYZ 36.1346 409.724 null]>>/subsection.4.5.5<</Rect[291.695 1511.3 299.997 1419.98]/D[null/XYZ 36.1346 548.964 null]>>/Item.153<</Rect[291.695 3225.3 299.997 3133.98]/D[null/XYZ 36.1346 342.513 null]>>/Item.154<</Rect[291.695 3505.3 299.997 3413.98]/D[null/XYZ 36.1346 308.786 null]>>/Item.155<</Rect[291.695 4066.3 299.997 3974.98]/D[null/XYZ 36.1346 241.214 null]>>/subsection.4.2.1<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.156<</Rect[291.695 1727.3 299.997 1635.98]/D[null/XYZ 36.1346 522.947 null]>>/subsection.4.2.2<</Rect[291.695 2870.3 299.997 2778.98]/D[null/XYZ 36.1346 385.272 null]>>/Item.157<</Rect[291.695 1992.3 299.997 1900.98]/D[null/XYZ 36.1346 491.027 null]>>/subsection.4.2.3<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.158<</Rect[291.695 2391.3 299.997 2299.98]/D[null/XYZ 36.1346 442.968 null]>>/subsection.4.2.4<</Rect[291.695 3162.3 299.997 3070.98]/D[null/XYZ 36.1346 350.101 null]>>/Item.159<</Rect[291.695 2972.3 299.997 2880.98]/D[null/XYZ 36.1346 372.987 null]>>/Item.160<</Rect[291.695 1965.3 299.997 1873.98]/D[null/XYZ 36.1346 494.28 null]>>/Item.161<</Rect[291.695 2131.3 299.997 2039.98]/D[null/XYZ 36.1346 474.285 null]>>/Item.162<</Rect[291.695 2298.3 299.997 2206.97]/D[null/XYZ 36.1346 454.17 null]>>/Item.163<</Rect[291.695 4303.3 299.997 4211.98]/D[null/XYZ 36.1346 212.668 null]>>/Item.164<</Rect[291.695 4446.3 299.997 4354.98]/D[null/XYZ 36.1346 195.443 null]>>/Item.165<</Rect[291.695 4461.3 299.997 4369.98]/D[null/XYZ 36.1346 193.636 null]>>/Item.166<</Rect[291.695 4639.3 299.997 4547.98]/D[null/XYZ 36.1346 172.196 null]>>/Item.167<</Rect[291.695 4805.3 299.997 4713.98]/D[null/XYZ 36.1346 152.202 null]>>/Item.168<</Rect[291.695 4971.3 299.997 4879.98]/D[null/XYZ 36.1346 132.207 null]>>/Item.169<</Rect[291.695 1665.3 299.997 1573.98]/D[null/XYZ 36.1346 530.414 null]>>/Item.170<</Rect[291.695 1931.3 299.997 1839.98]/D[null/XYZ 36.1346 498.375 null]>>/Item.171<</Rect[291.695 1482.3 299.997 1390.98]/D[null/XYZ 36.1346 552.457 null]>>/Item.172<</Rect[291.695 1647.3 299.997 1555.98]/D[null/XYZ 36.1346 532.583 null]>>/Item.173<</Rect[291.695 2014.3 299.997 1922.98]/D[null/XYZ 36.1346 488.377 null]>>/Item.174<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.175<</Rect[291.695 1690.3 299.997 1598.98]/D[null/XYZ 36.1346 527.403 null]>>/Item.176<</Rect[291.695 1955.3 299.997 1863.98]/D[null/XYZ 36.1346 495.484 null]>>/Item.177<</Rect[291.695 3744.3 299.997 3652.98]/D[null/XYZ 36.1346 279.999 null]>>/Item.178<</Rect[291.695 4346.3 299.997 4254.98]/D[null/XYZ 36.1346 207.488 null]>>/Item.179<</Rect[291.695 2471.3 299.997 2379.98]/D[null/XYZ 36.1346 433.332 null]>>/Item.180<</Rect[291.695 3859.3 299.997 3767.98]/D[null/XYZ 36.1346 266.147 null]>>/Item.181<</Rect[291.695 4325.3 299.997 4233.98]/D[null/XYZ 36.1346 210.018 null]>>/Item.182<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.183<</Rect[291.695 2042.3 299.997 1950.98]/D[null/XYZ 36.1346 485.005 null]>>/Item.184<</Rect[291.695 2905.3 299.997 2813.98]/D[null/XYZ 36.1346 381.057 null]>>/Item.185<</Rect[291.695 3751.3 299.997 3659.98]/D[null/XYZ 36.1346 279.156 null]>>/Item.186<</Rect[291.695 2887.3 299.997 2795.98]/D[null/XYZ 36.1346 383.225 null]>>/Item.187<</Rect[291.695 3041.3 299.997 2949.98]/D[null/XYZ 36.1346 364.675 null]>>/Item.188<</Rect[291.695 3194.3 299.997 3102.98]/D[null/XYZ 36.1346 346.246 null]>>/Item.189<</Rect[291.695 3331.3 299.997 3239.98]/D[null/XYZ 36.1346 329.745 null]>>/Item.190<</Rect[291.695 4345.3 299.997 4253.98]/D[null/XYZ 36.1346 207.608 null]>>/Item.191<</Rect[291.695 4594.3 299.997 4502.98]/D[null/XYZ 36.1346 177.616 null]>>/Item.192<</Rect[291.695 4777.3 299.997 4685.98]/D[null/XYZ 36.1346 155.574 null]>>/Item.193<</Rect[291.695 1007.3 299.997 915.975]/D[null/XYZ 36.1346 609.671 null]>>/Item.194<</Rect[291.695 1146.3 299.997 1054.98]/D[null/XYZ 36.1346 592.928 null]>>/Item.195<</Rect[291.695 1301.3 299.997 1209.98]/D[null/XYZ 36.1346 574.258 null]>>/Item.196<</Rect[291.695 1456.3 299.997 1364.98]/D[null/XYZ 36.1346 555.589 null]>>/Item.197<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.198<</Rect[291.695 629.302 299.997 537.977]/D[null/XYZ 36.1346 655.201 null]>>/Item.199<</Rect[291.695 783.299 299.997 691.975]/D[null/XYZ 36.1346 636.652 null]>>/Item.1<</Rect[291.695 1434.3 299.997 1351.28]/D[null/XYZ 36.1346 557.238 null]>>/Item.2<</Rect[291.695 4912.3 299.997 4829.28]/D[null/XYZ 36.1346 138.314 null]>>/page.700<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.3<</Rect[291.695 703.299 299.997 620.277]/D[null/XYZ 36.1346 645.288 null]>>/page.701<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.4<</Rect[291.695 1634.3 299.997 1551.28]/D[null/XYZ 36.1346 533.148 null]>>/page.702<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.5<</Rect[291.695 3775.3 299.997 3692.28]/D[null/XYZ 36.1346 275.265 null]>>/page.703<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.6<</Rect[291.695 4264.3 299.997 4181.28]/D[null/XYZ 36.1346 216.365 null]>>/page.704<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.7<</Rect[291.695 4572.3 299.997 4489.28]/D[null/XYZ 36.1346 179.267 null]>>/page.705<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.8<</Rect[291.695 687.3 299.997 604.278]/D[null/XYZ 36.1346 647.215 null]>>/page.706<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.9<</Rect[291.695 1375.3 299.997 1292.28]/D[null/XYZ 36.1346 564.345 null]>>/page.400<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.707<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.401<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.708<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.402<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.709<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.8.1<</Rect[291.695 2338.3 299.997 2246.97]/D[null/XYZ 36.1346 449.352 null]>>/page.403<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.8.2<</Rect[291.695 3647.3 299.997 3555.98]/D[null/XYZ 36.1346 291.683 null]>>/page.404<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.8.3<</Rect[291.695 2707.3 299.997 2615.98]/D[null/XYZ 36.1346 404.906 null]>>/page.405<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.8.4<</Rect[291.695 1425.3 299.997 1333.98]/D[null/XYZ 36.1346 559.323 null]>>/page.406<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.8.5<</Rect[291.695 2410.3 299.997 2318.98]/D[null/XYZ 36.1346 440.679 null]>>/page.100<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.407<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.8.6<</Rect[291.695 1729.3 299.997 1637.98]/D[null/XYZ 36.1346 522.706 null]>>/page.101<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.408<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.8.7<</Rect[291.695 2035.3 299.997 1943.98]/D[null/XYZ 36.1346 485.848 null]>>/page.102<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.409<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.5.1<</Rect[291.695 2338.3 299.997 2246.97]/D[null/XYZ 36.1346 449.352 null]>>/page.103<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.5.2<</Rect[291.695 2509.3 299.997 2417.98]/D[null/XYZ 36.1346 428.755 null]>>/page.104<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.5.3<</Rect[291.695 1532.3 299.997 1440.98]/D[null/XYZ 36.1346 546.435 null]>>/page.105<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.5.4<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.106<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.5.5<</Rect[291.695 4322.3 299.997 4230.98]/D[null/XYZ 36.1346 210.379 null]>>/page.107<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.5.6<</Rect[291.695 2360.3 299.997 2268.98]/D[null/XYZ 36.1346 446.702 null]>>/page.108<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.109<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.2.1<</Rect[291.695 2314.3 299.997 2222.98]/D[null/XYZ 36.1346 452.242 null]>>/section.2.2<</Rect[291.695 4224.3 299.997 4132.98]/D[null/XYZ 36.1346 222.183 null]>>/section.2.3<</Rect[291.695 2095.3 299.997 2003.98]/D[null/XYZ 36.1346 478.621 null]>>/section.2.4<</Rect[291.695 3500.3 299.997 3408.98]/D[null/XYZ 36.1346 309.389 null]>>/section.2.5<</Rect[291.695 3208.3 299.997 3116.97]/D[null/XYZ 36.1346 344.56 null]>>/section.2.6<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.2.7<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.2.8<</Rect[291.695 4544.3 299.997 4452.98]/D[null/XYZ 36.1346 183.639 null]>>/section.2.9<</Rect[291.695 1025.3 299.997 933.977]/D[null/XYZ 36.1346 607.503 null]>>/page.710<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.711<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.712<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.713<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.714<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.715<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.716<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.410<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.717<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.411<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.718<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.412<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.719<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.413<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.414<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.415<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.416<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.110<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.417<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.111<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.418<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.112<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.419<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.113<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.114<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.115<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.116<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.117<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.118<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.119<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.720<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.721<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.722<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.723<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.724<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.725<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.726<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.420<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.727<</Rect[291.695 228.299 308.299 211.695]/D[42 0 R/XYZ 36.1346 693.501 null]>>/page.421<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.728<</Rect[291.695 228.299 308.299 211.695]/D[1 0 R/XYZ 36.1346 693.501 null]>>/page.422<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.729<</Rect[291.695 228.299 308.299 211.695]/D[4 0 R/XYZ 36.1346 693.501 null]>>/page.423<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.424<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.425<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.426<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.600<</Rect[291.695 1596.3 299.997 1504.98]/D[null/XYZ 36.1346 538.726 null]>>/page.120<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.427<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.601<</Rect[291.695 2387.3 299.997 2295.98]/D[null/XYZ 36.1346 443.45 null]>>/page.121<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.428<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.602<</Rect[291.695 4754.3 299.997 4662.98]/D[null/XYZ 36.1346 158.344 null]>>/page.122<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.429<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.603<</Rect[291.695 2236.3 299.997 2144.98]/D[null/XYZ 36.1346 461.638 null]>>/page.123<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.604<</Rect[291.695 4205.3 299.997 4113.98]/D[null/XYZ 36.1346 224.471 null]>>/page.124<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.605<</Rect[291.695 4929.3 299.997 4837.98]/D[null/XYZ 36.1346 137.266 null]>>/page.125<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.606<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/page.126<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.300<</Rect[291.695 3382.3 299.997 3290.98]/D[null/XYZ 36.1346 323.602 null]>>/section*.607<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/page.127<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.301<</Rect[291.695 3780.3 299.997 3688.98]/D[null/XYZ 36.1346 275.663 null]>>/section*.608<</Rect[291.695 1238.3 299.997 1146.97]/D[null/XYZ 36.1346 581.847 null]>>/page.128<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.302<</Rect[291.695 1400.3 299.997 1308.98]/D[null/XYZ 36.1346 562.334 null]>>/section*.609<</Rect[291.695 2489.3 299.997 2397.98]/D[null/XYZ 36.1346 431.164 null]>>/page.129<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.303<</Rect[291.695 1561.3 299.997 1469.98]/D[null/XYZ 36.1346 542.941 null]>>/section*.304<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.305<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.306<</Rect[291.695 1935.3 299.997 1843.98]/D[null/XYZ 36.1346 497.893 null]>>/section*.307<</Rect[291.695 2761.3 299.997 2669.98]/D[null/XYZ 36.1346 398.401 null]>>/section*.308<</Rect[291.695 3335.3 299.997 3243.98]/D[null/XYZ 36.1346 329.263 null]>>/section*.309<</Rect[291.695 3861.3 299.997 3769.98]/D[null/XYZ 36.1346 265.906 null]>>/page.730<</Rect[291.695 228.299 308.299 211.695]/D[7 0 R/XYZ 36.1346 693.501 null]>>/page.731<</Rect[291.695 228.299 308.299 211.695]/D[10 0 R/XYZ 36.1346 693.501 null]>>/page.732<</Rect[291.695 228.299 308.299 211.695]/D[13 0 R/XYZ 36.1346 693.501 null]>>/page.733<</Rect[291.695 228.299 308.299 211.695]/D[16 0 R/XYZ 36.1346 693.501 null]>>/page.734<</Rect[291.695 228.299 308.299 211.695]/D[19 0 R/XYZ 36.1346 693.501 null]>>/subsection.3.16.1<</Rect[291.695 1364.3 299.997 1272.98]/D[null/XYZ 36.1346 566.67 null]>>/page.735<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.16.2<</Rect[291.695 2147.3 299.997 2055.98]/D[null/XYZ 36.1346 472.358 null]>>/page.736<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.16.3<</Rect[291.695 3056.3 299.997 2964.98]/D[null/XYZ 36.1346 362.869 null]>>/page.430<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.737<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.16.4<</Rect[291.695 4146.3 299.997 4054.98]/D[null/XYZ 36.1346 231.578 null]>>/page.431<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.738<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.16.5<</Rect[291.695 2152.3 299.997 2060.98]/D[null/XYZ 36.1346 471.755 null]>>/page.432<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.739<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.433<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.434<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.13.1<</Rect[291.695 4430.3 299.997 4338.98]/D[null/XYZ 36.1346 197.37 null]>>/page.435<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.13.2<</Rect[291.695 2450.3 299.997 2358.98]/D[null/XYZ 36.1346 435.861 null]>>/page.436<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.610<</Rect[291.695 3674.3 299.997 3582.98]/D[null/XYZ 36.1346 288.43 null]>>/subsection.3.13.3<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.130<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.437<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.611<</Rect[291.695 1793.3 299.997 1701.97]/D[null/XYZ 36.1346 514.997 null]>>/subsection.3.13.4<</Rect[291.695 1487.3 299.997 1395.98]/D[null/XYZ 36.1346 551.855 null]>>/page.131<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.438<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.612<</Rect[291.695 2430.3 299.997 2338.98]/D[null/XYZ 36.1346 438.27 null]>>/subsection.3.13.5<</Rect[291.695 1671.3 299.997 1579.98]/D[null/XYZ 36.1346 529.692 null]>>/page.132<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.439<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.613<</Rect[291.695 4043.3 299.997 3951.98]/D[null/XYZ 36.1346 243.985 null]>>/subsection.3.13.6<</Rect[291.695 703.299 299.997 611.975]/D[null/XYZ 36.1346 646.288 null]>>/page.133<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.614<</Rect[291.695 4582.3 299.997 4490.98]/D[null/XYZ 36.1346 179.062 null]>>/subsection.3.13.7<</Rect[291.695 1787.3 299.997 1695.98]/D[null/XYZ 36.1346 515.72 null]>>/page.134<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.615<</Rect[291.695 722.3 299.997 630.975]/D[null/XYZ 36.1346 643.999 null]>>/subsection.3.10.1<</Rect[291.695 1378.3 299.997 1286.97]/D[null/XYZ 36.1346 564.984 null]>>/subsection.3.13.8<</Rect[291.695 3943.3 299.997 3851.98]/D[null/XYZ 36.1346 256.03 null]>>/page.135<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.616<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/subsection.3.10.2<</Rect[291.695 2254.3 299.997 2162.98]/D[null/XYZ 36.1346 459.469 null]>>/subsection.3.13.9<</Rect[291.695 4454.3 299.997 4362.98]/D[null/XYZ 36.1346 194.479 null]>>/page.136<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.310<</Rect[291.695 4387.3 299.997 4295.98]/D[null/XYZ 36.1346 202.55 null]>>/section*.617<</Rect[291.695 2135.3 299.997 2043.98]/D[null/XYZ 36.1346 473.803 null]>>/subsection.3.10.3<</Rect[291.695 2496.3 299.997 2404.98]/D[null/XYZ 36.1346 430.321 null]>>/page.137<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.311<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/section*.618<</Rect[291.695 2326.3 299.997 2234.98]/D[null/XYZ 36.1346 450.797 null]>>/page.138<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.312<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/section*.619<</Rect[291.695 1414.3 299.997 1322.98]/D[null/XYZ 36.1346 560.647 null]>>/page.139<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.313<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.314<</Rect[291.695 1869.3 299.997 1777.98]/D[null/XYZ 36.1346 505.843 null]>>/section*.315<</Rect[291.695 4120.3 299.997 4028.98]/D[null/XYZ 36.1346 234.71 null]>>/section*.316<</Rect[291.695 1311.3 299.997 1219.98]/D[null/XYZ 36.1346 573.054 null]>>/section*.317<</Rect[291.695 3981.3 299.997 3889.98]/D[null/XYZ 36.1346 251.452 null]>>/section*.318<</Rect[291.695 945.301 299.997 853.977]/D[null/XYZ 36.1346 617.138 null]>>/section*.319<</Rect[291.695 1570.3 299.997 1478.98]/D[null/XYZ 36.1346 541.857 null]>>/page.740<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.741<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.742<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.743<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.744<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.745<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.746<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.440<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.747<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.441<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.748<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.442<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.749<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.443<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.444<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.445<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.446<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.620<</Rect[291.695 4309.3 299.997 4217.98]/D[null/XYZ 36.1346 211.945 null]>>/page.140<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.447<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.621<</Rect[291.695 4929.3 299.997 4837.98]/D[null/XYZ 36.1346 137.266 null]>>/page.141<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.448<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.622<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/page.142<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.449<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.623<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/page.143<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.624<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.144<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.625<</Rect[291.695 1869.3 299.997 1777.98]/D[null/XYZ 36.1346 505.843 null]>>/page.145<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.626<</Rect[291.695 4189.3 299.997 4097.98]/D[null/XYZ 36.1346 226.399 null]>>/page.146<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.320<</Rect[291.695 2115.3 299.997 2023.98]/D[null/XYZ 36.1346 476.212 null]>>/section*.627<</Rect[291.695 1795.3 299.997 1703.98]/D[null/XYZ 36.1346 514.756 null]>>/page.147<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.321<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.628<</Rect[291.695 2460.3 299.997 2368.98]/D[null/XYZ 36.1346 434.657 null]>>/page.148<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.322<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.629<</Rect[291.695 3865.3 299.997 3773.98]/D[null/XYZ 36.1346 265.424 null]>>/page.149<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.323<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/section*.324<</Rect[291.695 2941.3 299.997 2849.98]/D[null/XYZ 36.1346 376.72 null]>>/section*.325<</Rect[291.695 3567.3 299.997 3475.98]/D[null/XYZ 36.1346 301.319 null]>>/section*.326<</Rect[291.695 4112.3 299.997 4020.98]/D[null/XYZ 36.1346 235.674 null]>>/section*.327<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.328<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.329<</Rect[291.695 2500.3 299.997 2408.98]/D[null/XYZ 36.1346 429.839 null]>>/page.750<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.751<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.7.1<</Rect[291.695 2496.3 299.997 2404.98]/D[null/XYZ 36.1346 430.321 null]>>/page.752<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.7.2<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.753<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.7.3<</Rect[291.695 1345.3 299.997 1253.98]/D[null/XYZ 36.1346 568.958 null]>>/page.754<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.7.4<</Rect[291.695 3586.3 299.997 3494.98]/D[null/XYZ 36.1346 299.03 null]>>/page.755<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.7.5<</Rect[291.695 4607.3 299.997 4515.98]/D[null/XYZ 36.1346 176.051 null]>>/page.756<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.450<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.757<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.451<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.758<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.4.1<</Rect[291.695 1587.3 299.997 1495.98]/D[null/XYZ 36.1346 539.81 null]>>/page.452<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.759<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.4.2<</Rect[291.695 2971.3 299.997 2879.98]/D[null/XYZ 36.1346 373.107 null]>>/page.453<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.4.3<</Rect[291.695 1653.3 299.997 1561.97]/D[null/XYZ 36.1346 531.86 null]>>/page.454<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.4.4<</Rect[291.695 3347.3 299.997 3255.98]/D[null/XYZ 36.1346 327.818 null]>>/page.455<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.4.5<</Rect[291.695 1204.3 299.997 1112.98]/D[null/XYZ 36.1346 585.942 null]>>/page.456<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.630<</Rect[291.695 4490.3 299.997 4398.98]/D[null/XYZ 36.1346 190.143 null]>>/page.150<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.4.6<</Rect[291.695 2240.3 299.997 2148.98]/D[null/XYZ 36.1346 461.156 null]>>/page.457<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.631<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/page.151<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.4.7<</Rect[291.695 4607.3 299.997 4515.98]/D[null/XYZ 36.1346 176.051 null]>>/page.458<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.632<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/subsection.3.1.1<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.152<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.4.8<</Rect[291.695 4209.3 299.997 4117.98]/D[null/XYZ 36.1346 223.99 null]>>/page.459<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.633<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/subsection.3.1.2<</Rect[291.695 1172.3 299.997 1080.98]/D[null/XYZ 36.1346 589.797 null]>>/page.153<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.634<</Rect[291.695 1869.3 299.997 1777.98]/D[null/XYZ 36.1346 505.843 null]>>/page.154<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.635<</Rect[291.695 4189.3 299.997 4097.98]/D[null/XYZ 36.1346 226.399 null]>>/page.155<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.636<</Rect[291.695 1644.3 299.997 1552.98]/D[null/XYZ 36.1346 532.944 null]>>/page.156<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.330<</Rect[291.695 4521.3 299.997 4429.98]/D[null/XYZ 36.1346 186.409 null]>>/section*.637<</Rect[291.695 671.3 299.997 579.976]/D[null/XYZ 36.1346 650.142 null]>>/page.157<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.331<</Rect[291.695 2763.3 299.997 2671.97]/D[null/XYZ 36.1346 398.161 null]>>/section*.638<</Rect[291.695 1893.3 299.997 1801.97]/D[null/XYZ 36.1346 502.952 null]>>/page.158<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.332<</Rect[291.695 3402.3 299.997 3310.98]/D[null/XYZ 36.1346 321.193 null]>>/section*.639<</Rect[291.695 2518.3 299.997 2426.97]/D[null/XYZ 36.1346 427.671 null]>>/page.159<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.333<</Rect[291.695 4929.3 299.997 4837.98]/D[null/XYZ 36.1346 137.266 null]>>/section*.334<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/section*.335<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.336<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.337<</Rect[291.695 2766.3 299.997 2674.98]/D[null/XYZ 36.1346 397.799 null]>>/section*.338<</Rect[291.695 1795.3 299.997 1703.98]/D[null/XYZ 36.1346 514.756 null]>>/section*.339<</Rect[291.695 4081.3 299.997 3989.98]/D[null/XYZ 36.1346 239.407 null]>>/subsection.6.2.1<</Rect[291.695 3431.3 299.997 3339.98]/D[null/XYZ 36.1346 317.7 null]>>/subsection.6.2.2<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.760<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.6.2.3<</Rect[291.695 4607.3 299.997 4515.98]/D[null/XYZ 36.1346 176.051 null]>>/page.761<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.6.2.4<</Rect[291.695 2882.3 299.997 2790.98]/D[null/XYZ 36.1346 383.827 null]>>/page.762<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.6.2.5<</Rect[291.695 4325.3 299.997 4233.98]/D[null/XYZ 36.1346 210.018 null]>>/page.763<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.6.2.6<</Rect[291.695 1893.3 299.997 1801.97]/D[null/XYZ 36.1346 502.952 null]>>/page.764<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.6.2.7<</Rect[291.695 3279.3 299.997 3187.98]/D[null/XYZ 36.1346 336.008 null]>>/page.765<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.6.2.8<</Rect[291.695 1653.3 299.997 1561.97]/D[null/XYZ 36.1346 531.86 null]>>/page.766<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.6.2.9<</Rect[291.695 2583.3 299.997 2491.97]/D[null/XYZ 36.1346 419.842 null]>>/page.460<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.767<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.461<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.768<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.462<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.769<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.463<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.464<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.465<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.466<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.640<</Rect[291.695 3063.3 299.997 2971.97]/D[null/XYZ 36.1346 362.026 null]>>/page.160<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.467<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.641<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/page.161<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.468<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.642<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.162<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.469<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.643<</Rect[291.695 2268.3 299.997 2176.97]/D[null/XYZ 36.1346 457.783 null]>>/page.163<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.644<</Rect[291.695 4720.3 299.997 4628.98]/D[null/XYZ 36.1346 162.44 null]>>/page.164<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.645<</Rect[291.695 2209.3 299.997 2117.98]/D[null/XYZ 36.1346 464.89 null]>>/page.165<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.646<</Rect[291.695 2835.3 299.997 2743.98]/D[null/XYZ 36.1346 389.488 null]>>/page.166<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.340<</Rect[291.695 1918.3 299.997 1826.97]/D[null/XYZ 36.1346 499.941 null]>>/section*.647<</Rect[291.695 3380.3 299.997 3288.98]/D[null/XYZ 36.1346 323.843 null]>>/page.167<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.341<</Rect[291.695 2543.3 299.997 2451.97]/D[null/XYZ 36.1346 424.66 null]>>/section*.648<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/page.168<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.342<</Rect[291.695 3088.3 299.997 2996.97]/D[null/XYZ 36.1346 359.014 null]>>/section*.649<</Rect[291.695 1241.3 299.997 1149.98]/D[null/XYZ 36.1346 581.485 null]>>/page.169<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.343<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/section*.344<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.345<</Rect[291.695 3596.3 299.997 3504.98]/D[null/XYZ 36.1346 297.826 null]>>/section*.346<</Rect[291.695 2162.3 299.997 2070.98]/D[null/XYZ 36.1346 470.551 null]>>/section*.347<</Rect[291.695 1577.3 299.997 1485.98]/D[null/XYZ 36.1346 541.014 null]>>/section*.348<</Rect[291.695 1834.3 299.997 1742.98]/D[null/XYZ 36.1346 510.058 null]>>/section*.349<</Rect[291.695 2055.3 299.997 1963.98]/D[null/XYZ 36.1346 483.439 null]>>/page.770<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.771<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.772<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.773<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.774<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.775<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.776<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.470<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.777<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.471<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.778<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.472<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.779<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.473<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.474<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.475<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.476<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.650<</Rect[291.695 1964.3 299.997 1872.98]/D[null/XYZ 36.1346 494.4 null]>>/page.170<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.477<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.651<</Rect[291.695 4884.3 299.997 4792.98]/D[null/XYZ 36.1346 142.686 null]>>/page.171<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.478<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.652<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.172<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.479<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.653<</Rect[291.695 1298.3 299.997 1206.97]/D[null/XYZ 36.1346 574.62 null]>>/page.173<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.654<</Rect[291.695 3945.3 299.997 3853.98]/D[null/XYZ 36.1346 255.788 null]>>/page.174<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.655<</Rect[291.695 1345.3 299.997 1253.98]/D[null/XYZ 36.1346 568.958 null]>>/page.175<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.656<</Rect[291.695 1870.3 299.997 1778.98]/D[null/XYZ 36.1346 505.722 null]>>/page.176<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.350<</Rect[291.695 2680.3 299.997 2588.98]/D[null/XYZ 36.1346 408.158 null]>>/section*.657<</Rect[291.695 2415.3 299.997 2323.98]/D[null/XYZ 36.1346 440.077 null]>>/page.177<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.351<</Rect[291.695 3225.3 299.997 3133.98]/D[null/XYZ 36.1346 342.513 null]>>/section*.658<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.178<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.352<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/section*.659<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.179<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.353<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.354<</Rect[291.695 2234.3 299.997 2142.98]/D[null/XYZ 36.1346 461.878 null]>>/section*.355<</Rect[291.695 3059.3 299.997 2967.98]/D[null/XYZ 36.1346 362.507 null]>>/section*.356<</Rect[291.695 1147.3 299.997 1055.98]/D[null/XYZ 36.1346 592.808 null]>>/section*.357<</Rect[291.695 1691.3 299.997 1599.98]/D[null/XYZ 36.1346 527.283 null]>>/section*.358<</Rect[291.695 3287.3 299.997 3195.98]/D[null/XYZ 36.1346 335.045 null]>>/section*.359<</Rect[291.695 3812.3 299.997 3720.98]/D[null/XYZ 36.1346 271.809 null]>>/page.780<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.781<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.782<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.783<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.784<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.785<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.786<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.480<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.787<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.481<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.788<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.482<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.789<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.483<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.484<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.485<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.486<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.660<</Rect[291.695 2533.3 299.997 2441.97]/D[null/XYZ 36.1346 425.864 null]>>/page.180<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.487<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.661<</Rect[291.695 3358.3 299.997 3266.97]/D[null/XYZ 36.1346 326.493 null]>>/page.181<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.488<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.662<</Rect[291.695 1545.3 299.997 1453.98]/D[null/XYZ 36.1346 544.869 null]>>/page.182<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.489<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.663<</Rect[291.695 2071.3 299.997 1979.98]/D[null/XYZ 36.1346 481.512 null]>>/page.183<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.664<</Rect[291.695 2715.3 299.997 2623.98]/D[null/XYZ 36.1346 403.942 null]>>/subsection.3.13.10<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.184<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.665<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/subsection.3.13.11<</Rect[291.695 4544.3 299.997 4452.98]/D[null/XYZ 36.1346 183.639 null]>>/page.185<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.666<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/subsection.3.13.12<</Rect[291.695 2417.3 299.997 2325.98]/D[null/XYZ 36.1346 439.836 null]>>/page.186<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.360<</Rect[291.695 4357.3 299.997 4265.98]/D[null/XYZ 36.1346 206.163 null]>>/section*.667<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.187<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.361<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.668<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.188<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.362<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.669<</Rect[291.695 2301.3 299.997 2209.98]/D[null/XYZ 36.1346 453.808 null]>>/page.189<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.363<</Rect[291.695 2234.3 299.997 2142.98]/D[null/XYZ 36.1346 461.878 null]>>/section*.364<</Rect[291.695 3059.3 299.997 2967.98]/D[null/XYZ 36.1346 362.507 null]>>/section*.365<</Rect[291.695 4930.3 299.997 4838.98]/D[null/XYZ 36.1346 137.145 null]>>/section*.366<</Rect[291.695 671.3 299.997 579.976]/D[null/XYZ 36.1346 650.142 null]>>/section*.367<</Rect[291.695 2025.3 299.997 1933.98]/D[null/XYZ 36.1346 487.052 null]>>/section*.368<</Rect[291.695 2651.3 299.997 2559.98]/D[null/XYZ 36.1346 411.651 null]>>/section*.369<</Rect[291.695 3196.3 299.997 3104.98]/D[null/XYZ 36.1346 346.006 null]>>/page.790<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.791<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.792<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.793<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.794<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.795<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.796<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.490<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.797<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.491<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.798<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.492<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.799<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.493<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.494<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.495<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.496<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.670<</Rect[291.695 3894.3 299.997 3802.98]/D[null/XYZ 36.1346 261.931 null]>>/page.190<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.497<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.671<</Rect[291.695 2475.3 299.997 2383.98]/D[null/XYZ 36.1346 432.85 null]>>/page.191<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.498<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.672<</Rect[291.695 3100.3 299.997 3008.98]/D[null/XYZ 36.1346 357.569 null]>>/page.192<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.499<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.673<</Rect[291.695 3645.3 299.997 3553.98]/D[null/XYZ 36.1346 291.923 null]>>/page.193<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.674<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.194<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.675<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.195<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.676<</Rect[291.695 2035.3 299.997 1943.98]/D[null/XYZ 36.1346 485.848 null]>>/page.196<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.370<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.677<</Rect[291.695 3026.3 299.997 2934.98]/D[null/XYZ 36.1346 366.482 null]>>/page.197<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.371<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.678<</Rect[291.695 2872.3 299.997 2780.98]/D[null/XYZ 36.1346 385.032 null]>>/page.198<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.372<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/section*.679<</Rect[291.695 3517.3 299.997 3425.98]/D[null/XYZ 36.1346 307.341 null]>>/page.199<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.373<</Rect[291.695 3581.3 299.997 3489.98]/D[null/XYZ 36.1346 299.632 null]>>/section*.374<</Rect[291.695 4305.3 299.997 4213.98]/D[null/XYZ 36.1346 212.427 null]>>/section*.375<</Rect[291.695 4848.3 299.997 4756.98]/D[null/XYZ 36.1346 147.022 null]>>/section*.376<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.377<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.378<</Rect[291.695 1935.3 299.997 1843.98]/D[null/XYZ 36.1346 497.893 null]>>/section*.379<</Rect[291.695 3524.3 299.997 3432.98]/D[null/XYZ 36.1346 306.498 null]>>/section*.680<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.681<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/section*.682<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.683<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.684<</Rect[291.695 1869.3 299.997 1777.98]/D[null/XYZ 36.1346 505.843 null]>>/section*.685<</Rect[291.695 4303.3 299.997 4211.98]/D[null/XYZ 36.1346 212.668 null]>>/section*.686<</Rect[291.695 2109.3 299.997 2017.98]/D[null/XYZ 36.1346 476.935 null]>>/section*.380<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.687<</Rect[291.695 2834.3 299.997 2742.98]/D[null/XYZ 36.1346 389.608 null]>>/section*.381<</Rect[291.695 1180.3 299.997 1088.98]/D[null/XYZ 36.1346 588.833 null]>>/section*.688<</Rect[291.695 3459.3 299.997 3367.98]/D[null/XYZ 36.1346 314.327 null]>>/section*.382<</Rect[291.695 1725.3 299.997 1633.98]/D[null/XYZ 36.1346 523.187 null]>>/section*.689<</Rect[291.695 4004.3 299.997 3912.98]/D[null/XYZ 36.1346 248.682 null]>>/section*.383<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.384<</Rect[291.695 1239.3 299.997 1147.98]/D[null/XYZ 36.1346 581.726 null]>>/section*.2<</Rect[291.695 4229.3 299.997 4146.28]/D[null/XYZ 36.1346 220.581 null]>>/section*.385<</Rect[291.695 3088.3 299.997 2996.97]/D[null/XYZ 36.1346 359.014 null]>>/section*.3<</Rect[291.695 2723.3 299.997 2631.97]/D[null/XYZ 36.1346 402.979 null]>>/section*.386<</Rect[291.695 3389.3 299.997 3297.98]/D[null/XYZ 36.1346 322.759 null]>>/section*.4<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.387<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.5<</Rect[291.695 2779.3 299.997 2687.98]/D[null/XYZ 36.1346 396.233 null]>>/section*.388<</Rect[291.695 1295.3 299.997 1203.98]/D[null/XYZ 36.1346 574.981 null]>>/section*.6<</Rect[291.695 3594.3 299.997 3502.98]/D[null/XYZ 36.1346 298.066 null]>>/section*.389<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.7<</Rect[291.695 4296.3 299.997 4204.98]/D[null/XYZ 36.1346 213.511 null]>>/section*.8<</Rect[291.695 1328.3 299.997 1236.97]/D[null/XYZ 36.1346 571.006 null]>>/section*.9<</Rect[291.695 2136.3 299.997 2044.98]/D[null/XYZ 36.1346 473.683 null]>>/section*.690<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.691<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.692<</Rect[291.695 2068.3 299.997 1976.97]/D[null/XYZ 36.1346 481.873 null]>>/section*.693<</Rect[291.695 2791.3 299.997 2699.98]/D[null/XYZ 36.1346 394.788 null]>>/section*.694<</Rect[291.695 3272.3 299.997 3180.98]/D[null/XYZ 36.1346 336.852 null]>>/section*.695<</Rect[291.695 3897.3 299.997 3805.98]/D[null/XYZ 36.1346 261.57 null]>>/section*.696<</Rect[291.695 4442.3 299.997 4350.98]/D[null/XYZ 36.1346 195.925 null]>>/section*.390<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/section*.697<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/section*.391<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.698<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.392<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.699<</Rect[291.695 2135.3 299.997 2043.98]/D[null/XYZ 36.1346 473.803 null]>>/section*.393<</Rect[291.695 2333.3 299.997 2241.97]/D[null/XYZ 36.1346 449.954 null]>>/section*.394<</Rect[291.695 1164.3 299.997 1072.98]/D[null/XYZ 36.1346 590.76 null]>>/section*.395<</Rect[291.695 3139.3 299.997 3047.98]/D[null/XYZ 36.1346 352.871 null]>>/section*.396<</Rect[291.695 3783.3 299.997 3691.98]/D[null/XYZ 36.1346 275.302 null]>>/section*.397<</Rect[291.695 1568.3 299.997 1476.97]/D[null/XYZ 36.1346 542.098 null]>>/section*.398<</Rect[291.695 2113.3 299.997 2021.97]/D[null/XYZ 36.1346 476.453 null]>>/section*.399<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.10<</Rect[291.695 2746.3 299.997 2654.98]/D[null/XYZ 36.1346 400.208 null]>>/section*.11<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.12<</Rect[291.695 3193.3 299.997 3101.97]/D[null/XYZ 36.1346 346.367 null]>>/section*.13<</Rect[291.695 1738.3 299.997 1646.97]/D[null/XYZ 36.1346 521.622 null]>>/section*.14<</Rect[291.695 3869.3 299.997 3777.98]/D[null/XYZ 36.1346 264.943 null]>>/section*.15<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.16<</Rect[291.695 2661.3 299.997 2569.98]/D[null/XYZ 36.1346 410.446 null]>>/section*.17<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.18<</Rect[291.695 4067.3 299.997 3975.98]/D[null/XYZ 36.1346 241.094 null]>>/section*.19<</Rect[291.695 2034.3 299.997 1942.98]/D[null/XYZ 36.1346 485.968 null]>>/section*.20<</Rect[291.695 4758.3 299.997 4666.98]/D[null/XYZ 36.1346 157.863 null]>>/section*.21<</Rect[291.695 3116.3 299.997 3024.98]/D[null/XYZ 36.1346 355.642 null]>>/section*.22<</Rect[291.695 4513.3 299.997 4421.98]/D[null/XYZ 36.1346 187.373 null]>>/section*.23<</Rect[291.695 1486.3 299.997 1394.98]/D[null/XYZ 36.1346 551.975 null]>>/section*.24<</Rect[291.695 4444.3 299.997 4352.98]/D[null/XYZ 36.1346 195.684 null]>>/section*.25<</Rect[291.695 2985.3 299.997 2893.98]/D[null/XYZ 36.1346 371.421 null]>>/section*.26<</Rect[291.695 1140.3 299.997 1048.98]/D[null/XYZ 36.1346 593.651 null]>>/section*.27<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.28<</Rect[291.695 3045.3 299.997 2953.98]/D[null/XYZ 36.1346 364.194 null]>>/section*.29<</Rect[291.695 1277.3 299.997 1185.98]/D[null/XYZ 36.1346 577.149 null]>>/page.ii<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.30<</Rect[291.695 2804.3 299.997 2712.98]/D[null/XYZ 36.1346 393.222 null]>>/section*.31<</Rect[291.695 2672.3 299.997 2580.98]/D[null/XYZ 36.1346 409.122 null]>>/section*.32<</Rect[291.695 3108.3 299.997 3016.97]/D[null/XYZ 36.1346 356.605 null]>>/figure.4.1<</Rect[1784.7 1547.3 1801.3 1530.7]/D[null/XYZ 215.967 534.628 null]>>/section*.33<</Rect[291.695 3715.3 299.997 3623.98]/D[null/XYZ 36.1346 283.492 null]>>/figure.4.2<</Rect[1254.7 3382.3 1271.3 3365.7]/D[null/XYZ 152.128 313.602 null]>>/section*.34<</Rect[291.695 3747.3 299.997 3655.98]/D[null/XYZ 36.1346 279.638 null]>>/subsection.2.9.1<</Rect[291.695 2001.3 299.997 1909.98]/D[null/XYZ 36.1346 489.943 null]>>/section*.35<</Rect[291.695 1323.3 299.997 1231.97]/D[null/XYZ 36.1346 571.609 null]>>/subsection.2.9.2<</Rect[291.695 4072.3 299.997 3980.98]/D[null/XYZ 36.1346 240.492 null]>>/section*.36<</Rect[291.695 2808.3 299.997 2716.97]/D[null/XYZ 36.1346 392.74 null]>>/subsection.2.9.3<</Rect[291.695 2266.3 299.997 2174.98]/D[null/XYZ 36.1346 458.024 null]>>/section*.37<</Rect[291.695 3811.3 299.997 3719.98]/D[null/XYZ 36.1346 271.929 null]>>/subsection.2.9.4<</Rect[291.695 1221.3 299.997 1129.98]/D[null/XYZ 36.1346 583.894 null]>>/section*.38<</Rect[291.695 3038.3 299.997 2946.97]/D[null/XYZ 36.1346 365.037 null]>>/section*.39<</Rect[291.695 2580.3 299.997 2488.98]/D[null/XYZ 36.1346 420.203 null]>>/page.iv<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.ix<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.2.6.1<</Rect[291.695 3060.3 299.997 2968.98]/D[null/XYZ 36.1346 362.387 null]>>/subsection.2.6.2<</Rect[291.695 1321.3 299.997 1229.98]/D[null/XYZ 36.1346 571.849 null]>>/subsection.2.6.3<</Rect[291.695 3603.3 299.997 3511.98]/D[null/XYZ 36.1346 296.983 null]>>/subsection.2.6.4<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.2.6.5<</Rect[291.695 3354.3 299.997 3262.98]/D[null/XYZ 36.1346 326.974 null]>>/subsection.2.6.6<</Rect[291.695 3260.3 299.997 3168.98]/D[null/XYZ 36.1346 338.297 null]>>/subsection.2.6.7<</Rect[291.695 4227.3 299.997 4135.98]/D[null/XYZ 36.1346 221.822 null]>>/subsection.2.3.1<</Rect[291.695 1089.3 299.997 997.977]/D[null/XYZ 36.1346 599.794 null]>>/subsection.5.4.1<</Rect[291.695 1765.3 299.997 1673.98]/D[null/XYZ 36.1346 518.37 null]>>/section*.40<</Rect[291.695 3265.3 299.997 3173.98]/D[null/XYZ 36.1346 337.695 null]>>/subsection.5.4.2<</Rect[291.695 4552.3 299.997 4460.98]/D[null/XYZ 36.1346 182.676 null]>>/section*.41<</Rect[291.695 2107.3 299.997 2015.98]/D[null/XYZ 36.1346 477.176 null]>>/subsection.5.4.3<</Rect[291.695 2243.3 299.997 2151.97]/D[null/XYZ 36.1346 460.795 null]>>/section*.42<</Rect[291.695 656.3 299.997 564.976]/D[null/XYZ 36.1346 651.949 null]>>/section*.43<</Rect[291.695 4454.3 299.997 4362.98]/D[null/XYZ 36.1346 194.479 null]>>/section*.44<</Rect[291.695 1144.3 299.997 1052.98]/D[null/XYZ 36.1346 593.169 null]>>/section*.45<</Rect[291.695 2152.3 299.997 2060.98]/D[null/XYZ 36.1346 471.755 null]>>/section*.46<</Rect[291.695 1144.3 299.997 1052.98]/D[null/XYZ 36.1346 593.169 null]>>/section*.47<</Rect[291.695 2081.3 299.997 1989.98]/D[null/XYZ 36.1346 480.307 null]>>/section*.48<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.49<</Rect[291.695 1123.3 299.997 1031.97]/D[null/XYZ 36.1346 595.699 null]>>/section.2.10<</Rect[291.695 4501.3 299.997 4409.98]/D[null/XYZ 36.1346 188.818 null]>>/section.2.11<</Rect[291.695 3190.3 299.997 3098.98]/D[null/XYZ 36.1346 346.728 null]>>/section.2.12<</Rect[291.695 1928.3 299.997 1836.97]/D[null/XYZ 36.1346 498.736 null]>>/section.2.13<</Rect[291.695 1397.3 299.997 1305.98]/D[null/XYZ 36.1346 562.695 null]>>/section.2.14<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.2.15<</Rect[291.695 2726.3 299.997 2634.98]/D[null/XYZ 36.1346 402.617 null]>>/page.xvii<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.50<</Rect[291.695 4845.3 299.997 4753.98]/D[null/XYZ 36.1346 147.383 null]>>/section*.51<</Rect[291.695 1340.3 299.997 1248.98]/D[null/XYZ 36.1346 569.561 null]>>/section*.52<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.53<</Rect[291.695 1477.3 299.997 1385.98]/D[null/XYZ 36.1346 553.059 null]>>/section*.54<</Rect[291.695 3913.3 299.997 3821.98]/D[null/XYZ 36.1346 259.643 null]>>/section*.55<</Rect[291.695 4101.3 299.997 4009.98]/D[null/XYZ 36.1346 236.998 null]>>/section*.56<</Rect[291.695 2058.3 299.997 1966.97]/D[null/XYZ 36.1346 483.078 null]>>/section*.57<</Rect[291.695 4257.3 299.997 4165.98]/D[null/XYZ 36.1346 218.208 null]>>/section*.58<</Rect[291.695 2014.3 299.997 1922.98]/D[null/XYZ 36.1346 488.377 null]>>/section*.59<</Rect[291.695 3232.3 299.997 3140.98]/D[null/XYZ 36.1346 341.669 null]>>/table.5.1<</Rect[1238.7 2412.3 1255.3 2395.7]/D[null/XYZ 150.201 430.439 null]>>/table.2.1<</Rect[1551.69 1101.3 1568.3 1084.7]/D[null/XYZ 187.902 588.348 null]>>/table.2.2<</Rect[1249.7 1360.3 1266.3 1343.7]/D[null/XYZ 151.526 557.152 null]>>/section*.60<</Rect[291.695 4114.3 299.997 4022.98]/D[null/XYZ 36.1346 235.432 null]>>/section*.61<</Rect[291.695 4682.3 299.997 4590.98]/D[null/XYZ 36.1346 167.017 null]>>/section*.62<</Rect[291.695 1859.3 299.997 1767.98]/D[null/XYZ 36.1346 507.047 null]>>/section*.63<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.64<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.65<</Rect[291.695 1277.3 299.997 1185.98]/D[null/XYZ 36.1346 577.149 null]>>/section*.66<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.67<</Rect[291.695 2828.3 299.997 2736.97]/D[null/XYZ 36.1346 390.331 null]>>/section*.68<</Rect[291.695 3175.3 299.997 3083.98]/D[null/XYZ 36.1346 348.535 null]>>/section*.69<</Rect[291.695 1542.3 299.997 1450.98]/D[null/XYZ 36.1346 545.23 null]>>/subsection.2.13.1<</Rect[291.695 2651.3 299.997 2559.98]/D[null/XYZ 36.1346 411.651 null]>>/subsection.2.13.2<</Rect[291.695 4239.3 299.997 4147.98]/D[null/XYZ 36.1346 220.376 null]>>/section*.70<</Rect[291.695 3244.3 299.997 3152.98]/D[null/XYZ 36.1346 340.224 null]>>/subsection.2.13.3<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section*.71<</Rect[291.695 1142.3 299.997 1050.98]/D[null/XYZ 36.1346 593.41 null]>>/subsection.2.13.4<</Rect[291.695 1439.3 299.997 1347.98]/D[null/XYZ 36.1346 557.636 null]>>/section*.72<</Rect[291.695 4845.3 299.997 4753.98]/D[null/XYZ 36.1346 147.383 null]>>/subsection.2.13.5<</Rect[291.695 2845.3 299.997 2753.98]/D[null/XYZ 36.1346 388.284 null]>>/section*.73<</Rect[291.695 2324.3 299.997 2232.98]/D[null/XYZ 36.1346 451.038 null]>>/section*.74<</Rect[291.695 1227.3 299.997 1135.98]/D[null/XYZ 36.1346 583.172 null]>>/section*.75<</Rect[291.695 2671.3 299.997 2579.98]/D[null/XYZ 36.1346 409.242 null]>>/subsection.2.10.1<</Rect[291.695 1587.3 299.997 1495.98]/D[null/XYZ 36.1346 539.81 null]>>/section*.76<</Rect[291.695 1126.3 299.997 1034.98]/D[null/XYZ 36.1346 595.337 null]>>/subsection.2.10.2<</Rect[291.695 1288.3 299.997 1196.97]/D[null/XYZ 36.1346 575.824 null]>>/section*.77<</Rect[291.695 1573.3 299.997 1481.97]/D[null/XYZ 36.1346 541.496 null]>>/subsection.2.10.3<</Rect[291.695 2114.3 299.997 2022.98]/D[null/XYZ 36.1346 476.332 null]>>/section*.78<</Rect[291.695 2039.3 299.997 1947.98]/D[null/XYZ 36.1346 485.366 null]>>/subsection.2.10.4<</Rect[291.695 901.3 299.997 809.976]/D[null/XYZ 36.1346 622.438 null]>>/section*.79<</Rect[291.695 2941.3 299.997 2849.98]/D[null/XYZ 36.1346 376.72 null]>>/subsection.2.10.5<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.2.10.6<</Rect[291.695 4053.3 299.997 3961.98]/D[null/XYZ 36.1346 242.78 null]>>/subsection.2.10.7<</Rect[291.695 4086.3 299.997 3994.98]/D[null/XYZ 36.1346 238.805 null]>>/subsection.2.10.8<</Rect[291.695 3641.3 299.997 3549.98]/D[null/XYZ 36.1346 292.405 null]>>/subsection.2.10.9<</Rect[291.695 3237.3 299.997 3145.98]/D[null/XYZ 36.1346 341.067 null]>>/section*.80<</Rect[291.695 3728.3 299.997 3636.98]/D[null/XYZ 36.1346 281.926 null]>>/section*.81<</Rect[291.695 4830.3 299.997 4738.98]/D[null/XYZ 36.1346 149.19 null]>>/section*.82<</Rect[291.695 945.301 299.997 853.977]/D[null/XYZ 36.1346 617.138 null]>>/section*.83<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.84<</Rect[291.695 4712.3 299.997 4620.98]/D[null/XYZ 36.1346 163.404 null]>>/section*.85<</Rect[291.695 2666.3 299.997 2574.98]/D[null/XYZ 36.1346 409.844 null]>>/section*.86<</Rect[291.695 2771.3 299.997 2679.98]/D[null/XYZ 36.1346 397.197 null]>>/section*.87<</Rect[291.695 4845.3 299.997 4753.98]/D[null/XYZ 36.1346 147.383 null]>>/section*.88<</Rect[291.695 1410.3 299.997 1318.98]/D[null/XYZ 36.1346 561.129 null]>>/section*.89<</Rect[291.695 1551.3 299.997 1459.98]/D[null/XYZ 36.1346 544.146 null]>>/section*.90<</Rect[291.695 2955.3 299.997 2863.98]/D[null/XYZ 36.1346 375.034 null]>>/section*.91<</Rect[291.695 1409.3 299.997 1317.98]/D[null/XYZ 36.1346 561.25 null]>>/section*.92<</Rect[291.695 3965.3 299.997 3873.98]/D[null/XYZ 36.1346 253.379 null]>>/section*.93<</Rect[291.695 1808.3 299.997 1716.97]/D[null/XYZ 36.1346 513.19 null]>>/section*.94<</Rect[291.695 4170.3 299.997 4078.98]/D[null/XYZ 36.1346 228.687 null]>>/section*.95<</Rect[291.695 4687.3 299.997 4595.98]/D[null/XYZ 36.1346 166.415 null]>>/section*.96<</Rect[291.695 1776.3 299.997 1684.98]/D[null/XYZ 36.1346 517.045 null]>>/section*.97<</Rect[291.695 3718.3 299.997 3626.98]/D[null/XYZ 36.1346 283.131 null]>>/section*.98<</Rect[291.695 4332.3 299.997 4240.98]/D[null/XYZ 36.1346 209.175 null]>>/section*.99<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/Item.200<</Rect[291.695 1291.3 299.997 1199.98]/D[null/XYZ 36.1346 575.463 null]>>/Item.201<</Rect[291.695 1881.3 299.997 1789.98]/D[null/XYZ 36.1346 504.397 null]>>/Item.202<</Rect[291.695 3496.3 299.997 3404.98]/D[null/XYZ 36.1346 309.871 null]>>/Item.203<</Rect[291.695 4750.3 299.997 4658.98]/D[null/XYZ 36.1346 158.826 null]>>/Item.204<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.205<</Rect[291.695 735.301 299.997 643.977]/D[null/XYZ 36.1346 642.433 null]>>/Item.206<</Rect[291.695 4630.3 299.997 4538.98]/D[null/XYZ 36.1346 173.28 null]>>/Item.207<</Rect[291.695 835.301 299.997 743.977]/D[null/XYZ 36.1346 630.388 null]>>/page.xii<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.208<</Rect[291.695 2057.3 299.997 1965.98]/D[null/XYZ 36.1346 483.198 null]>>/Item.209<</Rect[291.695 3401.3 299.997 3309.98]/D[null/XYZ 36.1346 321.313 null]>>/page.xiv<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.210<</Rect[291.695 3535.3 299.997 3443.98]/D[null/XYZ 36.1346 305.173 null]>>/Item.211<</Rect[291.695 3767.3 299.997 3675.98]/D[null/XYZ 36.1346 277.229 null]>>/Item.212<</Rect[291.695 3900.3 299.997 3808.98]/D[null/XYZ 36.1346 261.209 null]>>/Item.213<</Rect[291.695 4231.3 299.997 4139.98]/D[null/XYZ 36.1346 221.34 null]>>/Item.214<</Rect[291.695 4365.3 299.997 4273.98]/D[null/XYZ 36.1346 205.199 null]>>/Item.215<</Rect[291.695 4697.3 299.997 4605.98]/D[null/XYZ 36.1346 165.21 null]>>/Item.216<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.217<</Rect[291.695 702.3 299.997 610.975]/D[null/XYZ 36.1346 646.408 null]>>/Item.218<</Rect[291.695 1548.3 299.997 1456.97]/D[null/XYZ 36.1346 544.507 null]>>/Item.219<</Rect[291.695 1781.3 299.997 1689.98]/D[null/XYZ 36.1346 516.442 null]>>/page.iii<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.220<</Rect[291.695 2196.3 299.997 2104.98]/D[null/XYZ 36.1346 466.456 null]>>/Item.221<</Rect[291.695 3596.3 299.997 3504.98]/D[null/XYZ 36.1346 297.826 null]>>/Item.222<</Rect[291.695 3762.3 299.997 3670.98]/D[null/XYZ 36.1346 277.831 null]>>/Item.223<</Rect[291.695 3911.3 299.997 3819.98]/D[null/XYZ 36.1346 259.884 null]>>/Item.224<</Rect[291.695 4077.3 299.997 3985.98]/D[null/XYZ 36.1346 239.889 null]>>/Item.225<</Rect[291.695 2300.3 299.997 2208.98]/D[null/XYZ 36.1346 453.929 null]>>/Item.226<</Rect[291.695 2462.3 299.997 2370.98]/D[null/XYZ 36.1346 434.416 null]>>/Item.227<</Rect[291.695 2656.3 299.997 2564.98]/D[null/XYZ 36.1346 411.049 null]>>/Item.228<</Rect[291.695 2839.3 299.997 2747.98]/D[null/XYZ 36.1346 389.006 null]>>/Item.229<</Rect[291.695 3005.3 299.997 2913.98]/D[null/XYZ 36.1346 369.012 null]>>/Item.230<</Rect[291.695 3171.3 299.997 3079.98]/D[null/XYZ 36.1346 349.017 null]>>/Item.231<</Rect[291.695 3337.3 299.997 3245.98]/D[null/XYZ 36.1346 329.022 null]>>/Item.232<</Rect[291.695 3503.3 299.997 3411.98]/D[null/XYZ 36.1346 309.028 null]>>/Item.233<</Rect[291.695 3669.3 299.997 3577.98]/D[null/XYZ 36.1346 289.033 null]>>/Item.234<</Rect[291.695 3835.3 299.997 3743.98]/D[null/XYZ 36.1346 269.038 null]>>/Item.235<</Rect[291.695 4001.3 299.997 3909.98]/D[null/XYZ 36.1346 249.043 null]>>/Item.236<</Rect[291.695 4167.3 299.997 4075.98]/D[null/XYZ 36.1346 229.049 null]>>/Item.237<</Rect[291.695 4333.3 299.997 4241.98]/D[null/XYZ 36.1346 209.054 null]>>/Item.238<</Rect[291.695 4499.3 299.997 4407.98]/D[null/XYZ 36.1346 189.059 null]>>/Item.239<</Rect[291.695 1532.3 299.997 1440.98]/D[null/XYZ 36.1346 546.435 null]>>/Item.240<</Rect[291.695 3316.3 299.997 3224.98]/D[null/XYZ 36.1346 331.552 null]>>/Item.241<</Rect[291.695 3580.3 299.997 3488.98]/D[null/XYZ 36.1346 299.753 null]>>/Item.242<</Rect[291.695 3844.3 299.997 3752.98]/D[null/XYZ 36.1346 267.954 null]>>/Item.243<</Rect[291.695 4436.3 299.997 4344.98]/D[null/XYZ 36.1346 196.648 null]>>/Item.244<</Rect[291.695 793.299 299.997 701.975]/D[null/XYZ 36.1346 635.447 null]>>/Item.245<</Rect[291.695 1072.3 299.997 980.975]/D[null/XYZ 36.1346 601.841 null]>>/Item.246<</Rect[291.695 1434.3 299.997 1342.98]/D[null/XYZ 36.1346 558.238 null]>>/Item.247<</Rect[291.695 2084.3 299.997 1992.98]/D[null/XYZ 36.1346 479.946 null]>>/Item.248<</Rect[291.695 2230.3 299.997 2138.98]/D[null/XYZ 36.1346 462.36 null]>>/Item.249<</Rect[291.695 2375.3 299.997 2283.98]/D[null/XYZ 36.1346 444.895 null]>>/subsection.4.6.1<</Rect[291.695 2093.3 299.997 2001.97]/D[null/XYZ 36.1346 478.862 null]>>/Item.250<</Rect[291.695 3606.3 299.997 3514.98]/D[null/XYZ 36.1346 296.621 null]>>/subsection.4.6.2<</Rect[291.695 2714.3 299.997 2622.98]/D[null/XYZ 36.1346 404.062 null]>>/Item.251<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.4.6.3<</Rect[291.695 4441.3 299.997 4349.98]/D[null/XYZ 36.1346 196.045 null]>>/Item.252<</Rect[291.695 635.301 299.997 543.977]/D[null/XYZ 36.1346 654.478 null]>>/subsection.4.6.4<</Rect[291.695 1315.3 299.997 1223.98]/D[null/XYZ 36.1346 572.572 null]>>/Item.253<</Rect[291.695 801.3 299.997 709.976]/D[null/XYZ 36.1346 634.483 null]>>/subsection.4.6.5<</Rect[291.695 2725.3 299.997 2633.98]/D[null/XYZ 36.1346 402.737 null]>>/Item.254<</Rect[291.695 4332.3 299.997 4240.98]/D[null/XYZ 36.1346 209.175 null]>>/subsection.4.6.6<</Rect[291.695 2984.3 299.997 2892.98]/D[null/XYZ 36.1346 371.541 null]>>/Item.255<</Rect[291.695 4686.3 299.997 4594.98]/D[null/XYZ 36.1346 166.535 null]>>/subsection.4.6.7<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.256<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/subsection.4.6.8<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/subsection.4.3.1<</Rect[291.695 3115.3 299.997 3023.98]/D[null/XYZ 36.1346 355.762 null]>>/Item.257<</Rect[291.695 801.3 299.997 709.976]/D[null/XYZ 36.1346 634.483 null]>>/subsection.4.6.9<</Rect[291.695 911.3 299.997 819.976]/D[null/XYZ 36.1346 621.234 null]>>/subsection.4.3.2<</Rect[291.695 4288.3 299.997 4196.98]/D[null/XYZ 36.1346 214.474 null]>>/Item.258<</Rect[291.695 1067.3 299.997 975.975]/D[null/XYZ 36.1346 602.444 null]>>/subsection.4.3.3<</Rect[291.695 1386.3 299.997 1294.98]/D[null/XYZ 36.1346 564.02 null]>>/Item.259<</Rect[291.695 4675.3 299.997 4583.98]/D[null/XYZ 36.1346 167.86 null]>>/subsection.4.3.4<</Rect[291.695 2438.3 299.997 2346.97]/D[null/XYZ 36.1346 437.307 null]>>/subsection.4.3.5<</Rect[291.695 4559.3 299.997 4467.98]/D[null/XYZ 36.1346 181.832 null]>>/chapter*.1<</Rect[291.695 1824.3 299.997 1732.98]/D[null/XYZ 36.1346 511.263 null]>>/Item.260<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.261<</Rect[291.695 1039.3 299.997 947.977]/D[null/XYZ 36.1346 605.816 null]>>/Item.262<</Rect[291.695 1325.3 299.997 1233.98]/D[null/XYZ 36.1346 571.367 null]>>/Item.263<</Rect[291.695 1711.3 299.997 1619.98]/D[null/XYZ 36.1346 524.874 null]>>/Item.264<</Rect[291.695 2131.3 299.997 2039.98]/D[null/XYZ 36.1346 474.285 null]>>/Item.265<</Rect[291.695 2298.3 299.997 2206.97]/D[null/XYZ 36.1346 454.17 null]>>/Item.266<</Rect[291.695 2464.3 299.997 2372.98]/D[null/XYZ 36.1346 434.175 null]>>/Item.267<</Rect[291.695 2630.3 299.997 2538.98]/D[null/XYZ 36.1346 414.18 null]>>/Item.268<</Rect[291.695 4595.3 299.997 4503.98]/D[null/XYZ 36.1346 177.496 null]>>/Item.269<</Rect[291.695 4761.3 299.997 4669.98]/D[null/XYZ 36.1346 157.501 null]>>/page.vi<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.270<</Rect[291.695 4927.3 299.997 4835.98]/D[null/XYZ 36.1346 137.507 null]>>/Item.271<</Rect[291.695 779.302 299.997 687.977]/D[null/XYZ 36.1346 637.133 null]>>/Item.272<</Rect[291.695 4285.3 299.997 4193.98]/D[null/XYZ 36.1346 214.835 null]>>/Item.273<</Rect[291.695 4451.3 299.997 4359.98]/D[null/XYZ 36.1346 194.841 null]>>/Item.274<</Rect[291.695 4700.3 299.997 4608.98]/D[null/XYZ 36.1346 164.849 null]>>/Item.275<</Rect[291.695 2635.3 299.997 2543.98]/D[null/XYZ 36.1346 413.578 null]>>/Item.276<</Rect[291.695 2798.3 299.997 2706.97]/D[null/XYZ 36.1346 393.945 null]>>/Item.277<</Rect[291.695 3060.3 299.997 2968.98]/D[null/XYZ 36.1346 362.387 null]>>/Item.278<</Rect[291.695 3222.3 299.997 3130.98]/D[null/XYZ 36.1346 342.874 null]>>/Item.279<</Rect[291.695 3548.3 299.997 3456.98]/D[null/XYZ 36.1346 303.607 null]>>/Item.280<</Rect[291.695 3709.3 299.997 3617.98]/D[null/XYZ 36.1346 284.215 null]>>/Item.281<</Rect[291.695 3971.3 299.997 3879.98]/D[null/XYZ 36.1346 252.657 null]>>/Item.282<</Rect[291.695 4551.3 299.997 4459.98]/D[null/XYZ 36.1346 182.796 null]>>/Item.283<</Rect[291.695 4719.3 299.997 4627.98]/D[null/XYZ 36.1346 162.56 null]>>/Item.284<</Rect[291.695 4981.3 299.997 4889.98]/D[null/XYZ 36.1346 131.002 null]>>/Item.285<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.286<</Rect[291.695 634.302 299.997 542.977]/D[null/XYZ 36.1346 654.598 null]>>/Item.287<</Rect[291.695 2765.3 299.997 2673.98]/D[null/XYZ 36.1346 397.919 null]>>/Item.288<</Rect[291.695 2930.3 299.997 2838.98]/D[null/XYZ 36.1346 378.045 null]>>/Item.289<</Rect[291.695 3091.3 299.997 2999.98]/D[null/XYZ 36.1346 358.653 null]>>/page.xi<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.xv<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.290<</Rect[291.695 3256.3 299.997 3164.98]/D[null/XYZ 36.1346 338.779 null]>>/Item.291<</Rect[291.695 3922.3 299.997 3830.98]/D[null/XYZ 36.1346 258.559 null]>>/Item.292<</Rect[291.695 4756.3 299.997 4664.98]/D[null/XYZ 36.1346 158.104 null]>>/Item.293<</Rect[291.695 1153.3 299.997 1061.97]/D[null/XYZ 36.1346 592.085 null]>>/Item.294<</Rect[291.695 1418.3 299.997 1326.97]/D[null/XYZ 36.1346 560.166 null]>>/Item.295<</Rect[291.695 1584.3 299.997 1492.98]/D[null/XYZ 36.1346 540.171 null]>>/Item.296<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/Item.297<</Rect[291.695 832.3 299.997 740.975]/D[null/XYZ 36.1346 630.75 null]>>/Item.298<</Rect[291.695 3660.3 299.997 3568.98]/D[null/XYZ 36.1346 290.117 null]>>/Item.299<</Rect[291.695 3809.3 299.997 3717.98]/D[null/XYZ 36.1346 272.17 null]>>/page.800<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.801<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.802<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.803<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.804<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.805<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.806<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.500<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.807<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.501<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.808<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.502<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.809<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.503<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.504<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.10<</Rect[291.695 3077.3 299.997 2985.98]/D[null/XYZ 36.1346 360.339 null]>>/page.505<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.11<</Rect[291.695 3304.3 299.997 3212.98]/D[null/XYZ 36.1346 332.997 null]>>/page.506<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.12<</Rect[291.695 3542.3 299.997 3450.98]/D[null/XYZ 36.1346 304.33 null]>>/page.507<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.200<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.13<</Rect[291.695 3874.3 299.997 3782.98]/D[null/XYZ 36.1346 264.34 null]>>/page.508<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.201<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.14<</Rect[291.695 4107.3 299.997 4015.98]/D[null/XYZ 36.1346 236.276 null]>>/page.509<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.202<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.15<</Rect[291.695 4334.3 299.997 4242.98]/D[null/XYZ 36.1346 208.933 null]>>/section.6.1<</Rect[291.695 3026.3 299.997 2934.98]/D[null/XYZ 36.1346 366.482 null]>>/page.203<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.16<</Rect[291.695 4555.3 299.997 4463.98]/D[null/XYZ 36.1346 182.314 null]>>/section.6.2<</Rect[291.695 1231.3 299.997 1139.98]/D[null/XYZ 36.1346 582.69 null]>>/page.204<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.17<</Rect[291.695 4799.3 299.997 4707.98]/D[null/XYZ 36.1346 152.924 null]>>/section.6.3<</Rect[291.695 1945.3 299.997 1853.98]/D[null/XYZ 36.1346 496.689 null]>>/page.205<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.18<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.6.4<</Rect[291.695 4337.3 299.997 4245.98]/D[null/XYZ 36.1346 208.572 null]>>/page.206<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.19<</Rect[291.695 899.302 299.997 807.977]/D[null/XYZ 36.1346 622.679 null]>>/page.207<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.208<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.209<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section.3.1<</Rect[291.695 2314.3 299.997 2222.98]/D[null/XYZ 36.1346 452.242 null]>>/section.3.2<</Rect[291.695 3706.3 299.997 3614.98]/D[null/XYZ 36.1346 284.576 null]>>/section.3.3<</Rect[291.695 2712.3 299.997 2620.98]/D[null/XYZ 36.1346 404.304 null]>>/section.3.4<</Rect[291.695 4132.3 299.997 4040.98]/D[null/XYZ 36.1346 233.265 null]>>/section.3.5<</Rect[291.695 932.3 299.997 840.975]/D[null/XYZ 36.1346 618.705 null]>>/section.3.6<</Rect[291.695 2048.3 299.997 1956.97]/D[null/XYZ 36.1346 484.282 null]>>/section.3.7<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.3.8<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section.3.9<</Rect[291.695 4428.3 299.997 4336.98]/D[null/XYZ 36.1346 197.611 null]>>/page.810<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.811<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.812<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.813<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.814<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.815<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.816<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.510<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.817<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.511<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.818<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.512<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.819<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.513<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.514<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.20<</Rect[291.695 1344.3 299.997 1252.98]/D[null/XYZ 36.1346 569.079 null]>>/page.515<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.21<</Rect[291.695 1573.3 299.997 1481.97]/D[null/XYZ 36.1346 541.496 null]>>/page.516<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.22<</Rect[291.695 1833.3 299.997 1741.97]/D[null/XYZ 36.1346 510.179 null]>>/page.517<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.210<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.23<</Rect[291.695 2085.3 299.997 1993.98]/D[null/XYZ 36.1346 479.826 null]>>/page.518<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.211<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.24<</Rect[291.695 2348.3 299.997 2256.97]/D[null/XYZ 36.1346 448.147 null]>>/page.519<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.212<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.25<</Rect[291.695 2705.3 299.997 2613.98]/D[null/XYZ 36.1346 405.147 null]>>/page.213<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.26<</Rect[291.695 2963.3 299.997 2871.97]/D[null/XYZ 36.1346 374.071 null]>>/page.214<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.27<</Rect[291.695 3215.3 299.997 3123.98]/D[null/XYZ 36.1346 343.717 null]>>/page.215<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.28<</Rect[291.695 3461.3 299.997 3369.98]/D[null/XYZ 36.1346 314.086 null]>>/page.216<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.29<</Rect[291.695 3730.3 299.997 3638.98]/D[null/XYZ 36.1346 281.685 null]>>/page.217<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.218<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.219<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.820<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.821<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.822<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.823<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.824<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.825<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.826<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.520<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.827<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.521<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.828<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.522<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.829<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.523<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.524<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.30<</Rect[291.695 3893.3 299.997 3801.98]/D[null/XYZ 36.1346 262.052 null]>>/page.525<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.31<</Rect[291.695 4251.3 299.997 4159.98]/D[null/XYZ 36.1346 218.931 null]>>/page.526<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.32<</Rect[291.695 4707.3 299.997 4615.98]/D[null/XYZ 36.1346 164.006 null]>>/section*.700<</Rect[291.695 3591.3 299.997 3499.98]/D[null/XYZ 36.1346 298.428 null]>>/page.527<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.220<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.33<</Rect[291.695 4965.3 299.997 4873.98]/D[null/XYZ 36.1346 132.93 null]>>/section*.701<</Rect[291.695 2475.3 299.997 2383.98]/D[null/XYZ 36.1346 432.85 null]>>/page.528<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.221<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.34<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section*.702<</Rect[291.695 3119.3 299.997 3027.98]/D[null/XYZ 36.1346 355.28 null]>>/page.529<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.222<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.35<</Rect[291.695 917.3 299.997 825.975]/D[null/XYZ 36.1346 620.511 null]>>/section*.703<</Rect[291.695 4722.3 299.997 4630.98]/D[null/XYZ 36.1346 162.199 null]>>/page.223<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.36<</Rect[291.695 1047.3 299.997 955.975]/D[null/XYZ 36.1346 604.853 null]>>/section*.704<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/page.224<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.37<</Rect[291.695 1278.3 299.997 1186.97]/D[null/XYZ 36.1346 577.029 null]>>/section*.705<</Rect[291.695 722.3 299.997 630.975]/D[null/XYZ 36.1346 643.999 null]>>/page.225<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.38<</Rect[291.695 3601.3 299.997 3509.98]/D[null/XYZ 36.1346 297.223 null]>>/section*.706<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.226<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.39<</Rect[291.695 4030.3 299.997 3938.98]/D[null/XYZ 36.1346 245.55 null]>>/section*.400<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.707<</Rect[291.695 2400.3 299.997 2308.98]/D[null/XYZ 36.1346 441.884 null]>>/page.227<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.401<</Rect[291.695 1935.3 299.997 1843.98]/D[null/XYZ 36.1346 497.893 null]>>/section*.708<</Rect[291.695 4786.3 299.997 4694.98]/D[null/XYZ 36.1346 154.49 null]>>/page.228<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.402<</Rect[291.695 4830.3 299.997 4738.98]/D[null/XYZ 36.1346 149.19 null]>>/section*.709<</Rect[291.695 3537.3 299.997 3445.98]/D[null/XYZ 36.1346 304.932 null]>>/page.229<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.403<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.404<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/section*.405<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.406<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.100<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.407<</Rect[291.695 2167.3 299.997 2075.98]/D[null/XYZ 36.1346 469.949 null]>>/section*.101<</Rect[291.695 4804.3 299.997 4712.98]/D[null/XYZ 36.1346 152.322 null]>>/section*.408<</Rect[291.695 965.301 299.997 873.977]/D[null/XYZ 36.1346 614.729 null]>>/section*.102<</Rect[291.695 1244.3 299.997 1152.98]/D[null/XYZ 36.1346 581.124 null]>>/section*.409<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.103<</Rect[291.695 2517.3 299.997 2425.98]/D[null/XYZ 36.1346 427.791 null]>>/page.xvi<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.104<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.105<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/page.830<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.106<</Rect[291.695 3401.3 299.997 3309.98]/D[null/XYZ 36.1346 321.313 null]>>/page.831<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.107<</Rect[291.695 3309.3 299.997 3217.98]/D[null/XYZ 36.1346 332.395 null]>>/page.832<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.108<</Rect[291.695 3299.3 299.997 3207.98]/D[null/XYZ 36.1346 333.599 null]>>/page.833<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.109<</Rect[291.695 1691.3 299.997 1599.98]/D[null/XYZ 36.1346 527.283 null]>>/page.834<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.835<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.836<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.530<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.837<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.531<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.838<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.532<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.839<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.533<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.534<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.40<</Rect[291.695 4339.3 299.997 4247.98]/D[null/XYZ 36.1346 208.331 null]>>/page.535<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.41<</Rect[291.695 4487.3 299.997 4395.98]/D[null/XYZ 36.1346 190.505 null]>>/page.536<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.42<</Rect[291.695 4717.3 299.997 4625.98]/D[null/XYZ 36.1346 162.801 null]>>/section*.710<</Rect[291.695 4480.3 299.997 4388.98]/D[null/XYZ 36.1346 191.348 null]>>/page.537<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.230<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.43<</Rect[291.695 2590.3 299.997 2498.98]/D[null/XYZ 36.1346 418.998 null]>>/section*.711<</Rect[291.695 1700.3 299.997 1608.98]/D[null/XYZ 36.1346 526.199 null]>>/page.538<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.231<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.44<</Rect[291.695 2920.3 299.997 2828.98]/D[null/XYZ 36.1346 379.25 null]>>/section*.712<</Rect[291.695 2325.3 299.997 2233.98]/D[null/XYZ 36.1346 450.918 null]>>/page.539<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.232<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.45<</Rect[291.695 3648.3 299.997 3556.98]/D[null/XYZ 36.1346 291.562 null]>>/section*.713<</Rect[291.695 2870.3 299.997 2778.98]/D[null/XYZ 36.1346 385.272 null]>>/page.233<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.46<</Rect[291.695 3879.3 299.997 3787.98]/D[null/XYZ 36.1346 263.738 null]>>/section*.714<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/page.234<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.47<</Rect[291.695 4659.3 299.997 4567.98]/D[null/XYZ 36.1346 169.787 null]>>/subsection.3.11.1<</Rect[291.695 4031.3 299.997 3939.98]/D[null/XYZ 36.1346 245.43 null]>>/section*.715<</Rect[291.695 1241.3 299.997 1149.98]/D[null/XYZ 36.1346 581.485 null]>>/page.235<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.48<</Rect[291.695 4792.3 299.997 4700.98]/D[null/XYZ 36.1346 153.768 null]>>/subsection.3.11.2<</Rect[291.695 3182.3 299.997 3090.98]/D[null/XYZ 36.1346 347.692 null]>>/section*.716<</Rect[291.695 1931.3 299.997 1839.98]/D[null/XYZ 36.1346 498.375 null]>>/page.236<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.49<</Rect[291.695 1211.3 299.997 1119.98]/D[null/XYZ 36.1346 585.099 null]>>/section*.410<</Rect[291.695 1298.3 299.997 1206.97]/D[null/XYZ 36.1346 574.62 null]>>/section*.717<</Rect[291.695 2655.3 299.997 2563.98]/D[null/XYZ 36.1346 411.169 null]>>/page.237<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.411<</Rect[291.695 1905.3 299.997 1813.98]/D[null/XYZ 36.1346 501.507 null]>>/section*.718<</Rect[291.695 4306.3 299.997 4214.98]/D[null/XYZ 36.1346 212.306 null]>>/page.238<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.412<</Rect[291.695 2450.3 299.997 2358.98]/D[null/XYZ 36.1346 435.861 null]>>/section*.719<</Rect[291.695 4929.3 299.997 4837.98]/D[null/XYZ 36.1346 137.266 null]>>/page.239<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.413<</Rect[291.695 721.3 299.997 629.976]/D[42 0 R/XYZ 36.1346 644.119 null]>>/section*.414<</Rect[291.695 1443.3 299.997 1351.97]/D[42 0 R/XYZ 36.1346 557.155 null]>>/section*.415<</Rect[291.695 2766.3 299.997 2674.98]/D[42 0 R/XYZ 36.1346 397.799 null]>>/section*.416<</Rect[291.695 3821.3 299.997 3729.98]/D[7 0 R/XYZ 36.1346 270.724 null]>>/section*.110<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.417<</Rect[291.695 1063.3 299.997 971.975]/D[13 0 R/XYZ 36.1346 602.926 null]>>/section*.111<</Rect[291.695 1810.3 299.997 1718.98]/D[null/XYZ 36.1346 512.949 null]>>/section*.418<</Rect[291.695 654.302 299.997 562.977]/D[19 0 R/XYZ 36.1346 652.189 null]>>/section*.112<</Rect[291.695 2032.3 299.997 1940.98]/D[null/XYZ 36.1346 486.21 null]>>/section*.419<</Rect[291.695 1279.3 299.997 1187.98]/D[19 0 R/XYZ 36.1346 576.908 null]>>/section*.113<</Rect[291.695 2254.3 299.997 2162.98]/D[null/XYZ 36.1346 459.469 null]>>/section*.114<</Rect[291.695 1208.3 299.997 1116.97]/D[null/XYZ 36.1346 585.46 null]>>/section*.115<</Rect[291.695 3650.3 299.997 3558.98]/D[null/XYZ 36.1346 291.321 null]>>/page.840<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.116<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/page.841<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.117<</Rect[291.695 2406.3 299.997 2314.98]/D[null/XYZ 36.1346 441.161 null]>>/page.842<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.118<</Rect[291.695 2506.3 299.997 2414.98]/D[null/XYZ 36.1346 429.116 null]>>/page.843<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.119<</Rect[291.695 1460.3 299.997 1368.98]/D[null/XYZ 36.1346 555.107 null]>>/page.844<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.845<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.846<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.540<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.847<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.541<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.848<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.542<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.849<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.543<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.544<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.50<</Rect[291.695 1340.3 299.997 1248.98]/D[null/XYZ 36.1346 569.561 null]>>/page.545<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.51<</Rect[291.695 1470.3 299.997 1378.98]/D[null/XYZ 36.1346 553.902 null]>>/page.546<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.52<</Rect[291.695 3903.3 299.997 3811.98]/D[null/XYZ 36.1346 260.848 null]>>/section*.720<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/page.547<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.240<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.53<</Rect[291.695 4085.3 299.997 3993.98]/D[null/XYZ 36.1346 238.925 null]>>/section*.721<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/page.548<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.241<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.54<</Rect[291.695 4549.3 299.997 4457.98]/D[null/XYZ 36.1346 183.037 null]>>/section*.722<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.549<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.242<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.55<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section*.723<</Rect[291.695 1935.3 299.997 1843.98]/D[null/XYZ 36.1346 497.893 null]>>/page.243<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.56<</Rect[291.695 718.299 299.997 626.975]/D[null/XYZ 36.1346 644.481 null]>>/section*.724<</Rect[291.695 2992.3 299.997 2900.98]/D[null/XYZ 36.1346 370.578 null]>>/page.244<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.57<</Rect[291.695 1006.3 299.997 914.976]/D[null/XYZ 36.1346 609.791 null]>>/section*.725<</Rect[291.695 1045.3 299.997 953.977]/D[null/XYZ 36.1346 605.094 null]>>/page.245<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.58<</Rect[291.695 1172.3 299.997 1080.98]/D[null/XYZ 36.1346 589.797 null]>>/section*.726<</Rect[291.695 1853.3 299.997 1761.97]/D[null/XYZ 36.1346 507.77 null]>>/page.246<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.59<</Rect[291.695 1354.3 299.997 1262.98]/D[null/XYZ 36.1346 567.874 null]>>/section*.420<</Rect[291.695 1825.3 299.997 1733.98]/D[19 0 R/XYZ 36.1346 511.143 null]>>/section*.727<</Rect[291.695 4730.3 299.997 4638.98]/D[null/XYZ 36.1346 161.235 null]>>/page.247<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.421<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.728<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.248<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.422<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.729<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/page.249<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.423<</Rect[291.695 2035.3 299.997 1943.98]/D[null/XYZ 36.1346 485.848 null]>>/section*.424<</Rect[291.695 4720.3 299.997 4628.98]/D[null/XYZ 36.1346 162.44 null]>>/section*.425<</Rect[291.695 2753.3 299.997 2661.97]/D[null/XYZ 36.1346 399.365 null]>>/section*.426<</Rect[291.695 4830.3 299.997 4738.98]/D[null/XYZ 36.1346 149.19 null]>>/section*.120<</Rect[291.695 641.3 299.997 549.976]/D[null/XYZ 36.1346 653.755 null]>>/section*.427<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.121<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.428<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/section*.122<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.429<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.123<</Rect[291.695 647.3 299.997 555.975]/D[null/XYZ 36.1346 653.033 null]>>/section*.124<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.125<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/page.850<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.126<</Rect[291.695 3612.3 299.997 3520.98]/D[null/XYZ 36.1346 295.899 null]>>/page.851<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.127<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/subsection.3.8.1<</Rect[291.695 3724.3 299.997 3632.98]/D[null/XYZ 36.1346 282.408 null]>>/page.852<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.128<</Rect[291.695 1427.3 299.997 1335.98]/D[null/XYZ 36.1346 559.082 null]>>/subsection.3.8.2<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.853<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.129<</Rect[291.695 4361.3 299.997 4269.98]/D[null/XYZ 36.1346 205.681 null]>>/subsection.3.8.3<</Rect[291.695 3029.3 299.997 2937.98]/D[null/XYZ 36.1346 366.121 null]>>/page.854<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.8.4<</Rect[291.695 2463.3 299.997 2371.97]/D[null/XYZ 36.1346 434.296 null]>>/page.855<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.856<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.550<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.857<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.551<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.858<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.552<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.5.1<</Rect[291.695 4508.3 299.997 4416.98]/D[null/XYZ 36.1346 187.975 null]>>/page.859<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.553<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.5.2<</Rect[291.695 816.3 299.997 724.976]/D[null/XYZ 36.1346 632.677 null]>>/page.554<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.5.3<</Rect[291.695 1450.3 299.997 1358.98]/D[null/XYZ 36.1346 556.311 null]>>/Item.60<</Rect[291.695 4979.3 299.997 4887.98]/D[null/XYZ 36.1346 131.243 null]>>/page.555<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.5.4<</Rect[291.695 1022.3 299.997 930.975]/D[null/XYZ 36.1346 607.864 null]>>/Item.61<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.556<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.5.5<</Rect[291.695 2982.3 299.997 2890.98]/D[null/XYZ 36.1346 371.782 null]>>/Item.62<</Rect[291.695 634.302 299.997 542.977]/D[null/XYZ 36.1346 654.598 null]>>/section*.730<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.557<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.5.6<</Rect[291.695 4508.3 299.997 4416.98]/D[null/XYZ 36.1346 187.975 null]>>/page.250<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.63<</Rect[291.695 2903.3 299.997 2811.97]/D[null/XYZ 36.1346 381.298 null]>>/section*.731<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.558<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.5.7<</Rect[291.695 2102.3 299.997 2010.98]/D[null/XYZ 36.1346 477.778 null]>>/page.251<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.64<</Rect[291.695 3263.3 299.997 3171.97]/D[null/XYZ 36.1346 337.936 null]>>/section*.732<</Rect[291.695 1935.3 299.997 1843.98]/D[null/XYZ 36.1346 497.893 null]>>/page.559<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.5.8<</Rect[291.695 920.301 299.997 828.977]/D[null/XYZ 36.1346 620.15 null]>>/page.252<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.2.1<</Rect[291.695 2769.3 299.997 2677.98]/D[null/XYZ 36.1346 397.438 null]>>/Item.65<</Rect[291.695 3916.3 299.997 3824.98]/D[null/XYZ 36.1346 259.282 null]>>/section*.733<</Rect[291.695 2927.3 299.997 2835.98]/D[null/XYZ 36.1346 378.407 null]>>/subsection.3.5.9<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/page.253<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.2.2<</Rect[291.695 2806.3 299.997 2714.98]/D[null/XYZ 36.1346 392.981 null]>>/Item.66<</Rect[291.695 2325.3 299.997 2233.98]/D[null/XYZ 36.1346 450.918 null]>>/section*.734<</Rect[291.695 3966.3 299.997 3874.98]/D[null/XYZ 36.1346 253.259 null]>>/page.254<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.2.3<</Rect[291.695 2601.3 299.997 2509.98]/D[null/XYZ 36.1346 417.673 null]>>/Item.67<</Rect[291.695 2491.3 299.997 2399.98]/D[null/XYZ 36.1346 430.923 null]>>/section*.735<</Rect[291.695 4492.3 299.997 4400.98]/D[null/XYZ 36.1346 189.903 null]>>/page.255<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.2.4<</Rect[291.695 1071.3 299.997 979.976]/D[null/XYZ 36.1346 601.962 null]>>/Item.68<</Rect[291.695 1483.3 299.997 1391.97]/D[null/XYZ 36.1346 552.337 null]>>/section*.736<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.256<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.2.5<</Rect[291.695 2998.3 299.997 2906.97]/D[null/XYZ 36.1346 369.855 null]>>/Item.69<</Rect[291.695 1610.3 299.997 1518.98]/D[null/XYZ 36.1346 537.039 null]>>/section*.430<</Rect[291.695 1343.3 299.997 1251.97]/D[null/XYZ 36.1346 569.2 null]>>/section*.737<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/page.257<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.2.6<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section*.431<</Rect[291.695 1869.3 299.997 1777.98]/D[null/XYZ 36.1346 505.843 null]>>/section*.738<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.258<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.2.7<</Rect[291.695 3382.3 299.997 3290.98]/D[null/XYZ 36.1346 323.602 null]>>/section*.432<</Rect[291.695 3059.3 299.997 2967.98]/D[null/XYZ 36.1346 362.507 null]>>/section*.739<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.259<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/subsection.3.2.8<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section*.433<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/subsection.3.2.9<</Rect[291.695 2864.3 299.997 2772.98]/D[null/XYZ 36.1346 385.995 null]>>/section*.434<</Rect[291.695 1965.3 299.997 1873.98]/D[null/XYZ 36.1346 494.28 null]>>/section*.435<</Rect[291.695 2804.3 299.997 2712.98]/D[null/XYZ 36.1346 393.222 null]>>/section*.436<</Rect[291.695 4041.3 299.997 3949.98]/D[null/XYZ 36.1346 244.225 null]>>/section*.130<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.437<</Rect[291.695 4582.3 299.997 4490.98]/D[null/XYZ 36.1346 179.062 null]>>/section*.131<</Rect[291.695 4123.3 299.997 4031.98]/D[null/XYZ 36.1346 234.349 null]>>/section*.438<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.132<</Rect[291.695 3120.3 299.997 3028.98]/D[null/XYZ 36.1346 355.16 null]>>/section*.439<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.133<</Rect[291.695 3458.3 299.997 3366.98]/D[null/XYZ 36.1346 314.448 null]>>/section*.134<</Rect[291.695 3052.3 299.997 2960.98]/D[null/XYZ 36.1346 363.351 null]>>/section*.135<</Rect[291.695 3085.3 299.997 2993.98]/D[null/XYZ 36.1346 359.376 null]>>/page.860<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.136<</Rect[291.695 2841.3 299.997 2749.98]/D[null/XYZ 36.1346 388.765 null]>>/page.861<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.137<</Rect[291.695 945.301 299.997 853.977]/D[null/XYZ 36.1346 617.138 null]>>/page.862<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.138<</Rect[291.695 3746.3 299.997 3654.98]/D[null/XYZ 36.1346 279.758 null]>>/page.863<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.139<</Rect[291.695 4015.3 299.997 3923.98]/D[null/XYZ 36.1346 247.357 null]>>/page.864<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.865<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.866<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.560<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.867<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.561<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.868<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.562<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.869<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.563<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.564<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.70<</Rect[291.695 1743.3 299.997 1651.97]/D[null/XYZ 36.1346 521.02 null]>>/page.565<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.71<</Rect[291.695 1876.3 299.997 1784.98]/D[null/XYZ 36.1346 505.0 null]>>/page.566<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.72<</Rect[291.695 2523.3 299.997 2431.97]/D[null/XYZ 36.1346 427.069 null]>>/section*.740<</Rect[291.695 1935.3 299.997 1843.98]/D[null/XYZ 36.1346 497.893 null]>>/page.567<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.260<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.73<</Rect[291.695 2697.3 299.997 2605.98]/D[null/XYZ 36.1346 406.11 null]>>/section*.741<</Rect[291.695 2727.3 299.997 2635.98]/D[null/XYZ 36.1346 402.497 null]>>/page.568<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.261<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.74<</Rect[291.695 2854.3 299.997 2762.98]/D[null/XYZ 36.1346 387.199 null]>>/section*.742<</Rect[291.695 3667.3 299.997 3575.98]/D[null/XYZ 36.1346 289.274 null]>>/page.569<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.262<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.75<</Rect[291.695 3109.3 299.997 3017.98]/D[null/XYZ 36.1346 356.485 null]>>/section*.743<</Rect[291.695 4492.3 299.997 4400.98]/D[null/XYZ 36.1346 189.903 null]>>/page.263<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.76<</Rect[291.695 4466.3 299.997 4374.98]/D[null/XYZ 36.1346 193.034 null]>>/section*.744<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.264<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.77<</Rect[291.695 4732.3 299.997 4640.98]/D[null/XYZ 36.1346 160.995 null]>>/section*.745<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/page.265<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.78<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section*.746<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/page.266<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.79<</Rect[291.695 3086.3 299.997 2994.98]/D[null/XYZ 36.1346 359.255 null]>>/section*.440<</Rect[291.695 2434.3 299.997 2342.98]/D[null/XYZ 36.1346 437.788 null]>>/section*.747<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.267<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.441<</Rect[291.695 2725.3 299.997 2633.98]/D[null/XYZ 36.1346 402.737 null]>>/section*.748<</Rect[291.695 2035.3 299.997 1943.98]/D[null/XYZ 36.1346 485.848 null]>>/page.268<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.442<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/section*.749<</Rect[291.695 2860.3 299.997 2768.98]/D[null/XYZ 36.1346 386.477 null]>>/page.269<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.443<</Rect[291.695 2892.3 299.997 2800.98]/D[null/XYZ 36.1346 382.622 null]>>/section*.444<</Rect[291.695 1264.3 299.997 1172.98]/D[null/XYZ 36.1346 578.715 null]>>/section*.445<</Rect[291.695 2620.3 299.997 2528.98]/D[null/XYZ 36.1346 415.385 null]>>/section*.446<</Rect[291.695 2773.3 299.997 2681.97]/D[null/XYZ 36.1346 396.956 null]>>/section*.140<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.447<</Rect[291.695 4041.3 299.997 3949.98]/D[null/XYZ 36.1346 244.225 null]>>/section*.141<</Rect[291.695 2041.3 299.997 1949.98]/D[null/XYZ 36.1346 485.125 null]>>/section*.448<</Rect[291.695 4582.3 299.997 4490.98]/D[null/XYZ 36.1346 179.062 null]>>/section*.142<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.449<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.143<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.144<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/section*.145<</Rect[291.695 2008.3 299.997 1916.97]/D[null/XYZ 36.1346 489.1 null]>>/page.870<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.146<</Rect[291.695 3115.3 299.997 3023.98]/D[null/XYZ 36.1346 355.762 null]>>/page.871<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.147<</Rect[291.695 4480.3 299.997 4388.98]/D[null/XYZ 36.1346 191.348 null]>>/page.872<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.148<</Rect[291.695 2904.3 299.997 2812.98]/D[null/XYZ 36.1346 381.177 null]>>/page.873<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.149<</Rect[291.695 1509.3 299.997 1417.98]/D[null/XYZ 36.1346 549.205 null]>>/page.874<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.875<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.876<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.570<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.877<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.571<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.878<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.572<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.879<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.573<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.574<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.80<</Rect[291.695 3964.3 299.997 3872.98]/D[null/XYZ 36.1346 253.5 null]>>/page.575<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.81<</Rect[291.695 1766.3 299.997 1674.98]/D[null/XYZ 36.1346 518.249 null]>>/page.576<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.82<</Rect[291.695 2048.3 299.997 1956.97]/D[null/XYZ 36.1346 484.282 null]>>/section*.750<</Rect[291.695 1711.3 299.997 1619.98]/D[null/XYZ 36.1346 524.874 null]>>/page.577<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.270<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.83<</Rect[291.695 3442.3 299.997 3350.98]/D[null/XYZ 36.1346 316.375 null]>>/section*.751<</Rect[291.695 2237.3 299.997 2145.98]/D[null/XYZ 36.1346 461.517 null]>>/page.578<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.271<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.84<</Rect[291.695 3607.3 299.997 3515.98]/D[null/XYZ 36.1346 296.501 null]>>/section*.752<</Rect[291.695 2763.3 299.997 2671.97]/D[null/XYZ 36.1346 398.161 null]>>/page.579<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.272<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.85<</Rect[291.695 3773.3 299.997 3681.98]/D[null/XYZ 36.1346 276.506 null]>>/section*.753<</Rect[291.695 3308.3 299.997 3216.97]/D[null/XYZ 36.1346 332.515 null]>>/page.273<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.86<</Rect[291.695 3921.3 299.997 3829.98]/D[null/XYZ 36.1346 258.679 null]>>/section*.754<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.274<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.87<</Rect[291.695 4103.3 299.997 4011.98]/D[null/XYZ 36.1346 236.758 null]>>/section*.755<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.275<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.88<</Rect[291.695 4269.3 299.997 4177.98]/D[null/XYZ 36.1346 216.763 null]>>/section*.756<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/page.276<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.89<</Rect[291.695 4434.3 299.997 4342.98]/D[null/XYZ 36.1346 196.888 null]>>/section*.450<</Rect[291.695 1242.3 299.997 1150.98]/D[null/XYZ 36.1346 581.365 null]>>/section*.757<</Rect[291.695 2594.3 299.997 2502.98]/D[null/XYZ 36.1346 418.516 null]>>/page.277<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.451<</Rect[291.695 2132.3 299.997 2040.98]/D[null/XYZ 36.1346 474.164 null]>>/section*.758<</Rect[291.695 4364.3 299.997 4272.98]/D[null/XYZ 36.1346 205.32 null]>>/page.278<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.452<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/section*.759<</Rect[291.695 4890.3 299.997 4798.98]/D[null/XYZ 36.1346 141.963 null]>>/page.279<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.453<</Rect[291.695 4453.3 299.997 4361.98]/D[null/XYZ 36.1346 194.6 null]>>/section*.454<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.455<</Rect[291.695 1279.3 299.997 1187.98]/D[null/XYZ 36.1346 576.908 null]>>/section*.456<</Rect[291.695 1825.3 299.997 1733.98]/D[null/XYZ 36.1346 511.143 null]>>/section*.150<</Rect[291.695 3580.3 299.997 3488.98]/D[null/XYZ 36.1346 299.753 null]>>/section*.457<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/section*.151<</Rect[291.695 2321.3 299.997 2229.98]/D[null/XYZ 36.1346 451.399 null]>>/section*.458<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.152<</Rect[291.695 1903.3 299.997 1811.97]/D[null/XYZ 36.1346 501.748 null]>>/section*.459<</Rect[291.695 2301.3 299.997 2209.98]/D[null/XYZ 36.1346 453.808 null]>>/section*.153<</Rect[291.695 1837.3 299.997 1745.98]/D[null/XYZ 36.1346 509.697 null]>>/section*.154<</Rect[291.695 4716.3 299.997 4624.98]/D[null/XYZ 36.1346 162.922 null]>>/section*.155<</Rect[291.695 3380.3 299.997 3288.98]/D[null/XYZ 36.1346 323.843 null]>>/page.880<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.156<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/page.881<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.157<</Rect[291.695 3687.3 299.997 3595.98]/D[null/XYZ 36.1346 286.865 null]>>/page.882<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.158<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/page.883<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.159<</Rect[291.695 2097.3 299.997 2005.98]/D[null/XYZ 36.1346 478.38 null]>>/page.884<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.885<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.886<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.580<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.887<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.581<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.888<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.582<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.889<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.583<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.584<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.90<</Rect[291.695 867.3 299.997 775.975]/D[null/XYZ 36.1346 626.534 null]>>/page.585<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.91<</Rect[291.695 1051.3 299.997 959.976]/D[null/XYZ 36.1346 604.371 null]>>/page.586<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.92<</Rect[291.695 4853.3 299.997 4761.98]/D[null/XYZ 36.1346 146.42 null]>>/section*.760<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.587<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.280<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.93<</Rect[291.695 4969.3 299.997 4877.98]/D[null/XYZ 36.1346 132.448 null]>>/section*.761<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/page.588<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.281<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.94<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>/section*.762<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/page.589<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.282<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.95<</Rect[291.695 607.3 299.997 515.975]/D[null/XYZ 36.1346 657.851 null]>>/section*.763<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/page.283<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.96<</Rect[291.695 716.3 299.997 624.976]/D[null/XYZ 36.1346 644.722 null]>>/section*.764<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/page.284<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.97<</Rect[291.695 1691.3 299.997 1599.98]/D[null/XYZ 36.1346 527.283 null]>>/section*.765<</Rect[291.695 2395.3 299.997 2303.98]/D[null/XYZ 36.1346 442.486 null]>>/page.285<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.98<</Rect[291.695 2156.3 299.997 2064.98]/D[null/XYZ 36.1346 471.274 null]>>/section*.766<</Rect[291.695 3700.3 299.997 3608.98]/D[null/XYZ 36.1346 285.299 null]>>/page.286<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/Item.99<</Rect[291.695 3203.3 299.997 3111.97]/D[null/XYZ 36.1346 345.163 null]>>/section*.460<</Rect[291.695 3856.3 299.997 3764.98]/D[null/XYZ 36.1346 266.509 null]>>/section*.767<</Rect[291.695 4525.3 299.997 4433.98]/D[null/XYZ 36.1346 185.927 null]>>/page.287<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.461<</Rect[291.695 2940.3 299.997 2848.98]/D[null/XYZ 36.1346 376.841 null]>>/section*.768<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.288<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.462<</Rect[291.695 3485.3 299.997 3393.98]/D[null/XYZ 36.1346 311.195 null]>>/section*.769<</Rect[291.695 1199.3 299.997 1107.98]/D[null/XYZ 36.1346 586.544 null]>>/page.289<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.463<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/section*.464<</Rect[291.695 1279.3 299.997 1187.98]/D[null/XYZ 36.1346 576.908 null]>>/section*.465<</Rect[291.695 1825.3 299.997 1733.98]/D[null/XYZ 36.1346 511.143 null]>>/section*.466<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.160<</Rect[291.695 4026.3 299.997 3934.98]/D[null/XYZ 36.1346 246.032 null]>>/section*.467<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.161<</Rect[291.695 3560.3 299.997 3468.98]/D[null/XYZ 36.1346 302.162 null]>>/section*.468<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/section*.162<</Rect[291.695 4164.3 299.997 4072.98]/D[null/XYZ 36.1346 229.41 null]>>/section*.469<</Rect[291.695 3421.3 299.997 3329.98]/D[null/XYZ 36.1346 318.904 null]>>/section*.163<</Rect[291.695 2638.3 299.997 2546.97]/D[null/XYZ 36.1346 413.217 null]>>/section*.164<</Rect[291.695 3780.3 299.997 3688.98]/D[null/XYZ 36.1346 275.663 null]>>/section*.165<</Rect[291.695 2915.3 299.997 2823.98]/D[null/XYZ 36.1346 379.852 null]>>/page.890<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.166<</Rect[291.695 4205.3 299.997 4113.98]/D[null/XYZ 36.1346 224.471 null]>>/page.891<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.167<</Rect[291.695 2339.3 299.997 2247.98]/D[null/XYZ 36.1346 449.231 null]>>/page.892<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.168<</Rect[291.695 658.299 299.997 566.975]/D[null/XYZ 36.1346 651.708 null]>>/page.893<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.169<</Rect[291.695 2471.3 299.997 2379.98]/D[null/XYZ 36.1346 433.332 null]>>/page.894<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.895<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.896<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.590<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.897<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.591<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.898<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.592<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.899<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.593<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.594<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.595<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.596<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.770<</Rect[291.695 2572.3 299.997 2480.98]/D[null/XYZ 36.1346 421.167 null]>>/page.597<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.290<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.771<</Rect[291.695 1231.3 299.997 1139.98]/D[null/XYZ 36.1346 582.69 null]>>/page.598<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.291<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.772<</Rect[291.695 3038.3 299.997 2946.97]/D[null/XYZ 36.1346 365.037 null]>>/page.599<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/page.292<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.773<</Rect[291.695 654.302 299.997 562.977]/D[null/XYZ 36.1346 652.189 null]>>/page.293<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.774<</Rect[291.695 3725.3 299.997 3633.98]/D[null/XYZ 36.1346 282.288 null]>>/page.294<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.775<</Rect[291.695 1596.3 299.997 1504.98]/D[null/XYZ 36.1346 538.726 null]>>/page.295<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.776<</Rect[291.695 4280.3 299.997 4188.98]/D[null/XYZ 36.1346 215.438 null]>>/page.296<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.470<</Rect[291.695 4294.3 299.997 4202.98]/D[null/XYZ 36.1346 213.751 null]>>/page.297<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.471<</Rect[291.695 4919.3 299.997 4827.98]/D[null/XYZ 36.1346 138.47 null]>>/page.298<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.472<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/page.299<</Rect[291.695 228.299 308.299 211.695]/D[null/XYZ 36.1346 693.501 null]>>/section*.473<</Rect[291.695 699.302 299.997 607.977]/D[null/XYZ 36.1346 646.769 null]>>/section*.474<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.475<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/section*.476<</Rect[291.695 3823.3 299.997 3731.98]/D[null/XYZ 36.1346 270.484 null]>>/section*.170<</Rect[291.695 1725.3 299.997 1633.98]/D[null/XYZ 36.1346 523.187 null]>>/section*.477<</Rect[291.695 4497.3 299.997 4405.98]/D[null/XYZ 36.1346 189.3 null]>>/section*.171<</Rect[291.695 2174.3 299.997 2082.98]/D[null/XYZ 36.1346 469.105 null]>>/section*.478<</Rect[291.695 673.299 299.997 581.975]/D[null/XYZ 36.1346 649.901 null]>>/section*.172<</Rect[291.695 4295.3 299.997 4203.98]/D[null/XYZ 36.1346 213.631 null]>>/section*.479<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.173<</Rect[291.695 1022.3 299.997 930.975]/D[null/XYZ 36.1346 607.864 null]>>/section*.174<</Rect[291.695 2493.3 299.997 2401.97]/D[null/XYZ 36.1346 430.682 null]>>/section*.175<</Rect[291.695 641.3 299.997 549.976]/D[null/XYZ 36.1346 653.755 null]>>/section*.176<</Rect[291.695 2594.3 299.997 2502.98]/D[null/XYZ 36.1346 418.516 null]>>/section*.177<</Rect[291.695 4299.3 299.997 4207.98]/D[null/XYZ 36.1346 213.149 null]>>/section*.178<</Rect[291.695 4015.3 299.997 3923.98]/D[null/XYZ 36.1346 247.357 null]>>/section*.179<</Rect[291.695 3469.3 299.997 3377.98]/D[null/XYZ 36.1346 313.123 null]>>/section*.480<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.481<</Rect[291.695 1769.3 299.997 1677.98]/D[null/XYZ 36.1346 517.888 null]>>/section*.482<</Rect[291.695 2277.3 299.997 2185.98]/D[null/XYZ 36.1346 456.699 null]>>/section*.483<</Rect[291.695 3268.3 299.997 3176.97]/D[null/XYZ 36.1346 337.333 null]>>/section*.484<</Rect[291.695 3794.3 299.997 3702.98]/D[null/XYZ 36.1346 273.976 null]>>/section*.485<</Rect[291.695 4339.3 299.997 4247.98]/D[null/XYZ 36.1346 208.331 null]>>/section*.486<</Rect[291.695 721.3 299.997 629.976]/D[null/XYZ 36.1346 644.119 null]>>/section*.180<</Rect[291.695 2437.3 299.997 2345.98]/D[null/XYZ 36.1346 437.427 null]>>/section*.487<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.181<</Rect[291.695 3982.3 299.997 3890.98]/D[null/XYZ 36.1346 251.332 null]>>/section*.488<</Rect[291.695 2500.3 299.997 2408.98]/D[null/XYZ 36.1346 429.839 null]>>/section*.182<</Rect[291.695 3112.3 299.997 3020.98]/D[null/XYZ 36.1346 356.124 null]>>/section*.489<</Rect[291.695 4022.3 299.997 3930.98]/D[null/XYZ 36.1346 246.514 null]>>/section*.183<</Rect[291.695 1135.3 299.997 1043.98]/D[null/XYZ 36.1346 594.253 null]>>/section*.184<</Rect[291.695 1228.3 299.997 1136.97]/D[null/XYZ 36.1346 583.051 null]>>/section*.185<</Rect[291.695 1044.3 299.997 952.977]/D[null/XYZ 36.1346 605.214 null]>>/section*.186<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/section*.187<</Rect[291.695 1433.3 299.997 1341.97]/D[null/XYZ 36.1346 558.359 null]>>/section*.188<</Rect[291.695 649.302 299.997 557.977]/D[null/XYZ 36.1346 652.792 null]>>/section*.189<</Rect[291.695 642.3 299.997 550.975]/D[null/XYZ 36.1346 653.635 null]>>/subsection.4.6.10<</Rect[291.695 1150.3 299.997 1058.98]/D[null/XYZ 36.1346 592.446 null]>>/section*.490<</Rect[291.695 3471.3 299.997 3379.98]/D[null/XYZ 36.1346 312.882 null]>>/section*.491<</Rect[291.695 4115.3 299.997 4023.98]/D[null/XYZ 36.1346 235.312 null]>>/section*.492<</Rect[291.695 1577.3 299.997 1485.98]/D[null/XYZ 36.1346 541.014 null]>>/section*.493<</Rect[291.695 2122.3 299.997 2030.98]/D[null/XYZ 36.1346 475.369 null]>>/section*.494<</Rect[291.695 698.299 299.997 606.975]/D[null/XYZ 36.1346 646.89 null]>>/section*.495<</Rect[291.695 1243.3 299.997 1151.97]/D[null/XYZ 36.1346 581.245 null]>>/section*.496<</Rect[291.695 2500.3 299.997 2408.98]/D[null/XYZ 36.1346 429.839 null]>>/section*.190<</Rect[291.695 3657.3 299.997 3565.98]/D[null/XYZ 36.1346 290.478 null]>>/section*.497<</Rect[291.695 3956.3 299.997 3864.98]/D[null/XYZ 36.1346 254.464 null]>>/section*.191<</Rect[291.695 1460.3 299.997 1368.98]/D[null/XYZ 36.1346 555.107 null]>>/section*.498<</Rect[291.695 2573.3 299.997 2481.97]/D[null/XYZ 36.1346 421.046 null]>>/section*.192<</Rect[291.695 3487.3 299.997 3395.98]/D[null/XYZ 36.1346 310.955 null]>>/section*.499<</Rect[291.695 3218.3 299.997 3126.97]/D[null/XYZ 36.1346 343.356 null]>>/section*.193<</Rect[291.695 4707.3 299.997 4615.98]/D[null/XYZ 36.1346 164.006 null]>>/section*.194<</Rect[291.695 4480.3 299.997 4388.98]/D[null/XYZ 36.1346 191.348 null]>>/section*.195<</Rect[291.695 2878.3 299.997 2786.97]/D[null/XYZ 36.1346 384.309 null]>>/section*.196<</Rect[291.695 656.3 299.997 564.976]/D[null/XYZ 36.1346 651.949 null]>>/section*.197<</Rect[291.695 4047.3 299.997 3955.98]/D[null/XYZ 36.1346 243.503 null]>>/section*.198<</Rect[291.695 3057.3 299.997 2965.98]/D[null/XYZ 36.1346 362.748 null]>>/section*.199<</Rect[291.695 4452.3 299.997 4360.98]/D[null/XYZ 36.1346 194.721 null]>>/figure.5.1<</Rect[1236.69 3069.3 1253.3 3052.7]/D[null/XYZ 149.96 351.303 null]>>/figure.2.1<</Rect[1419.7 3317.3 1436.3 3300.7]/D[null/XYZ 172.002 321.431 null]>>/figure.2.2<</Rect[1724.7 4190.3 1741.3 4173.7]/D[null/XYZ 208.74 216.278 null]>>/subsection.2.7.1<</Rect[291.695 1001.3 299.997 909.976]/D[null/XYZ 36.1346 610.393 null]>>/figure.2.3<</Rect[1885.7 3114.3 1902.3 3097.7]/D[null/XYZ 228.132 345.882 null]>>/subsection.2.7.2<</Rect[291.695 1826.3 299.997 1734.98]/D[null/XYZ 36.1346 511.022 null]>>/figure.2.4<</Rect[1223.7 2360.3 1240.3 2343.7]/D[null/XYZ 148.394 436.702 null]>>/subsection.2.7.3<</Rect[291.695 1853.3 299.997 1761.97]/D[null/XYZ 36.1346 507.77 null]>>/figure.2.5<</Rect[1795.7 1927.3 1812.3 1910.7]/D[null/XYZ 217.292 488.857 null]>>/figure.2.6<</Rect[1583.7 4327.3 1600.3 4310.7]/D[null/XYZ 191.756 199.777 null]>>/figure.2.7<</Rect[1554.7 3902.3 1571.3 3885.7]/D[null/XYZ 188.263 250.968 null]>>/subsection.2.4.1<</Rect[291.695 3845.3 299.997 3753.98]/D[null/XYZ 36.1346 267.833 null]>>/subsection.5.2.1<</Rect[291.695 3979.3 299.997 3887.98]/D[null/XYZ 36.1346 251.693 null]>>/subsection.5.2.2<</Rect[291.695 528.299 299.997 436.975]/D[null/XYZ 36.1346 667.366 null]>>>>endobj36 0 obj<</Count 8/Type/Pages/Kids[42 0 R 1 0 R 4 0 R 7 0 R 10 0 R 13 0 R 16 0 R 19 0 R]>>endobj37 0 obj<</Subtype/XML/Length 3776/Type/Metadata>>stream
+<?xpacket begin="" id="W5M0MpCehiHzreSzNTczkc9d"?>
+<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 4.0-c321 44.398116, Tue Aug 04 2009 14:24:30">
+   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
+      <rdf:Description rdf:about=""
+            xmlns:xap="http://ns.adobe.com/xap/1.0/">
+         <xap:CreateDate>2010-01-06T10:47:34Z</xap:CreateDate>
+         <xap:CreatorTool>LaTeX with hyperref package</xap:CreatorTool>
+         <xap:ModifyDate>2010-01-06T11:31:47-06:00</xap:ModifyDate>
+         <xap:MetadataDate>2010-01-06T11:31:47-06:00</xap:MetadataDate>
+      </rdf:Description>
+      <rdf:Description rdf:about=""
+            xmlns:dc="http://purl.org/dc/elements/1.1/">
+         <dc:format>application/pdf</dc:format>
+         <dc:description>
+            <rdf:Alt>
+               <rdf:li xml:lang="x-default"/>
+            </rdf:Alt>
+         </dc:description>
+         <dc:creator>
+            <rdf:Seq>
+               <rdf:li/>
+            </rdf:Seq>
+         </dc:creator>
+         <dc:title>
+            <rdf:Alt>
+               <rdf:li xml:lang="x-default"/>
+            </rdf:Alt>
+         </dc:title>
+      </rdf:Description>
+      <rdf:Description rdf:about=""
+            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
+         <pdf:Keywords/>
+         <pdf:Producer>dvips + ESP Ghostscript 815.02</pdf:Producer>
+      </rdf:Description>
+      <rdf:Description rdf:about=""
+            xmlns:xapMM="http://ns.adobe.com/xap/1.0/mm/">
+         <xapMM:DocumentID>uuid:42d05dc9-de97-044c-9a6b-39d0943c7a5d</xapMM:DocumentID>
+         <xapMM:InstanceID>uuid:db8eb89d-613b-bc43-a136-17acfa2bab5b</xapMM:InstanceID>
+      </rdf:Description>
+   </rdf:RDF>
+</x:xmpmeta>
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                                                                                                    
+                           
+<?xpacket end="w"?>endstreamendobj38 0 obj<</CreationDate(D:20100106104734Z)/Subject()/Author()/Creator(LaTeX with hyperref package)/Keywords()/Producer(dvips + ESP Ghostscript 815.02)/ModDate(D:20100106113147-06'00')/Title()>>endobjxref0 390000000000 65535 f
+0000064236 00000 n
+0000064415 00000 n
+0000064448 00000 n
+0000069632 00000 n
+0000069811 00000 n
+0000069844 00000 n
+0000075805 00000 n
+0000075984 00000 n
+0000076017 00000 n
+0000081853 00000 n
+0000082035 00000 n
+0000082069 00000 n
+0000085988 00000 n
+0000086170 00000 n
+0000086204 00000 n
+0000089296 00000 n
+0000089478 00000 n
+0000089512 00000 n
+0000091597 00000 n
+0000091794 00000 n
+0000091961 00000 n
+0000091995 00000 n
+0000093758 00000 n
+0000093815 00000 n
+0000093872 00000 n
+0000093941 00000 n
+0000094010 00000 n
+0000094088 00000 n
+0000094182 00000 n
+0000094251 00000 n
+0000094308 00000 n
+0000094365 00000 n
+0000095557 00000 n
+0000095647 00000 n
+0000095724 00000 n
+0000298219 00000 n
+0000298318 00000 n
+0000302171 00000 n
+trailer<</Size 39>>startxref116%%EOF
\ No newline at end of file
diff --git a/src/condor_contrib/mgmt/qmf/daemons/Globals.cpp b/src/condor_contrib/mgmt/qmf/daemons/Globals.cpp
index 0a850ff..37a5873 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/Globals.cpp
+++ b/src/condor_contrib/mgmt/qmf/daemons/Globals.cpp
@@ -20,4 +20,5 @@
 
 JobCollectionType g_jobs;
 SubmissionCollectionType g_submissions;
-OwnerlessClusterType g_ownerless;
\ No newline at end of file
+OwnerlessClusterType g_ownerless_clusters;
+OwnerlessSubmissionType g_ownerless_submissions;
diff --git a/src/condor_contrib/mgmt/qmf/daemons/Globals.h b/src/condor_contrib/mgmt/qmf/daemons/Globals.h
index 989d7ac..8850a0c 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/Globals.h
+++ b/src/condor_contrib/mgmt/qmf/daemons/Globals.h
@@ -33,10 +33,12 @@ using namespace std;
 
 typedef map<const char *, Job *, cmpstr> JobCollectionType;
 typedef map<const char *, SubmissionObject *, cmpstr> SubmissionCollectionType;
-typedef map<int, const char *> OwnerlessClusterType;
+typedef map<int, string> OwnerlessClusterType;
+typedef map<int, SubmissionObject*> OwnerlessSubmissionType;
 
 extern JobCollectionType g_jobs;
 extern SubmissionCollectionType g_submissions;
-extern OwnerlessClusterType g_ownerless;
+extern OwnerlessClusterType g_ownerless_clusters;
+extern OwnerlessSubmissionType g_ownerless_submissions;
 
 #endif /* _GLOBALS_H */
diff --git a/src/condor_contrib/mgmt/qmf/daemons/Job.cpp b/src/condor_contrib/mgmt/qmf/daemons/Job.cpp
index 22ea98a..301949e 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/Job.cpp
+++ b/src/condor_contrib/mgmt/qmf/daemons/Job.cpp
@@ -247,7 +247,8 @@ LiveJobImpl::Set ( const char *_name, const char *_value )
 	// if we are in here, we don't have m_submission
 	PROC_ID id = getProcByString(m_job->GetKey());
 	std::string val = TrimQuotes( _value );
-	g_ownerless[id.cluster] = strdup( val.c_str() );
+	g_ownerless_clusters[id.cluster] = val;
+	m_job->UpdateSubmission(id.cluster,val.c_str());
     }
 
     // parse the type
@@ -372,7 +373,7 @@ HistoryJobImpl::HistoryJobImpl ( const HistoryEntry& _he):
 	m_he(_he)
 {
     m_job = NULL;
-    g_ownerless[_he.cluster] = strdup(_he.owner.c_str());
+    g_ownerless_clusters[_he.cluster] = _he.owner;
     dprintf ( D_FULLDEBUG, "HistoryJobImpl created for '%d.%d'\n", _he.cluster, _he.proc );
 }
 
@@ -585,18 +586,26 @@ void Job::DecrementSubmission() {
 }
 
 void
+Job::UpdateSubmission ( int cluster, const char* owner )
+{
+	OwnerlessSubmissionType::const_iterator it = g_ownerless_submissions.find ( cluster );
+	if ( g_ownerless_submissions.end() != it ) {
+		SubmissionObject* submission = (*it).second;
+		submission->SetOwner(owner);
+		g_ownerless_submissions.erase(cluster);
+	}
+}
+
+void
 Job::SetSubmission ( const char* _subName, int cluster )
 {
 	const char* owner = NULL;
 
 	// need to see if someone has left us an owner
-	OwnerlessClusterType::const_iterator it = g_ownerless.find ( cluster );
-	if ( g_ownerless.end() == it )
+	OwnerlessClusterType::const_iterator it = g_ownerless_clusters.find ( cluster );
+	if ( g_ownerless_clusters.end() != it )
 	{
-		dprintf ( D_FULLDEBUG, "warning: unable to resolve owner for Job key '%s' and cluster '%d'\n", GetKey(), cluster );
-	}
-	else {
-		owner = ( *it ).second ;
+		owner = ( *it ).second.c_str() ;
 	}
 
 	SubmissionCollectionType::const_iterator element = g_submissions.find ( _subName );
@@ -617,7 +626,11 @@ Job::SetSubmission ( const char* _subName, int cluster )
 	if (owner) {
 		// ensure that the submission has an owner
 		m_submission->SetOwner ( owner );
-		g_ownerless.erase ( cluster );
+		g_ownerless_clusters.erase ( cluster );
+	}
+	else {
+		// add it to our list to be updated for owner
+		g_ownerless_submissions[cluster] = m_submission;
 	}
 
 }
diff --git a/src/condor_contrib/mgmt/qmf/daemons/Job.h b/src/condor_contrib/mgmt/qmf/daemons/Job.h
index 2a640f5..147b10b 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/Job.h
+++ b/src/condor_contrib/mgmt/qmf/daemons/Job.h
@@ -149,6 +149,7 @@ class Job
         void Remove ( const char* );
 
         void SetSubmission ( const char*, int );
+        void UpdateSubmission ( int, const char* );
         void IncrementSubmission();
         void DecrementSubmission();
 
diff --git a/src/condor_contrib/mgmt/qmf/daemons/JobServerJobLogConsumer.cpp b/src/condor_contrib/mgmt/qmf/daemons/JobServerJobLogConsumer.cpp
index 62f22c2..7eb7342 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/JobServerJobLogConsumer.cpp
+++ b/src/condor_contrib/mgmt/qmf/daemons/JobServerJobLogConsumer.cpp
@@ -118,9 +118,7 @@ JobServerJobLogConsumer::NewClassAd(const char *_key,
 		JobCollectionType::const_iterator element = g_jobs.find(cluster_dup);
         ClusterJobImpl* cluster_impl = NULL;
 
-		// TODO this code assumes that we will always get the parent 
-		// classad before its child from the job log...this is not strictly
-		// guaranteed (e.g., compressed log?)
+		// either find an existing cluster parent or create a new one
 		if (g_jobs.end() == element) {
 			// didn't find an existing job so create a new one
 			Job* new_cluster_job = new Job(cluster_dup);
@@ -136,13 +134,6 @@ JobServerJobLogConsumer::NewClassAd(const char *_key,
         new_proc_job->SetImpl(new LiveJobImpl(key_dup, cluster_impl));
         g_jobs[key_dup] = new_proc_job;
 
-//		if (cluster_job) {
-//			ClassAd ad;
-//			cluster_job->GetFullAd(ad);
-//			dprintf(D_FULLDEBUG, "JobServerJobLogConsumer::NewClassAd found a parent ClassAd from cluster...\n");
-//			ad.dPrint(D_FULLDEBUG|D_NOHEADER);
-//		}
-
 	}
 
 	return true;
diff --git a/src/condor_contrib/mgmt/qmf/daemons/SubmissionObject.cpp b/src/condor_contrib/mgmt/qmf/daemons/SubmissionObject.cpp
index 5741e43..6b7fee4 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/SubmissionObject.cpp
+++ b/src/condor_contrib/mgmt/qmf/daemons/SubmissionObject.cpp
@@ -180,7 +180,7 @@ SubmissionObject::GetHeld()
 void
 SubmissionObject::SetOwner ( const char *owner )
 {
-    if ( !ownerSet )
+    if (owner && !ownerSet )
     {
         mgmtObject->set_Owner ( string(owner) );
         ownerSet = true;
diff --git a/src/condor_contrib/mgmt/qmf/plugins/NegotiatorObject.cpp b/src/condor_contrib/mgmt/qmf/plugins/NegotiatorObject.cpp
index 78baa6c..48290df 100644
--- a/src/condor_contrib/mgmt/qmf/plugins/NegotiatorObject.cpp
+++ b/src/condor_contrib/mgmt/qmf/plugins/NegotiatorObject.cpp
@@ -188,7 +188,7 @@ NegotiatorObject::SetLimit(std::string &name, double max, std::string &text)
 		return STATUS_USER + 1;
 	}
 
-	if (!IsValidGroupUserName(name,text)) {
+	if (!IsValidParamName(name,text)) {
 		return STATUS_USER + 2;
 	}
 
@@ -233,7 +233,7 @@ NegotiatorObject::SetRawConfig(std::string &name, std::string &value, std::strin
 		return STATUS_USER + 1;
 	}
 
-	if (!IsValidAttributeName(name,text)) {
+	if (!IsValidParamName(name,text)) {
 		return STATUS_USER + 2;
 	}
 
diff --git a/src/condor_contrib/mgmt/qmf/plugins/Utils.cpp b/src/condor_contrib/mgmt/qmf/plugins/Utils.cpp
index 8262f95..90e2c32 100644
--- a/src/condor_contrib/mgmt/qmf/plugins/Utils.cpp
+++ b/src/condor_contrib/mgmt/qmf/plugins/Utils.cpp
@@ -22,6 +22,8 @@
 
 #include "condor_debug.h"
 
+#include "condor_config.h" // is_valid_param_name
+
 #include "compat_classad_util.h"
 
 
@@ -49,23 +51,37 @@ string TrimQuotes(const char* str) {
 }
 
 // validate that an incoming group/user name is
-// alphanumeric, underscores, or a dot separator
+// alphanumeric, underscores, @ or a dot separator
 bool IsValidGroupUserName(const std::string& _name, std::string& _text) {
 	const char* ptr = _name.c_str();
+
 	while( *ptr ) {
 		char c = *ptr++;
 		if (	('a' > c || c > 'z') &&
 			('A' > c || c > 'Z') &&
 			('0' > c || c > '9') &&
 			(c != '_' ) &&
+			(c != '@' ) &&
 			(c != '.' ) ) {
-			_text = "Invalid name for group/user - alphanumeric, underscore and dot characters only";
+			_text = "Invalid name for group/user - alphanumeric, underscore, @ and dot characters only";
 			return false;
 		}
 	}
 	return true;
 }
 
+// validate that an incoming group/user name is
+// alphanumeric, underscores, or a dot separator
+bool IsValidParamName(const std::string& _name, std::string& _text) {
+	const char* ptr = _name.c_str();
+
+	if (!is_valid_param_name(ptr)) {
+		_text = "Invalid name for group/user - alphanumeric, underscore, @ and dot characters only";
+		return false;
+	}
+	return true;
+}
+
 // validate that an incoming attribute name is
 // alphanumeric, or underscores
 bool IsValidAttributeName(const std::string& _name, std::string& _text) {
@@ -161,18 +177,14 @@ bool
 PopulateVariantMapFromAd(compat_classad::ClassAd &ad, Variant::Map &_map)
 {
 	ExprTree *expr;
-    ClassAd::iterator iter;
-
-    ad.ResetExpr();
-    _map.clear();
-    iter = ad.begin();
-    while (iter != ad.end()) {
-            string name = iter->first;
-            if (!AddAttribute(ad, name.c_str(), _map)) {
+	const char *name;
+	ad.ResetExpr();
+	_map.clear();
+	while (ad.NextExpr(name,expr)) {
+		if (!AddAttribute(ad, name, _map)) {
                     return false;
-            }
-            iter++;
-    }
+		}
+	}
 
 	// TODO: debug
 //	if (DebugFlags & D_FULLDEBUG) {
diff --git a/src/condor_contrib/mgmt/qmf/plugins/Utils.h b/src/condor_contrib/mgmt/qmf/plugins/Utils.h
index a248dab..670956a 100644
--- a/src/condor_contrib/mgmt/qmf/plugins/Utils.h
+++ b/src/condor_contrib/mgmt/qmf/plugins/Utils.h
@@ -27,6 +27,8 @@ bool AddAttribute(compat_classad::ClassAd &ad, const char *name, qpid::types::Va
 
 bool IsValidGroupUserName(const std::string& _name, std::string& _text);
 
+bool IsValidParamName(const std::string& _name, std::string& _text);
+
 bool IsValidAttributeName(const std::string& _name, std::string& _text);
 
 bool CheckRequiredAttrs(compat_classad::ClassAd& ad, const char* attrs[], std::string& missing);
diff --git a/src/condor_contrib/mgmt/qmf/test/submit-vm.py b/src/condor_contrib/mgmt/qmf/test/submit-vm.py
index 06155d0..8f83185 100755
--- a/src/condor_contrib/mgmt/qmf/test/submit-vm.py
+++ b/src/condor_contrib/mgmt/qmf/test/submit-vm.py
@@ -17,7 +17,7 @@
 #
 from qmf.console import Session
 from sys import exit, argv
-import time, pwd
+import time, pwd, os
 
 uid = pwd.getpwuid(os.getuid())[0]
 if not uid:
diff --git a/src/condor_contrib/mgmt/qmf/test/submit.py b/src/condor_contrib/mgmt/qmf/test/submit.py
index 7a57d4f..2969488 100755
--- a/src/condor_contrib/mgmt/qmf/test/submit.py
+++ b/src/condor_contrib/mgmt/qmf/test/submit.py
@@ -17,7 +17,7 @@
 #
 from qmf.console import Session
 from sys import exit, argv
-import time, pwd
+import time, pwd, os
 
 uid = pwd.getpwuid(os.getuid())[0]
 if not uid:
diff --git a/src/condor_contrib/triggerd/src/TriggerConsole.cpp b/src/condor_contrib/triggerd/src/TriggerConsole.cpp
index 75406e5..5801fea 100644
--- a/src/condor_contrib/triggerd/src/TriggerConsole.cpp
+++ b/src/condor_contrib/triggerd/src/TriggerConsole.cpp
@@ -102,15 +102,37 @@ TriggerConsole::config(std::string host, int port, std::string user, std::string
    url << host << ":" << port;
    options << "{reconnect:True"; 
    if (!user.empty())
+   {
       options << ", username:'" << user << "', password:'" << passwd << "'";
+   }
    options << "}";
 
-   qpidConnection = qpid::messaging::Connection(url.str(), options.str());
-   qpidConnection.open();
+   try
+   {
+      qpidConnection = qpid::messaging::Connection(url.str(), options.str());
+      qpidConnection.open();
+   }
+   catch(...)
+   {
+      dprintf(D_ALWAYS, "Triggerd Error: Failed to contact AMQP broker on host '%s'.  Absent nodes detection disabled\n", host.c_str());
+      qpidConnection.close();
+   }
 
-   qmf2Session = qmf::ConsoleSession(qpidConnection);
-   qmf2Session.open();
-   qmf2Session.setAgentFilter("[and, [eq, _vendor, [quote, 'com.redhat.grid']], [eq, _product, [quote, 'master']]]");
+   if (true == qpidConnection.isOpen())
+   {
+      try
+      {
+         qmf2Session = qmf::ConsoleSession(qpidConnection);
+         qmf2Session.open();
+         qmf2Session.setAgentFilter("[and, [eq, _vendor, [quote, 'com.redhat.grid']], [eq, _product, [quote, 'master']]]");
+      }
+      catch(...)
+      {
+         dprintf(D_ALWAYS, "Triggerd Error: Failed to setup QMF connections\n");
+         qpidConnection.close();
+         qmf2Session.close();
+      }
+   }
 }
 
 
@@ -124,6 +146,12 @@ TriggerConsole::findAbsentNodes()
    std::list<std::string> missing_nodes;
    uint64_t timeout(30);
 
+   // Only Perform the check if the qpid connection is valid
+   if (false == qpidConnection.isOpen())
+   {
+      return missing_nodes;
+   }
+
    // Drain the queue of pending console events.
    qmf::ConsoleEvent evt;
    while (qmf2Session.nextEvent(evt, qpid::messaging::Duration::IMMEDIATE));
diff --git a/src/condor_contrib/triggerd/src/Triggerd.cpp b/src/condor_contrib/triggerd/src/Triggerd.cpp
index 85e65f9..21fa50d 100644
--- a/src/condor_contrib/triggerd/src/Triggerd.cpp
+++ b/src/condor_contrib/triggerd/src/Triggerd.cpp
@@ -221,22 +221,13 @@ Triggerd::init()
    triggerCollection = new ClassAdCollection(trigger_log.c_str());
    free(dataDir);
 
-   // Initialize the triggers if any already exist
-   triggerCollection->StartIterateAllClassAds();
-   while(true == triggerCollection->IterateAllClassAds(ad, key))
-   {
-      key_value = atoll(key.value());
-      if (triggers.end() == triggers.find(key_value))
-      {
-         if (STATUS_OK != AddTriggerToCollection(key_value, ad, error_text))
-         {
-            dprintf(D_ALWAYS, "Triggerd Error: '%s'.  Removing trigger\n", error_text.c_str());
-            int_str << key_value;
-            triggerCollection->DestroyClassAd(int_str.str().c_str());
-         }
-      }
-   }
+   settings.host = std::string(host);
+   settings.port = port;
+   settings.username = std::string(username);
+   settings.password = std::string(password);
+   settings.mechanism = std::string(mechanism);
 
+   // Initialize the QMF agent
    singleton = new ManagementAgent::Singleton();
    ManagementAgent* agent = singleton->getInstance();
 
@@ -244,17 +235,9 @@ Triggerd::init()
    CondorTrigger::registerSelf(agent);
    EventCondorTriggerNotify::registerSelf(agent);
 
-   mgmtObject = new CondorTriggerService(agent, this);
-
-   settings.host = std::string(host);
-   settings.port = port;
-   settings.username = std::string(username);
-   settings.password = std::string(password);
-   settings.mechanism = std::string(mechanism);
-
-   // Initialize the QMF agent
    agent->setName("com.redhat.grid","condortriggerservice", daemonName.c_str());
    agent->init(settings, interval, true, storefile);
+   mgmtObject = new CondorTriggerService(agent, this);
 
    // Initialize the QMF console, if desired
    enable_console = param_boolean("ENABLE_ABSENT_NODES_DETECTION", false);
@@ -269,8 +252,24 @@ Triggerd::init()
    free(password);
    free(mechanism);
 
-   bool _lifetime = param_boolean("QMF_IS_PERSISTENT", true);
-   agent->addObject(mgmtObject, daemonName.c_str(), _lifetime);
+   // Initialize the triggers if any already exist
+   triggerCollection->StartIterateAllClassAds();
+   while(true == triggerCollection->IterateAllClassAds(ad, key))
+   {
+      key_value = atoll(key.value());
+      if (triggers.end() == triggers.find(key_value))
+      {
+         if (STATUS_OK != AddTriggerToCollection(key_value, ad, error_text))
+         {
+            dprintf(D_ALWAYS, "Triggerd Error: '%s'.  Removing trigger\n", error_text.c_str());
+            int_str << key_value;
+            triggerCollection->DestroyClassAd(int_str.str().c_str());
+         }
+      }
+   }
+
+   bool lifetime = param_boolean("QMF_IS_PERSISTENT", true);
+   agent->addObject(mgmtObject, daemonName.c_str(), lifetime);
 
    // Create a socket to handle management method calls
    sock = new ReliSock;
diff --git a/src/condor_contrib/triggerd/src/condor_trigger_config.py b/src/condor_contrib/triggerd/src/condor_trigger_config.py
index 6b09ab7..8ac5e93 100644
--- a/src/condor_contrib/triggerd/src/condor_trigger_config.py
+++ b/src/condor_contrib/triggerd/src/condor_trigger_config.py
@@ -320,6 +320,9 @@ class TriggerConfigOptionParser(OptionParser):
         self.add_option("-i", "--init", action="store_true", help="add default triggers")
         self.add_option("-l", "--list", action="store_true", help="list installed triggers")
         self.add_option("-s", "--test", action="store_true", help="test triggers")
+        self.add_option("-U", "--user", action="store", help="The username used to authenticate with the broker")
+        self.add_option("-P", "--password", action="store", help="The password used to authenticate with the broker")
+        self.add_option("-m", "--auth-mechanism", action="store", help="A comma separated list of authentication mechanisms to use when communicating with the broker.  Supported mechanisms are: ANONYMOUS, PLAIN, GSSAPI", default="ANONYMOUS,PLAIN,GSSAPI")
 
     def is_valid(self, opts, args):
         valid = False
@@ -352,8 +355,13 @@ def main():
     session = TriggerConfig(opts.test)
 
     print "Connecting to broker '%s'..." % target
+    if opts.user != None and opts.password != None:
+       target = "%s/%s@%s" % (opts.user, opts.password, target)
+    elif opts.user != None:
+       target = "%s@%s" % (opts.user, target)
+
     try:
-        broker = session.addBroker(target)
+        broker = session.addBroker(target, mechanisms = opts.auth_mechanism.replace(',', ' '))
     except Exception, e:
         print e
         sys.exit(1)
diff --git a/src/condor_daemon_core.V6/soap_core.cpp b/src/condor_daemon_core.V6/soap_core.cpp
index 0cf3a64..178dce7 100644
--- a/src/condor_daemon_core.V6/soap_core.cpp
+++ b/src/condor_daemon_core.V6/soap_core.cpp
@@ -518,6 +518,10 @@ int serve_file(struct soap *soap, const char *name, const char *type) {
     web_root_realpath = strdup(buf);
   }
   free(web_root_dir);
+
+  if (!web_root_realpath) {
+    return 404;
+  } 
   
   char * full_name = dircat(web_root_realpath,name);
   char * full_name_realpath = NULL;
diff --git a/src/condor_examples/condor.boot.rpm b/src/condor_examples/condor.boot.rpm
index c96d3b3..498e7da 100755
--- a/src/condor_examples/condor.boot.rpm
+++ b/src/condor_examples/condor.boot.rpm
@@ -500,7 +500,7 @@ find_masters() {
 }
 
 # To the best of its ability, finds the active condor_master's PID.
-# echos the result, or an empty string if none was found.
+# Store the result in global variable MASTER_PIDS.
 # You can call this repeatedly to check for updates.
 # If we use the pid file the first time through, always use it --
 #  if it disappears, means that the Condor went bye-bye
@@ -560,7 +560,7 @@ wait_for_exit() {
     condor_master_pids
   done
   
-  if [ "`condor_master_pids`" = "" ]; then
+  if [ "$MASTER_PIDS" = "" ]; then
     return 0
   else
     return 1
@@ -684,8 +684,8 @@ xstop() {
 # This can fail for any number of reasons, and we wouldn't
 # detect it.
 #
-# As a possible improvement, we might send SIGHUP if `condor_master_pids`
-# is non-empty, only falling back on condor_reconfig if it is.
+# As a possible improvement, we might send SIGHUP if condor_master_pids
+# finds nothing, only falling back on condor_reconfig if it is.
 #
 # Also, detect the return code from CONDOR_RECONFIG; non-zero
 # indicates aproblem. (At the moment that never happens, but
@@ -712,7 +712,8 @@ reload() {
 # 3 not running
 # 4 unknown
 status() {
-  master_pid=`condor_master_pids`
+  condor_master_pids
+  master_pid="$MASTER_PIDS"
   if [ "$master_pid" != "" ]; then
     echo "Condor is running (pid $master_pid)"
     return 0
@@ -768,7 +769,8 @@ case "$INIT_COMMAND" in
     ;;
 
   'try-restart')
-    if [ "`condor_master_pids`" = "" ]; then exit 0; fi # Not running
+    condor_master_pids
+    if [ "$MASTER_PIDS" = "" ]; then exit 0; fi # Not running
     xstop
     start
     ;;
diff --git a/src/condor_gridmanager/amazonjob.cpp b/src/condor_gridmanager/amazonjob.cpp
index 27a13b5..b55e601 100644
--- a/src/condor_gridmanager/amazonjob.cpp
+++ b/src/condor_gridmanager/amazonjob.cpp
@@ -154,6 +154,12 @@ dprintf( D_ALWAYS, "================================>  AmazonJob::AmazonJob 1 \n
 	numSubmitAttempts = 0;
 	myResource = NULL;
 	gahp = NULL;
+	m_public_key_file = NULL;
+	m_private_key_file = NULL;
+	m_user_data = NULL;
+	m_user_data_file = NULL;
+	m_group_names = NULL;
+	m_instance_type = NULL;
 	
 	// check the public_key_file
 	buff[0] = '\0';
@@ -183,8 +189,6 @@ dprintf( D_ALWAYS, "================================>  AmazonJob::AmazonJob 1 \n
 		// at the attribute in a better way.
 
 	memset(buff, 0, 16385);
-	m_user_data = NULL;
-	m_user_data_file = NULL;	
 	
 	// if user assigns both user_data and user_data_file, the two will
 	// be concatenated by the gahp
@@ -197,14 +201,13 @@ dprintf( D_ALWAYS, "================================>  AmazonJob::AmazonJob 1 \n
 	
 	// get VM instance type
 	memset(buff, 0, 16385);
-	m_instance_type = NULL; // if clients don't assign this value in condor submit file,
-							// we should set the default value to NULL and gahp_server
-							// will start VM in Amazon using m1.small mode.
+	// if clients don't assign this value in condor submit file,
+	// we should set the default value to NULL and gahp_server
+	// will start VM in Amazon using m1.small mode.
 	if ( jobAd->LookupString( ATTR_AMAZON_INSTANCE_TYPE, buff ) ) {
 		m_instance_type = strdup(buff);	
 	}
 	
-	m_group_names = NULL;
 	m_vm_check_times = 0;
 	m_keypair_check_times = 0;
 
diff --git a/src/condor_gridmanager/creamresource.cpp b/src/condor_gridmanager/creamresource.cpp
index e82339d..3680ed4 100644
--- a/src/condor_gridmanager/creamresource.cpp
+++ b/src/condor_gridmanager/creamresource.cpp
@@ -175,7 +175,7 @@ dprintf(D_FULLDEBUG,"    deleting %s\n",next_deleg->deleg_uri?next_deleg->deleg_
 		free( serviceUri );
 	}
 
-	ResourcesByName.remove( HashKey( HashName( resourceName, proxySubject ) ) );
+	ResourcesByName.remove( HashKey( HashName( resourceName, proxyFQAN ) ) );
 
 	daemonCore->Cancel_Timer( delegationTimerId );
 	if ( gahp != NULL ) {
diff --git a/src/condor_includes/condor_debug.h b/src/condor_includes/condor_debug.h
index 742ed59..48be699 100644
--- a/src/condor_includes/condor_debug.h
+++ b/src/condor_includes/condor_debug.h
@@ -76,6 +76,12 @@
 extern "C" {
 #endif
 
+#if _MSC_VER >= 1400 /* VC++ 2005 version */
+#define PREFAST_NORETURN __declspec(noreturn)
+#else
+#define PREFAST_NORETURN
+#endif
+
 extern int DebugFlags;	/* Bits to look for in dprintf */
 extern int Termlog;		/* Are we logging to a terminal? */
 extern int DebugShouldLockToAppend; /* Should we lock the file before each write? */
@@ -93,7 +99,7 @@ void dprintf ( int flags, const char *fmt, ... ) CHECK_PRINTF_FORMAT(2,3);
 void dprintf_config( const char *subsys );
 void _condor_dprintf_va ( int flags, const char* fmt, va_list args );
 int _condor_open_lock_file(const char *filename,int flags, mode_t perm);
-void _EXCEPT_ ( const char *fmt, ... ) CHECK_PRINTF_FORMAT(1,2);
+void PREFAST_NORETURN _EXCEPT_ ( const char *fmt, ... ) CHECK_PRINTF_FORMAT(1,2);
 void Suicide(void);
 void set_debug_flags( const char *strflags );
 void _condor_fd_panic( int line, const char *file );
@@ -156,7 +162,7 @@ extern int	_EXCEPT_Line;			/* Line number of the exception    */
 extern const char	*_EXCEPT_File;		/* File name of the exception      */
 extern int	_EXCEPT_Errno;			/* errno from most recent system call */
 extern int (*_EXCEPT_Cleanup)(int,int,const char*);	/* Function to call to clean up (or NULL) */
-extern void _EXCEPT_(const char*, ...) CHECK_PRINTF_FORMAT(1,2);
+extern PREFAST_NORETURN void _EXCEPT_(const char*, ...) CHECK_PRINTF_FORMAT(1,2);
 
 #if defined(__cplusplus)
 }
diff --git a/src/condor_includes/condor_sys_nt.h b/src/condor_includes/condor_sys_nt.h
index 676793b..92e69ed 100644
--- a/src/condor_includes/condor_sys_nt.h
+++ b/src/condor_includes/condor_sys_nt.h
@@ -241,6 +241,18 @@ END_C_DECLS
 
 #endif
 
+// defeat prefast warnings
+_Check_return_ inline int isspace(_In_ char ch) {
+   return isspace(static_cast<int> (static_cast<unsigned char> (ch)));
+}
+_Check_return_ inline int isalnum(_In_ char ch) {
+   return isalnum(static_cast<int> (static_cast<unsigned char> (ch)));
+}
+_Check_return_ inline int isdigit(_In_ char ch) {
+   return isdigit(static_cast<int> (static_cast<unsigned char> (ch)));
+}
+
+
 /* Define the PRIx64 macros */
 
 // If no inttypes, try to define our own
diff --git a/src/condor_includes/condor_system.h b/src/condor_includes/condor_system.h
index d08d6dd..1c943da 100644
--- a/src/condor_includes/condor_system.h
+++ b/src/condor_includes/condor_system.h
@@ -1,6 +1,6 @@
 /***************************************************************
  *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * Copyright (C) 1990-2011, Condor Team, Computer Sciences Department,
  * University of Wisconsin-Madison, WI.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you
@@ -169,7 +169,6 @@
 #include <time.h>
 #include <sys/time.h>
 #include <sys/times.h>
-#include <rpc/types.h>
 #if !defined(Darwin) && !defined(CONDOR_FREEBSD)
 #include <values.h>
 #endif
diff --git a/src/condor_includes/config.h.cmake b/src/condor_includes/config.h.cmake
index 28d802f..3969aff 100644
--- a/src/condor_includes/config.h.cmake
+++ b/src/condor_includes/config.h.cmake
@@ -25,14 +25,6 @@
 /// TODO: OS VARS, may be able to ax with some smart mods
 /// the definitions
 /// I may be able to do away with all of this.
-///* Define if on FreeBSD4 */
-//#cmakedefine CONDOR_FREEBSD4
-///* Define if on FreeBSD5 */
-//#cmakedefine CONDOR_FREEBSD5
-///* Define if on FreeBSD6 */
-//#cmakedefine CONDOR_FREEBSD6
-///* Define if on FreeBSD7 */
-//#cmakedefine CONDOR_FREEBSD7
 ///* Define if on OS X 10.3 */
 //#cmakedefine Darwin_10_3
 ///* Define if on OS X 10.4 */
@@ -44,6 +36,28 @@
 //////////////////////////////////////////////////
 
 //////////////////////////////////////////////////
+// Sadly, some of these are still in use
+/* Define if on FreeBSD 4 */
+#cmakedefine CONDOR_FREEBSD4
+/* Define if on FreeBSD 5 */
+#cmakedefine CONDOR_FREEBSD5
+/* Define if on FreeBSD 6 */
+#cmakedefine CONDOR_FREEBSD6
+/* Define if on FreeBSD 7 */
+#cmakedefine CONDOR_FREEBSD7
+///* Define if on FreeBSD 8 */
+#cmakedefine CONDOR_FREEBSD8
+///* Define if on FreeBSD */
+#cmakedefine CONDOR_FREEBSD
+///* Define release of FreeBSD (i.e. 7.4, 8.2) */
+#cmakedefine FREEBSD_RELEASE
+///* Define major release of FreeBSD */
+#cmakedefine FREEBSD_MAJOR
+///* Define minor release of FreeBSD */
+#cmakedefine FREEBSD_MINOR
+//////////////////////////////////////////////////
+
+//////////////////////////////////////////////////
 /// Options which may be changed if standard universe
 /// goes away
 ///* Define if we can do checkpointing */
diff --git a/src/condor_io/condor_crypt.cpp b/src/condor_io/condor_crypt.cpp
index e8f1d40..2de4883 100644
--- a/src/condor_io/condor_crypt.cpp
+++ b/src/condor_io/condor_crypt.cpp
@@ -75,6 +75,7 @@ unsigned char * Condor_Crypt_Base :: randomKey(int length)
     int size = 128;
     if( ! already_seeded ) {
         unsigned char * buf = (unsigned char *) malloc(size);
+        ASSERT(buf);
 		for (int i = 0; i < size; i++) {
 			buf[i] = get_random_int() & 0xFF;
 		}
@@ -118,6 +119,6 @@ unsigned char * Condor_Crypt_Base :: oneWayHashKey(const char * initialKey)
 #ifdef HAVE_EXT_OPENSSL
     return Condor_MD_MAC::computeOnce((unsigned char *)initialKey, strlen(initialKey));
 #else 
-    return 0;
+    return NULL;
 #endif
 }
diff --git a/src/condor_io/condor_secman.cpp b/src/condor_io/condor_secman.cpp
index 54579de..207fbba 100644
--- a/src/condor_io/condor_secman.cpp
+++ b/src/condor_io/condor_secman.cpp
@@ -2900,7 +2900,7 @@ SecMan::CreateNonNegotiatedSecuritySession(DCpermission auth_level, char const *
 	unsigned char* keybuf = Condor_Crypt_Base::oneWayHashKey(private_key);
 	if(!keybuf) {
 		dprintf(D_ALWAYS,"SECMAN: failed to create non-negotiated security session %s because"
-				"oneWayHashKey() failed.\n",sesid);
+				" oneWayHashKey() failed.\n",sesid);
 		return false;
 	}
 	KeyInfo *keyinfo = new KeyInfo(keybuf,keylen,crypt_protocol);
diff --git a/src/condor_io/shared_port_client.cpp b/src/condor_io/shared_port_client.cpp
index 05a46ff..b9f26c2 100644
--- a/src/condor_io/shared_port_client.cpp
+++ b/src/condor_io/shared_port_client.cpp
@@ -193,12 +193,12 @@ SharedPortClient::PassSocket(Sock *sock_to_pass,char const *shared_port_id,char
 		return false;
 	}
 
-	int bufferSize = sizeof(WSAPROTOCOL_INFO) + sizeof(int);
+	int bufferSize = sizeof(protocol_info) + sizeof(int);
 	char *buffer = new char[bufferSize];
 	ASSERT( buffer );
 	int cmd = SHARED_PORT_PASS_SOCK;
 	memcpy_s(buffer, sizeof(int), &cmd, sizeof(int));
-	memcpy_s(buffer+sizeof(int), sizeof(WSAPROTOCOL_INFO), &protocol_info, sizeof(WSAPROTOCOL_INFO));
+	memcpy_s(buffer+sizeof(int), sizeof(protocol_info), &protocol_info, sizeof(protocol_info));
 	BOOL write_result = WriteFile(child_pipe, buffer, bufferSize, &read_bytes, 0);
 
 	delete [] buffer;
diff --git a/src/condor_job_router/JobRouter.h b/src/condor_job_router/JobRouter.h
index 7de6951..243f44c 100644
--- a/src/condor_job_router/JobRouter.h
+++ b/src/condor_job_router/JobRouter.h
@@ -26,7 +26,6 @@
 #include "RoutedJob.h"
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 #if HAVE_JOB_HOOKS
diff --git a/src/condor_job_router/JobRouterHookMgr.h b/src/condor_job_router/JobRouterHookMgr.h
index 5084e81..e061d05 100644
--- a/src/condor_job_router/JobRouterHookMgr.h
+++ b/src/condor_job_router/JobRouterHookMgr.h
@@ -26,7 +26,6 @@
 #include "RoutedJob.h"
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 
diff --git a/src/condor_job_router/NewClassAdJobLogConsumer.cpp b/src/condor_job_router/NewClassAdJobLogConsumer.cpp
index 9ee3728..3d2fe1c 100644
--- a/src/condor_job_router/NewClassAdJobLogConsumer.cpp
+++ b/src/condor_job_router/NewClassAdJobLogConsumer.cpp
@@ -27,7 +27,6 @@
 #include <string>
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 NewClassAdJobLogConsumer::NewClassAdJobLogConsumer() : m_reader(0) { }
diff --git a/src/condor_job_router/NewClassAdJobLogConsumer.h b/src/condor_job_router/NewClassAdJobLogConsumer.h
index 8b0c142..d4d6d12 100644
--- a/src/condor_job_router/NewClassAdJobLogConsumer.h
+++ b/src/condor_job_router/NewClassAdJobLogConsumer.h
@@ -27,7 +27,6 @@
 #include <string>
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 class NewClassAdJobLogConsumer: public ClassAdLogConsumer
diff --git a/src/condor_job_router/RoutedJob.h b/src/condor_job_router/RoutedJob.h
index 6cb2432..7d27709 100644
--- a/src/condor_job_router/RoutedJob.h
+++ b/src/condor_job_router/RoutedJob.h
@@ -23,7 +23,6 @@
 //#include "condor_common.h"
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 class JobRoute;
diff --git a/src/condor_job_router/VanillaToGrid.cpp b/src/condor_job_router/VanillaToGrid.cpp
index 429c478..fd4e8bd 100644
--- a/src/condor_job_router/VanillaToGrid.cpp
+++ b/src/condor_job_router/VanillaToGrid.cpp
@@ -29,7 +29,6 @@
 #include "filename_tools.h"
 #include "string_list.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 
diff --git a/src/condor_job_router/VanillaToGrid_main.cpp b/src/condor_job_router/VanillaToGrid_main.cpp
index 39f812e..56d6762 100644
--- a/src/condor_job_router/VanillaToGrid_main.cpp
+++ b/src/condor_job_router/VanillaToGrid_main.cpp
@@ -26,7 +26,6 @@
 #include "condor_attributes.h"
 #include "basename.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 #include <libgen.h>
diff --git a/src/condor_job_router/set_user_from_ad.cpp b/src/condor_job_router/set_user_from_ad.cpp
index c44f966..f332ce0 100644
--- a/src/condor_job_router/set_user_from_ad.cpp
+++ b/src/condor_job_router/set_user_from_ad.cpp
@@ -27,7 +27,6 @@
 #include "classad_newold.h"
 #include "condor_uid.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 void set_user_from_ad(classad::ClassAd const &ad)
diff --git a/src/condor_job_router/submit_job.cpp b/src/condor_job_router/submit_job.cpp
index 6aa544c..cd82c69 100644
--- a/src/condor_job_router/submit_job.cpp
+++ b/src/condor_job_router/submit_job.cpp
@@ -34,7 +34,6 @@
 #include "format_time.h"
 #include "set_user_priv_from_ad.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 #include "set_user_from_ad.h"
 #include "file_transfer.h"
diff --git a/src/condor_kbdd/kbdd.cpp b/src/condor_kbdd/kbdd.cpp
index be3f10d..1420b77 100644
--- a/src/condor_kbdd/kbdd.cpp
+++ b/src/condor_kbdd/kbdd.cpp
@@ -38,7 +38,6 @@
 #include <utmp.h>
 #include <sys/file.h>
 #include <netinet/in.h>
-#include <rpc/types.h>
 #include <X11/Xlib.h>
 
 XInterface *xinter = NULL;
diff --git a/src/condor_negotiator.V6/matchmaker.cpp b/src/condor_negotiator.V6/matchmaker.cpp
index e4d3a89..cf49d73 100644
--- a/src/condor_negotiator.V6/matchmaker.cpp
+++ b/src/condor_negotiator.V6/matchmaker.cpp
@@ -1272,7 +1272,7 @@ negotiationTime ()
 
                     negotiateWithGroup(untrimmed_num_startds, untrimmedSlotWeightTotal, minSlotWeight,
                                        startdAds, claimIds, *(group->submitterAds), 
-                                       slots, group->usage, group->name.c_str());
+                                       slots, group->name.c_str());
                 }
 
                 // Halt when we have negotiated with full deltas
@@ -1967,7 +1967,7 @@ negotiateWithGroup ( int untrimmed_num_startds,
 					 ClassAdListDoesNotDeleteAds& startdAds,
 					 ClaimIdHash& claimIds, 
 					 ClassAdListDoesNotDeleteAds& scheddAds, 
-					 float groupQuota, float groupusage,const char* groupAccountingName)
+					 float groupQuota, const char* groupName)
 {
     time_t start_time_phase3 = time(NULL);
 	ClassAd		*schedd;
@@ -2006,6 +2006,18 @@ negotiateWithGroup ( int untrimmed_num_startds,
 	do {
 		spin_pie++;
 
+        // On the first spin of the pie we tell the negotiate function to ignore the
+        // submitterLimit w/ respect to jobs which are strictly preferred by resource 
+        // offers (via startd rank).  However, if preemption is not being considered, 
+        // we respect submitter limits on all iterations.
+        const bool ignore_submitter_limit = ((spin_pie == 1) && ConsiderPreemption);
+
+        double groupusage = (NULL != groupName) ? accountant.GetWeightedResourcesUsed(groupName) : 0.0;
+        if (!ignore_submitter_limit && (NULL != groupName) && (groupusage >= groupQuota)) {
+            // If we've met the group quota, and if we are paying attention to submitter limits, halt now
+            dprintf(D_ALWAYS, "Group %s is using its quota %g - halting negotiation\n", groupName, groupQuota);
+            break;
+        }
 			// invalidate the MatchList cache, because even if it is valid
 			// for the next user+auto_cluster being considered, we might
 			// have thrown out matches due to SlotWeight being too high
@@ -2028,7 +2040,7 @@ negotiateWithGroup ( int untrimmed_num_startds,
 
 		calculatePieLeft(
 			scheddAds,
-			groupAccountingName,
+			groupName,
 			groupQuota,
 			groupusage,
 			maxPrioValue,
@@ -2056,6 +2068,11 @@ negotiateWithGroup ( int untrimmed_num_startds,
         // "schedd" seems to be used interchangeably with "submitter" here
 		while( (schedd = scheddAds.Next()) )
 		{
+            if (!ignore_submitter_limit && (NULL != groupName) && (accountant.GetWeightedResourcesUsed(groupName) >= groupQuota)) {
+                // If we met group quota, and if we're respecting submitter limits, halt.
+                // (output message at top of outer loop above)
+                break;
+            }
 			// get the name of the submitter and address of the schedd-daemon it came from
 			if( !schedd->LookupString( ATTR_NAME, scheddName ) ||
 				!schedd->LookupString( ATTR_SCHEDD_IP_ADDR, scheddAddr ) )
@@ -2100,7 +2117,7 @@ negotiateWithGroup ( int untrimmed_num_startds,
 
 			calculateSubmitterLimit(
 				scheddName.Value(),
-				groupAccountingName,
+				groupName,
 				groupQuota,
 				groupusage,
 				maxPrioValue,
@@ -2184,11 +2201,6 @@ negotiateWithGroup ( int untrimmed_num_startds,
 				if ( (submitterLimit <= 0 || pieLeft < minSlotWeight) && spin_pie > 1 ) {
 					result = MM_RESUME;
 				} else {
-					if ( spin_pie == 1 && ConsiderPreemption ) {
-						ignore_schedd_limit = true;
-					} else {
-						ignore_schedd_limit = false;
-					}
 					int numMatched = 0;
 					startTime = time(NULL);
 					double limitUsed = 0.0;
@@ -2247,7 +2259,6 @@ negotiateWithGroup ( int untrimmed_num_startds,
 		scheddAds.Close();
 		dprintf( D_FULLDEBUG, " resources used scheddUsed= %f\n",scheddUsed);
 
-		groupusage = scheddUsed;
 	} while ( ( pieLeft < pieLeftOrig || scheddAds.MyLength() < scheddAdsCountOrig )
 			  && (scheddAds.MyLength() > 0)
 			  && (startdAds.MyLength() > 0) );
@@ -2570,6 +2581,25 @@ obtainAdsFromCollector (
 				// CRUFT: Before 7.3.2, submitter ads had a MyType of
 				//   "Scheduler". The only way to tell the difference
 				//   was that submitter ads didn't have ATTR_NUM_USERS.
+
+            MyString subname;
+            if (!ad->LookupString(ATTR_NAME, subname)) {
+                dprintf(D_ALWAYS, "WARNING: ignoring submitter ad with no name\n");
+                continue;
+            }
+
+            int numidle=0;
+            ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+            int numrunning=0;
+            ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+            int requested = numrunning + numidle;
+
+            // This will avoid some wasted effort in negotiation looping
+            if (requested <= 0) {
+                dprintf(D_FULLDEBUG, "Ignoring submitter %s with no requested jobs\n", subname.Value());
+                continue;
+            }
+
     		ad->Assign(ATTR_TOTAL_TIME_IN_CYCLE, 0);
 			scheddAds.Insert(ad);
 		}
diff --git a/src/condor_negotiator.V6/matchmaker.h b/src/condor_negotiator.V6/matchmaker.h
index e0d647b..2b01ff5 100644
--- a/src/condor_negotiator.V6/matchmaker.h
+++ b/src/condor_negotiator.V6/matchmaker.h
@@ -175,7 +175,7 @@ class Matchmaker : public Service
 								 double minSlotWeight,
 			ClassAdListDoesNotDeleteAds& startdAds, 
 			ClaimIdHash& claimIds, ClassAdListDoesNotDeleteAds& scheddAds, 
-			float groupQuota=INT_MAX, float groupusage=0, const char* groupAccountingName=NULL);
+			float groupQuota=INT_MAX, const char* groupName=NULL);
 
 		
 		ClassAd *matchmakingAlgorithm(const char*,const char*,ClassAd&,ClassAdListDoesNotDeleteAds&,
diff --git a/src/condor_procapi/procapi.cpp b/src/condor_procapi/procapi.cpp
index fcb28fa..bee8e36 100644
--- a/src/condor_procapi/procapi.cpp
+++ b/src/condor_procapi/procapi.cpp
@@ -492,12 +492,6 @@ ProcAPI::getProcInfoRaw( pid_t pid, procInfoRaw& procRaw, int &status )
 		// assume success
 	status = PROCAPI_OK;
 
-		// clear the memory of procRaw
-	initProcInfoRaw(procRaw);
-
-		// set the sample time
-	procRaw.sample_time = secsSinceEpoch();
-
 	// read the entry a certain number of times since it appears that linux
 	// often simply does something stupid while reading.
 	sprintf( path, "/proc/%d/stat", pid );
@@ -508,7 +502,10 @@ ProcAPI::getProcInfoRaw( pid_t pid, procInfoRaw& procRaw, int &status )
 
 		// in case I must restart, assume that everything is ok again...
 		status = PROCAPI_OK;
+		// clear the memory of procRaw
 		initProcInfoRaw(procRaw);
+		// set the sample time
+		procRaw.sample_time = secsSinceEpoch();
 
 		if( (fp = safe_fopen_wrapper(path, "r")) == NULL ) {
 			if( errno == ENOENT ) {
diff --git a/src/condor_rmdir/bprint.h b/src/condor_rmdir/bprint.h
index b7ae97d8..2bb4535 100644
--- a/src/condor_rmdir/bprint.h
+++ b/src/condor_rmdir/bprint.h
@@ -253,10 +253,10 @@ void bprint_Initialize(BPRINT_BUFFER & bp)
    if (bp.cchMax <= 0)
       bp.cchMax = 0x0FFFF;
    if ( ! bp.psz)
-      bp.psz = (LPTSTR) GlobalAllocPtr(GPTR, (bp.cchMax+1) * NUMBYTES(bp.psz[0]));
+      bp.psz = (LPTSTR) malloc((bp.cchMax+1) * NUMBYTES(bp.psz[0]));
   #ifdef UNICODE
    if ( ! bp.pszAscii)
-      bp.pszAscii = (LPSTR) GlobalAllocPtr(GPTR, (bp.cchMax+1) * 2);
+      bp.pszAscii = (LPSTR) malloc((bp.cchMax+1) * 2);
   #endif
    bp.cch = 0;
    bp.CodePage = CP_ACP;
@@ -466,9 +466,9 @@ void bprint_Terminate(BPRINT_BUFFER & bp, bool fFlush)
    if (fFlush)
       bprint_EndLine(bp);
    if (bp.psz)
-      GlobalFreePtr(bp.psz);
+      free(bp.psz);
    if (bp.pszAscii)
-      GlobalFreePtr(bp.pszAscii);
+      free(bp.pszAscii);
    if (bp.hOut && (bp.hOut != GetStdHandle(STD_OUTPUT_HANDLE)))
       CloseHandle(bp.hOut);
    ZeroStruct(&bp);
diff --git a/src/condor_rmdir/harylist.h b/src/condor_rmdir/harylist.h
index d31f71e..f62b326 100644
--- a/src/condor_rmdir/harylist.h
+++ b/src/condor_rmdir/harylist.h
@@ -118,13 +118,13 @@ HRESULT FNEXPORT HaryList_InsertList (
 INLINE LPVOID HaryList_AllocItem(HARYLIST hlst, LONG cbItem) {
 	DASSERT(PCARYLIST_PTR(hlst)->cbItem == sizeof(void*));
 	DASSERT(PCARYLIST_PTR(hlst)->fdwOptions & ARYLIST_OPT_F_GPTRS);
-	return (LPVOID)GlobalAllocPtr(GPTR, cbItem);
+	return (LPVOID)malloc(cbItem);
 }
 
 INLINE void HaryList_FreeItem(HARYLIST hlst, LPVOID pvItem) {
 	DASSERT(PCARYLIST_PTR(hlst)->cbItem == sizeof(void*));
 	DASSERT(PCARYLIST_PTR(hlst)->fdwOptions & ARYLIST_OPT_F_GPTRS);
-	GlobalFreePtr(pvItem);
+	free(pvItem);
 }
 
 INLINE HRESULT HaryList_InsertItemCopy(HARYLIST hlst, LONG ix, LPCVOID pvItem) {
@@ -384,7 +384,7 @@ HRESULT FNEXPORT HaryList_Create (
 	else
 	{
 		*phlst = NULL;
-		plst = (PARYLIST)GlobalAllocPtr(GPTR, sizeof(*plst));
+		plst = (PARYLIST)malloc(sizeof(*plst));
 	}
 	if ( ! plst)
 		return E_OUTOFMEMORY;
@@ -407,7 +407,7 @@ HRESULT FNEXPORT HaryList_Create (
 	plst->cGrowBy    = cGrowBy;
 
     LONG cb = cAllocate * cbItem;
-    plst->pvList = (void**)GlobalAllocPtr(GPTR, cb);
+    plst->pvList = (void**)malloc(cb);
 
 	if (fdwOptions & ARYLIST_OPT_F_EMBEDDED)
 	{
@@ -417,7 +417,7 @@ HRESULT FNEXPORT HaryList_Create (
     DASSERT(plst->pvList);
     if ( ! plst->pvList)
     {
-        GlobalFreePtr(plst);
+        free(plst);
         return E_OUTOFMEMORY;
     }
 
@@ -445,12 +445,12 @@ HRESULT FNEXPORT HaryList_Destroy (HARYLIST hlst)
 				LPVOID pv = ppv[plst->cItems-1];
 				ppv[plst->cItems-1] = NULL;
 				if (pv)
-					GlobalFreePtr(pv);
+					free(pv);
 				--plst->cItems;
 			}
 		}
 
-        GlobalFreePtr(plst->pvList);
+        free(plst->pvList);
         plst->pvList = NULL;
     }
 
@@ -461,7 +461,7 @@ HRESULT FNEXPORT HaryList_Destroy (HARYLIST hlst)
     }
 
 	if ( ! (plst->fdwOptions & ARYLIST_OPT_F_EMBEDDED))
-		GlobalFreePtr(plst);
+		free(plst);
     return S_OK;
 }
 
@@ -485,12 +485,7 @@ HRESULT HaryList_GrowAllocated (
 
     LONG cbNewAlloc = (plst->cAllocated + cDelta) * plst->cbItem;
 
-    // 
-    // GlobalReAllocPtr can fail, will fail so we have to allocate
-    // a whole new buffer and copy the new data to it.
-    //pvNew = (LPVOID)GlobalReAllocPtr(plst->pvList, cb, GMEM_ZEROINIT);
-
-    void** pvNew = (void**)GlobalAllocPtr(GPTR, cbNewAlloc);
+    void** pvNew = (void**)malloc(cbNewAlloc);
     if ( ! pvNew)
     {
         hr = E_OUTOFMEMORY;
@@ -498,7 +493,7 @@ HRESULT HaryList_GrowAllocated (
     }
 
     RtlCopyMemory(pvNew, plst->pvList, plst->cAllocated * plst->cbItem);
-    GlobalFreePtr(plst->pvList);
+    free(plst->pvList);
 
     plst->pvList = pvNew;
     plst->cAllocated += cDelta;
diff --git a/src/condor_rmdir/main.cpp b/src/condor_rmdir/main.cpp
index 19395a2..fc6c89a 100644
--- a/src/condor_rmdir/main.cpp
+++ b/src/condor_rmdir/main.cpp
@@ -745,7 +745,8 @@ HRESULT App_ExecuteCommandLine (
          {
          hr = App_ExecuteArgList (aArgs, ixFirst, cArgs - ixFirst);
          }
-      GlobalFreePtr (aArgs);
+
+      HeapFree(GetProcessHeap(), 0, aArgs);
       }
 
    return hr;
@@ -761,6 +762,12 @@ const TCHAR * _pszModulePath; // global path name
 void App_SetModuleInfo(void)
 {
    TCHAR * pszBase =(TCHAR*)malloc(sizeof(TCHAR) * (MAX_PATH+3));
+   if ( ! pszBase)
+      {
+	  _pszModulePath = _pszModuleName = TEXT("");
+	  return;
+      }
+
    TCHAR * psz = pszBase;
    *psz++ = 0; // so we have room for a "" path if the module filename has no path
    int cch = GetModuleFileName(NULL, psz, MAX_PATH+1);
@@ -798,13 +805,13 @@ void App_SetModuleInfo(void)
       _pszModulePath = pszBase;
    else
       {
-      if (_pszModuleName-1 > _pszModulePath)
+      if (_pszModuleName-2 >= _pszModulePath)
          {
          // we need to be careful not to delete \ folling a drive letter,
          // if that happens, we have to move the name by 1 character
          // so there is room for a null terminator after N:\ and before
          // the name.
-         if (_pszModuleName[-1] == ':' &&
+         if (_pszModuleName[-2] == ':' &&
              _pszModuleName[-1] == '\\')
             {
             RtlMoveMemory((void*)(_pszModuleName+1), (void*)(_pszModuleName),
diff --git a/src/condor_schedd.V6/qmgmt.cpp b/src/condor_schedd.V6/qmgmt.cpp
index c3fbafd..aee9daf 100644
--- a/src/condor_schedd.V6/qmgmt.cpp
+++ b/src/condor_schedd.V6/qmgmt.cpp
@@ -2862,6 +2862,7 @@ CommitTransaction(SetAttributeFlags_t flags /* = 0 */)
 					rewriteSpooledJobAd(procad, cluster_id, proc_id, false);
 					JobQueue->CommitNondurableTransaction();
 					ScheduleJobQueueLogFlush();
+					SpooledJobFiles::createJobSpoolDirectory(procad,PRIV_UNKNOWN);
 				}
 
 				std::string version;
@@ -2871,7 +2872,6 @@ CommitTransaction(SetAttributeFlags_t flags /* = 0 */)
 					// they are responsible for writing the submit event
 					// to the user log.
 					if ( vers.built_since_version( 7, 5, 4 ) ) {
-						SpooledJobFiles::createJobSpoolDirectory(procad,PRIV_UNKNOWN);
 						PROC_ID job_id;
 						job_id.cluster = cluster_id;
 						job_id.proc = proc_id;
@@ -2947,9 +2947,13 @@ GetAttributeFloat(int cluster_id, int proc_id, const char *attr_name, float *val
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		sscanf(attr_val, "%f", val);
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupFloat(attr_name, *val) == 1) {
+			return 1;
+		}
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
@@ -2971,9 +2975,13 @@ GetAttributeInt(int cluster_id, int proc_id, const char *attr_name, int *val)
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		sscanf(attr_val, "%d", val);
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupInteger(attr_name, *val) == 1) {
+			return 1;
+		}
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
@@ -2995,9 +3003,13 @@ GetAttributeBool(int cluster_id, int proc_id, const char *attr_name, int *val)
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		sscanf(attr_val, "%d", val);
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupBool(attr_name, *val) == 1) {
+			return 1;
+		}
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
@@ -3025,15 +3037,13 @@ GetAttributeStringNew( int cluster_id, int proc_id, const char *attr_name,
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		int attr_len = strlen( attr_val );
-		if ( attr_val[0] != '"' || attr_val[attr_len-1] != '"' ) {
-			free( attr_val );
-			return -1;
-		}
-		attr_val[attr_len - 1] = '\0';
-		*val = strdup(&attr_val[1]);
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupString(attr_name, val) == 1) {
+			return 1;
+		}
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
@@ -3060,16 +3070,14 @@ GetAttributeString( int cluster_id, int proc_id, const char *attr_name,
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		int attr_len = strlen( attr_val );
-		if ( attr_val[0] != '"' || attr_val[attr_len-1] != '"' ) {
-			free( attr_val );
-			val = "";
-			return -1;
-		}
-		attr_val[attr_len - 1] = '\0';
-		val = attr_val + 1;
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupString(attr_name, val) == 1) {
+			return 1;
+		}
+		val = "";
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
diff --git a/src/condor_schedd.V6/schedd.cpp b/src/condor_schedd.V6/schedd.cpp
index 0e977f9..a394332 100644
--- a/src/condor_schedd.V6/schedd.cpp
+++ b/src/condor_schedd.V6/schedd.cpp
@@ -11801,12 +11801,11 @@ bool
 moveStrAttr( PROC_ID job_id, const char* old_attr, const char* new_attr,
 			 bool verbose )
 {
-	char* value = NULL;
-	MyString new_value;
+	MyString value;
 	int rval;
 
-	if( GetAttributeStringNew(job_id.cluster, job_id.proc,
-							  old_attr, &value) < 0 ) { 
+	if( GetAttributeString(job_id.cluster, job_id.proc,
+						   old_attr, value) < 0 ) { 
 		if( verbose ) {
 			dprintf( D_FULLDEBUG, "No %s found for job %d.%d\n",
 					 old_attr, job_id.cluster, job_id.proc );
@@ -11814,14 +11813,8 @@ moveStrAttr( PROC_ID job_id, const char* old_attr, const char* new_attr,
 		return false;
 	}
 	
-	new_value += '"';
-	new_value += value;
-	new_value += '"';
-	free( value );
-	value = NULL;
-
-	rval = SetAttribute( job_id.cluster, job_id.proc, new_attr,
-						 new_value.Value() ); 
+	rval = SetAttributeString( job_id.cluster, job_id.proc, new_attr,
+							   value.Value() ); 
 
 	if( rval < 0 ) { 
 		if( verbose ) {
diff --git a/src/condor_scripts/Condor.pm b/src/condor_scripts/Condor.pm
index 26b0ca8..473ee44 100755
--- a/src/condor_scripts/Condor.pm
+++ b/src/condor_scripts/Condor.pm
@@ -703,7 +703,7 @@ sub Monitor
 	# if this line is for another cluster, ignore
 	if ( $line =~ /^\d+\s+\(0*(\d+)\./ && $1 != $cluster )
 	{
-	    debug( "log line for cluster $1, not $cluster -- ignoring...\n" ,6);
+	    debug( "log line for cluster $1, not $cluster -- ignoring...\n" ,1);
 	    next LINE;
 	}
 	
@@ -713,7 +713,7 @@ sub Monitor
 	    $info{'cluster'} = $1;
 	    $info{'job'} = $2;
 
-	    debug( "Saw job evicted\n" ,5);
+	    debug( "Saw job ($1.$2) evicted\n" ,1);
 
 	    # execute callback if one is registered
 	    &$EvictedCallback( %info )
@@ -738,7 +738,7 @@ sub Monitor
 
 	    if( $line =~ /^\s+\(0\) Job was not checkpointed\./ )
 	    {
-		debug( "job was evicted without ckpt\n" ,5);
+		debug( "job was evicted without ckpt\n" ,1);
 		# execute callback if one is registered
 		&$EvictedWithoutCheckpointCallback( %info )
 		    if defined $EvictedWithoutCheckpointCallback;
@@ -746,14 +746,14 @@ sub Monitor
 	    }
 	    elsif( $line =~ /^\s+\(1\) Job was checkpointed\./ )
 	    {
-		debug( "job was evicted with ckpt\n" ,5);
+		debug( "job was evicted with ckpt\n" ,1);
 		# execute callback if one is registered
 		&$EvictedWithCheckpointCallback( %info )
 		    if defined $EvictedWithCheckpointCallback;
 	    }
 	    elsif( $line =~ /^\s+\(0\) Job terminated and was requeued.*$/ )
 	    {
-		debug( "job was evicted and requeued\n" ,5);
+		debug( "job was evicted and requeued\n" ,1);
 		# execute callback if one is registered
 		&$EvictedWithRequeueCallback( %info )
 		    if defined $EvictedWithRequeueCallback;
@@ -762,7 +762,7 @@ sub Monitor
 	    {
 		debug( "parse error on line $linenum of $info{'log'}:\n" .
 		       "   no checkpoint message found after eviction: " .
-		       "continuing...\n" ,5);
+		       "continuing...\n" ,1);
 		# re-parse line so we don't miss whatever it said
 		goto PARSE;
 	    }
@@ -775,7 +775,7 @@ sub Monitor
 	    $info{'cluster'} = $1;
 	    $info{'job'} = $2;
 
-	    debug( "Saw job terminated\n" ,5);
+	    debug( "Saw job terminated\n" ,1);
 
 	    # decrement # of queued jobs so we will know when to exit monitor
 	    $num_active_jobs--;
@@ -817,11 +817,11 @@ sub Monitor
 	    # abnormal termination
 	    elsif( $line =~ /^\s+\(0\) Abnormal termination \(signal (\d+)\)/ )
 	    {
-		debug( "Loading $1 as info{'signal'}\n" ,5);
+		debug( "Loading $1 as info{'signal'}\n" ,1);
 		$info{'signal'} = $1;
 		#print "keys:".join(" ",keys %info)."\n";
 
-		debug( "checking for core file...\n" ,5);
+		debug( "checking for core file...\n" ,1);
 
 		# read next line to find core file
 		$line = <SUBMIT_LOG>;
@@ -860,7 +860,7 @@ sub Monitor
 	    {
 		debug( "parse error on line $linenum of $info{'log'}:\n" .
 		       "   no termination status message found after " .
-		       "termination: continuing...\n" ,5);
+		       "termination: continuing...\n" ,1);
 		# re-parse line so we don't miss whatever it said
 		goto PARSE;
 	    }
@@ -873,7 +873,7 @@ sub Monitor
 	    $info{'cluster'} = $1;
 	    $info{'job'} = $2;
 
-	    debug( "Saw Shadow Exception\n" ,5);
+	    debug( "Saw Shadow Exception\n" ,1);
 
 		if(! defined $ShadowCallback)
 		{
@@ -916,7 +916,7 @@ sub Monitor
 	    $info{'host'} = $3;
 	    $info{'sinful'} = "<$3>";
 	    
-	    debug( "Saw job executing\n" ,5);
+	    debug( "Saw job executing\n" ,1);
 
 	    # execute callback if one is registered
 	    &$ExecuteCallback( %info )
@@ -934,7 +934,7 @@ sub Monitor
 	    $info{'host'} = $3;
 	    $info{'sinful'} = "<$3>";
 
-	    debug( "Saw job submitted\n" ,5);
+	    debug( "Saw job submitted\n" ,1);
 	    $submit_info{'cluster'} = $1; # squirrel it away for TimedWait
 
 	    # mark that we've seen a submit so we can start watching # of jobs
@@ -955,7 +955,7 @@ sub Monitor
 	    $info{'cluster'} = $1;
 	    $info{'job'} = $2;
 
-	    debug( "Saw job abort cluster $1 job $2\n" ,5);
+	    debug( "Saw job abort cluster $1 job $2\n" ,1);
 
 	    # decrement # of queued jobs so we will know when to exit monitor
 	    $num_active_jobs--;
@@ -989,7 +989,7 @@ sub Monitor
 
 		$info{'holdreason'} = $line;
 
-	    debug( "Saw job held\n" ,5);
+	    debug( "Saw job held\n" ,1);
 
 	    
 	    # execute callback if one is registered
@@ -1005,7 +1005,7 @@ sub Monitor
 	    #$info{'host'} = $3;
 	    #$info{'sinful'} = "<$3:$4>";
 	    
-	    debug( "Saw job released\n" ,5);
+	    debug( "Saw job released\n" ,1);
 
 	    
 	    # execute callback if one is registered
diff --git a/src/condor_scripts/CondorUtils.pm b/src/condor_scripts/CondorUtils.pm
index bdd74f4..a332152 100644
--- a/src/condor_scripts/CondorUtils.pm
+++ b/src/condor_scripts/CondorUtils.pm
@@ -257,7 +257,7 @@ sub runcmd {
 		}
 		$sz = $#errlines;
 		if($sz != -1) {
-			PrintStdOut(\@errlines);
+			PrintStdErr(\@errlines);
 		}
 		PrintFooter();
 	}
diff --git a/src/condor_shadow.V6.1/NTreceivers.cpp b/src/condor_shadow.V6.1/NTreceivers.cpp
index d3ed7f9..7049f81 100644
--- a/src/condor_shadow.V6.1/NTreceivers.cpp
+++ b/src/condor_shadow.V6.1/NTreceivers.cpp
@@ -181,14 +181,25 @@ do_REMOTE_syscall()
 		err_msg += ':';
 		err_msg += syscall_sock->peer_port();
 		err_msg += '>';
+
+            // the socket is closed, there's no way to recover
+            // from this.  so, we have to cancel the socket
+            // handler in daemoncore and delete the relisock.
+		thisRemoteResource->closeClaimSock();
+
+            /* It is possible that we are failing to read the
+            syscall number because the starter went away
+            because we *asked* it to go away. Don't be shocked
+            and surprised if the startd/starter actually did
+            what we asked when we deactivated the claim */
+       if ( thisRemoteResource->wasClaimDeactivated() ) {
+           return 0;
+       }
+
 		if( Shadow->supportsReconnect() ) {
 				// instead of having to EXCEPT, we can now try to
 				// reconnect.  happy day! :)
 			dprintf( D_ALWAYS, "%s\n", err_msg.Value() );
-				// the socket is closed, there's no way to recover
-				// from this.  so, we have to cancel the socket
-				// handler in daemoncore and delete the relisock.
-			thisRemoteResource->closeClaimSock();
 
 			const char* txt = "Socket between submit and execute hosts "
 				"closed unexpectedly";
diff --git a/src/condor_shadow.V6.1/baseshadow.cpp b/src/condor_shadow.V6.1/baseshadow.cpp
index 5c3ab37..93b22f3 100644
--- a/src/condor_shadow.V6.1/baseshadow.cpp
+++ b/src/condor_shadow.V6.1/baseshadow.cpp
@@ -73,6 +73,7 @@ BaseShadow::BaseShadow() {
 	m_lazy_queue_update = true;
 	m_cleanup_retry_tid = -1;
 	m_cleanup_retry_delay = 30;
+	m_RunAsNobody = false;
 }
 
 BaseShadow::~BaseShadow() {
@@ -163,9 +164,30 @@ BaseShadow::baseInit( ClassAd *job_ad, const char* schedd_addr, const char *xfer
 	// handle system calls with Owner's privilege
 // XXX this belong here?  We'll see...
 	if ( !init_user_ids(owner.Value(), domain.Value())) {
-		dprintf(D_ALWAYS, "init_user_ids() failed!\n");
+		dprintf(D_ALWAYS, "init_user_ids() failed as user %s\n",owner.Value() );
 		// uids.C will EXCEPT when we set_user_priv() now
 		// so there's not much we can do at this point
+		
+#if ! defined(WIN32)
+		if ( param_boolean( "SHADOW_RUN_UNKNOWN_USER_JOBS", false ) )
+		{
+			dprintf(D_ALWAYS, "trying init_user_ids() as user nobody\n" );
+			
+			owner="nobody";
+			domain=NULL;
+			if (!init_user_ids(owner.Value(), domain.Value()))
+			{
+				dprintf(D_ALWAYS, "init_user_ids() failed!\n");
+			}
+			else
+			{
+				jobAd->Assign( ATTR_JOB_RUNAS_OWNER, "FALSE" );
+				m_RunAsNobody=true;
+				dprintf(D_ALWAYS, "init_user_ids() now running as user nobody\n");
+			}
+		}
+#endif
+
 	}
 	set_user_priv();
 	daemonCore->Register_Priv_State( PRIV_USER );
@@ -287,6 +309,15 @@ void BaseShadow::config()
 
 
 int BaseShadow::cdToIwd() {
+	int iRet =0;
+	
+#if ! defined(WIN32)
+	priv_state p;
+	
+	if (m_RunAsNobody)
+		p = set_root_priv();
+#endif
+	
 	if (chdir(iwd.Value()) < 0) {
 		int chdir_errno = errno;
 		dprintf(D_ALWAYS, "\n\nPath does not exist.\n"
@@ -297,9 +328,15 @@ int BaseShadow::cdToIwd() {
 		                    iwd.Value(), strerror(chdir_errno));
 		dprintf( D_ALWAYS, "%s\n",hold_reason.Value());
 		holdJob(hold_reason.Value(),CONDOR_HOLD_CODE_IwdError,chdir_errno);
-		return -1;
+		iRet = -1;
 	}
-	return 0;
+	
+#if ! defined(WIN32)
+	if ( m_RunAsNobody )
+		set_priv(p);
+#endif
+	
+	return iRet;
 }
 
 
@@ -614,6 +651,13 @@ BaseShadow::terminateJob( update_style_t kind ) // has a default argument of US_
 	// update the job ad in the queue with some important final
 	// attributes so we know what happened to the job when using
 	// condor_history...
+    if (m_num_cleanup_retries < 1 &&
+        param_boolean("SHADOW_TEST_JOB_CLEANUP_RETRY", false)) {
+		dprintf( D_ALWAYS,
+				 "Testing Failure to perform final update to job queue!\n");
+		retryJobCleanup();
+		return;
+    }
 	if( !updateJobInQueue(U_TERMINATE) ) {
 		dprintf( D_ALWAYS, 
 				 "Failed to perform final update to job queue!\n");
@@ -773,7 +817,21 @@ void BaseShadow::initUserLog()
 
 	if ( getPathToUserLog(jobAd, logfilename) ) {
 		result = uLog.initialize (owner.Value(), domain.Value(), logfilename.Value(), cluster, proc, 0, gjid);
+		// It is important to NOT ignore a failure to initialize the user log,
+		// since if we fail to initialize here, then all event logging 
+		// in the shadow from this point forward are effectively ignored.
+		// So if we fail to initialize the user log, put this job on hold.
+		// Future work: it would be good to pass use the error stack to 
+		// figure out -why- the initialization failed, allowing the shadow
+		// to retry automatically -vs- go on hold depending upon the details
+		// of the failure.
 		if ( result == false ) {
+			MyString hold_reason;
+			hold_reason.sprintf(
+				"Failed to initialize user log to %s", logfilename.Value());
+			dprintf( D_ALWAYS, "%s\n",hold_reason.Value());
+			holdJob(hold_reason.Value(),CONDOR_HOLD_CODE_UnableToInitUserLog,0);
+			// holdJob() should not return, but just in case it does EXCEPT
 			EXCEPT("Failed to initialize user log to %s",logfilename.Value());
 		}
 		if (jobAd->LookupBool(ATTR_ULOG_USE_XML, use_xml)
diff --git a/src/condor_shadow.V6.1/baseshadow.h b/src/condor_shadow.V6.1/baseshadow.h
index f4053e9..3b5d769 100644
--- a/src/condor_shadow.V6.1/baseshadow.h
+++ b/src/condor_shadow.V6.1/baseshadow.h
@@ -428,6 +428,7 @@ class BaseShadow : public Service
 	char *uidDomain;
 	int reconnect_ceiling;
 	double reconnect_e_factor;
+	bool m_RunAsNobody;
 
 	// job parameters
 	int cluster;
diff --git a/src/condor_shadow.V6.1/remoteresource.h b/src/condor_shadow.V6.1/remoteresource.h
index a4871df..f22647e 100644
--- a/src/condor_shadow.V6.1/remoteresource.h
+++ b/src/condor_shadow.V6.1/remoteresource.h
@@ -336,6 +336,13 @@ class RemoteResource : public Service {
 		/// Did the job on this resource exit with a signal?
 	bool exitedBySignal( void ) { return exited_by_signal; };
 
+        /** Return true if we already asked the startd to deactivate
+            the claim (aka kill the starter), false if not.
+            @return true if claim deactivated, false if not
+         */
+    bool wasClaimDeactivated( void ) {
+       return already_killed_graceful || already_killed_fast; };
+
 		/** If the job on this resource exited with a signal, return
 			the signal.  If not, return -1. */
 	int exitSignal( void );
diff --git a/src/condor_startd.V6/ResState.cpp b/src/condor_startd.V6/ResState.cpp
index f303099..54934d9 100644
--- a/src/condor_startd.V6/ResState.cpp
+++ b/src/condor_startd.V6/ResState.cpp
@@ -412,6 +412,25 @@ ResState::eval( void )
 		break;	
 
 	case owner_state:
+			// If the dynamic slot is allocated in the owner state
+			// (e.g. because of START expression contains attributes
+			// of job ClassAd), it may never go back to Unclaimed 
+			// state. So we need to delete the dynmaic slot in owner
+			// state.
+		if( Resource::DYNAMIC_SLOT == rip->get_feature() ) {
+#if HAVE_JOB_HOOKS
+				// If we're currently fetching we can't delete
+				// ourselves. If we do when the hook returns we won't
+				// be around to handle the response.
+			if( rip->isCurrentlyFetching() ) {
+				dprintf(D_ALWAYS, "State change: Owner -> Deleted delayed for outstanding work fetch\n");
+				break;
+			}
+#endif
+			change( delete_state );
+			return TRUE; // XXX: change TRUE
+		}
+
 		if( ! rip->eval_is_owner() ) {
 			dprintf( D_ALWAYS, "State change: IS_OWNER is false\n" );
 			change( unclaimed_state );
diff --git a/src/condor_startd.V6/Resource.cpp b/src/condor_startd.V6/Resource.cpp
index c8c598e..4c9bbef 100644
--- a/src/condor_startd.V6/Resource.cpp
+++ b/src/condor_startd.V6/Resource.cpp
@@ -2527,4 +2527,19 @@ void Resource::disable()
 }
 
 
+float
+Resource::compute_rank( ClassAd* req_classad ) {
+
+	float rank;
+
+	if( r_classad->EvalFloat( ATTR_RANK, req_classad, rank ) == 0 ) {
+		ExprTree *rank_expr = r_classad->LookupExpr("RANK");
+		dprintf( D_ALWAYS, "Error evaluating machine rank expression: %s\n", ExprTreeToString(rank_expr));
+		dprintf( D_ALWAYS, "Setting RANK to 0.0\n");
+		rank = 0.0;
+	}
+	return rank;
+}
+
+
 #endif /* HAVE_JOB_HOOKS */
diff --git a/src/condor_startd.V6/Resource.h b/src/condor_startd.V6/Resource.h
index 000d208..3a142e6 100644
--- a/src/condor_startd.V6/Resource.h
+++ b/src/condor_startd.V6/Resource.h
@@ -189,6 +189,7 @@ public:
 	int		eval_start( void );			// returns -1 on undefined
 	int		eval_cpu_busy( void );		// returns FALSE on undefined
 	bool	willingToRun( ClassAd* request_ad );
+	float	compute_rank( ClassAd* req_classad );
 
 #if HAVE_BACKFILL
 	int		eval_start_backfill( void ); 
diff --git a/src/condor_startd.V6/StartdHookMgr.cpp b/src/condor_startd.V6/StartdHookMgr.cpp
index 07b61fb..12ff7e8 100644
--- a/src/condor_startd.V6/StartdHookMgr.cpp
+++ b/src/condor_startd.V6/StartdHookMgr.cpp
@@ -184,7 +184,7 @@ StartdHookMgr::handleHookFetchWork(FetchClient* fetch_client)
 		willing = false;
 	}
 	else {
-		rank = compute_rank(rip->r_classad, job_ad);
+		rank = rip->compute_rank(job_ad);
 		rip->dprintf(D_FULLDEBUG, "Rank of this fetched claim is: %f\n", rank);
 		if (rip->state() == claimed_state && !idle_fetch_claim) {
 				// Make sure it's got a high enough rank to preempt us.
diff --git a/src/condor_startd.V6/command.cpp b/src/condor_startd.V6/command.cpp
index 13d3d31..1d8d6e6 100644
--- a/src/condor_startd.V6/command.cpp
+++ b/src/condor_startd.V6/command.cpp
@@ -1197,7 +1197,7 @@ request_claim( Resource* rip, Claim *claim, char* id, Stream* stream )
 	}
 
 		// Now, make sure it's got a high enough rank to preempt us.
-	rank = compute_rank(rip->r_classad, req_classad);
+	rank = rip->compute_rank(req_classad);
 	rip->dprintf( D_FULLDEBUG, "Rank of this claim is: %f\n", rank );
 
 	if( rip->state() == claimed_state ) {
@@ -1721,7 +1721,7 @@ activate_claim( Resource* rip, Stream* stream )
 	tmp_starter = NULL;
 
 		// update the current rank on this claim
-	float rank = compute_rank( mach_classad, req_classad ); 
+	float rank = rip->compute_rank( req_classad ); 
 	rip->r_cur->setrank( rank );
 
 		// Grab the job ID, so we've got it.  Once we give the
diff --git a/src/condor_startd.V6/util.cpp b/src/condor_startd.V6/util.cpp
index b552dcc..d86fc43 100644
--- a/src/condor_startd.V6/util.cpp
+++ b/src/condor_startd.V6/util.cpp
@@ -356,20 +356,6 @@ cleanup_execute_dir(int pid, char const *exec_path)
 #endif  /* UNIX */
 }
 
-
-float
-compute_rank( ClassAd* mach_classad, ClassAd* req_classad ) 
-{
-	float rank;
-
-	if( mach_classad->EvalFloat( ATTR_RANK, req_classad, rank ) == 0 ) {
-		dprintf( D_ALWAYS, "Error evaluating rank.\n" );
-		rank = 0;
-	}
-	return rank;
-}
-
-
 int
 create_port( ReliSock* rsock )
 {
diff --git a/src/condor_startd.V6/util.h b/src/condor_startd.V6/util.h
index 23fd420..0d5728b 100644
--- a/src/condor_startd.V6/util.h
+++ b/src/condor_startd.V6/util.h
@@ -31,7 +31,6 @@ class StringList;
 void	cleanup_execute_dir(int pid, char const *exec_path);
 void	cleanup_execute_dirs( StringList &list );
 void	check_execute_dir_perms( StringList &list );
-float	compute_rank( ClassAd*, ClassAd* );
 int 	create_port( ReliSock* );
 bool	reply( Stream*, int );
 bool	refuse( Stream* );
diff --git a/src/condor_starter.V6.1/CondorJavaInfo.class b/src/condor_starter.V6.1/CondorJavaInfo.class
index 2f28c3b..893d89c 100644
Binary files a/src/condor_starter.V6.1/CondorJavaInfo.class and b/src/condor_starter.V6.1/CondorJavaInfo.class differ
diff --git a/src/condor_starter.V6.1/CondorJavaInfo.java b/src/condor_starter.V6.1/CondorJavaInfo.java
index 73153e2..71d6f94 100644
--- a/src/condor_starter.V6.1/CondorJavaInfo.java
+++ b/src/condor_starter.V6.1/CondorJavaInfo.java
@@ -98,7 +98,7 @@ public class CondorJavaInfo {
 			// deal with escaped double quotes very well. This might be
 			// revisited in the future.
 			System.out.print( UnDotString(name) + " = \"" + 
-				value.replace('"', '\'') + "\"");
+				value.replace('"', '\'').replace('\n',' ').replace('\r', ' ') + "\"");
 
 			if( newmode ) {
 				System.out.println(";");
diff --git a/src/condor_starter.V6.1/jic_shadow.cpp b/src/condor_starter.V6.1/jic_shadow.cpp
index b17cd6c..04a3cb4 100644
--- a/src/condor_starter.V6.1/jic_shadow.cpp
+++ b/src/condor_starter.V6.1/jic_shadow.cpp
@@ -377,8 +377,10 @@ bool JICShadow::allJobsDone( void )
 
 	r1 = JobInfoCommunicator::allJobsDone();
 
-	publishJobExitAd( &update_ad );
-	r2 = updateShadow( &update_ad, true );
+	if (!m_did_transfer) {
+		publishJobExitAd( &update_ad );
+		r2 = updateShadow( &update_ad, true );
+	}
 
 	return r1;
 }
diff --git a/src/condor_starter.V6.1/vanilla_proc.cpp b/src/condor_starter.V6.1/vanilla_proc.cpp
index b27af2a..1b0495b 100644
--- a/src/condor_starter.V6.1/vanilla_proc.cpp
+++ b/src/condor_starter.V6.1/vanilla_proc.cpp
@@ -340,11 +340,7 @@ VanillaProc::ShutdownGraceful()
 	// now softkill the parent job process.  this is exactly what
 	// OsProc::ShutdownGraceful does, so call it.
 	//
-	OsProc::ShutdownGraceful();
-#if !defined(WIN32)
-	startEscalationTimer();
-#endif
-	return false; // shutdown is pending (same as OsProc::ShutdownGraceful()
+	return OsProc::ShutdownGraceful();
 }
 
 bool
diff --git a/src/condor_sysapi/CMakeLists.txt b/src/condor_sysapi/CMakeLists.txt
index 2f2fbcf..3690c59 100644
--- a/src/condor_sysapi/CMakeLists.txt
+++ b/src/condor_sysapi/CMakeLists.txt
@@ -16,6 +16,7 @@
  # 
  ############################################################### 
 
+set(BENCH_LINK_LIBS "${TOOL_LINK_LIBS}")
 
 file( GLOB SysApiRmvElements *_t.cpp *.t.* dhry21b* *_main.cpp )
 
@@ -26,5 +27,5 @@ condor_static_lib(sysapi "${SysapiHeaderFiles};${SysapiSourceFiles}")
 
 # there was a test target which was never used.
 # it makes the most sense to hook in a UT here instead of integ test
-condor_exe(condor_kflops "kflops_main.cpp" "${C_LIBEXEC}" "sysapi;condorapi;${TOOL_LINK_LIBS}" OFF)
-condor_exe(condor_mips "mips_main.cpp" "${C_LIBEXEC}" "sysapi;condorapi;${TOOL_LINK_LIBS}" OFF)
+condor_exe(condor_kflops "kflops_main.cpp" ${C_LIBEXEC} "sysapi;condorapi;${BENCH_LINK_LIBS}" OFF)
+condor_exe(condor_mips "mips_main.cpp" ${C_LIBEXEC} "sysapi;condorapi;${BENCH_LINK_LIBS}" OFF)
diff --git a/src/condor_syscall_lib/CMakeLists.txt b/src/condor_syscall_lib/CMakeLists.txt
index 2f96684..7208da6 100644
--- a/src/condor_syscall_lib/CMakeLists.txt
+++ b/src/condor_syscall_lib/CMakeLists.txt
@@ -104,6 +104,20 @@ if( STD_UNIVERSE )
 	# now create the glorious syscall lib from various refs.
 	# behold the birth of frankenstein.
 	condor_static_lib( condorsyscall "senders.cpp;switches.cpp;${SyscallHdrs};${SyscallSrcs};${STDU_OBJS};${CKPT_REFS};${UTIL_REFS};${IO_REFS};${STDIO_REF}")
+	if (DOES_COMPRESS_CKPT)
+		# For condorzsyscall, pull in all the same objects as
+		# condorsyscall except use ZCKPT_REFS in place of
+		# CKPT_REFS
+		src_target_ref( zckpt "^.*$" ZCKPT_REFS)
+
+		# We need to compile condor-malloc.c with special preprocessor
+		# definitions.
+		src_target_ref( zckpt "malloc-condor.c" MALLOC_CONDOR_REF)
+		set_property(SOURCE ${MALLOC_CONDOR_REF} APPEND PROPERTY COMPILE_DEFINITIONS "MORECORE=condor_morecore;HAVE_MMAP=0;malloc_getpagesize=8192")
+
+		condor_static_lib( condorzsyscall "senders.cpp;switches.cpp;${SyscallHdrs};${SyscallSrcs};${STDU_OBJS};${ZCKPT_REFS};${UTIL_REFS};${IO_REFS};${STDIO_REF}")
+	endif()
+
 	# local library which the daemons can link without glibc tainting.
 	condor_static_lib( std_local_ref "senders.cpp;receivers.cpp;${CKPT_LOCAL_REFS};${SYSCALL_LOCAL_REFS}" )
 
@@ -111,7 +125,10 @@ if( STD_UNIVERSE )
 	# part 2:
 	# set dependencies to ensure build dep order for parallel builds
 	##################################################
-	add_dependencies( condorsyscall ckpt utils cedar stdunivio stub_gen )
+	add_dependencies( condorsyscall stub_gen )
+	if (DOES_COMPRESS_CKPT)
+		add_dependencies( condorzsyscall stub_gen )
+	endif()
 	add_dependencies( switches syscall_numbers stub_gen )
 	add_dependencies( senders syscall_numbers stub_gen )
 	add_dependencies( receivers syscall_numbers stub_gen )
@@ -120,6 +137,9 @@ if( STD_UNIVERSE )
 	#################################################
 	# here we begin the install target section
 	install ( TARGETS condorsyscall DESTINATION ${C_LIB} )
+	if (DOES_COMPRESS_CKPT)
+		install ( TARGETS condorzsyscall DESTINATION ${C_LIB} )
+	endif()
 	install ( FILES ${CMAKE_CURRENT_BINARY_DIR}/condor_rt0.o DESTINATION ${C_LIB} )
 	install ( FILES ${LIBGCC} DESTINATION ${C_LIB} RENAME libcomp_libgcc.a )
 	install ( FILES ${LIBGCC_EH} DESTINATION ${C_LIB} RENAME libcomp_libgcc_eh.a )
diff --git a/src/condor_tests/CMakeLists.txt b/src/condor_tests/CMakeLists.txt
index 32e0264..babf413 100644
--- a/src/condor_tests/CMakeLists.txt
+++ b/src/condor_tests/CMakeLists.txt
@@ -105,6 +105,7 @@ if (BUILD_TESTS)
 		condor_std_exe_test(job_ckpt_io-async_std "${CMAKE_C_COMPILER}" "job_ckpt_io-async_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_io-buffer-async_std "${CMAKE_C_COMPILER}" "job_ckpt_io-buffer-async_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_stack_std "${CMAKE_C_COMPILER}" "job_ckpt_stack_std.c" "${STDU_LDD_FLAGS}")
+		condor_std_exe_test(job_ckpt_standalone_std "${CMAKE_C_COMPILER}" "job_ckpt_standalone_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_floats_std "${CMAKE_C_COMPILER}" "job_ckpt_floats_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_floats-async_std "${CMAKE_C_COMPILER}" "job_ckpt_floats-async_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_integers_std "${CMAKE_C_COMPILER}" "job_ckpt_integers_std.c" "${STDU_LDD_FLAGS}")
@@ -167,12 +168,16 @@ if (BUILD_TESTS)
 
 	if (WANT_LEASE_MANAGER)
 		condor_pl_test(lib_lease_manager-simple "Lease manager: Simple test" "core;quick;full")
+	
+	endif(WANT_LEASE_MANAGER)
+
+	if (WANT_LEASE_MANAGER_EXTRA_TESTS)
 		condor_pl_test(lib_lease_manager-get_rel_1 "Lease manager: get/relesae test 1" "core;quick;full")
 		condor_pl_test(lib_lease_manager-get_rel_2 "Lease manager: get/relesae test 2" "core;quick;full")
 		condor_pl_test(lib_lease_manager-get_rel_3 "Lease manager: get/relesae test 3" "core;quick;full")
 		condor_pl_test(lib_lease_manager-get_rel_4 "Lease manager: get/relesae test 4" "core;quick;full")
 		condor_pl_test(lib_lease_manager-get_rel_5 "Lease manager: get/relesae test 5" "core;quick;full")
-	endif(WANT_LEASE_MANAGER)
+	endif(WANT_LEASE_MANAGER_EXTRA_TESTS)
 
 	if (STD_UNIVERSE)
 		# C-Tests
@@ -206,6 +211,7 @@ if (BUILD_TESTS)
 		condor_pl_test(job_ckpt_io-async_std "file I/O during async ckpt signals" "stduniv;quick;full;ckpt")
 		condor_pl_test(job_ckpt_io-buffer-async_std "file buffing during async ckpt/restore" "stduniv;quick;full;ckpt")
 		condor_pl_test(job_ckpt_stack_std "ckpt/restore function call stack" "stduniv;framework;quick;full;ckpt")
+		condor_pl_test(job_ckpt_standalone_std "standalone ckpt/restore function call stack" "stduniv;framework;quick;full;ckpt")
 		condor_pl_test(job_ckpt_floats_std "ckpt/restore floating point registers" "stduniv;framework;quick;full;ckpt")
 		condor_pl_test(job_ckpt_floats-async_std "checks floating point ops with async ckpts" "stduniv;framework;quick;full;ckpt")
 		condor_pl_test(job_ckpt_integers_std "ckpt/restore integer registers" "stduniv;framework;quick;full;ckpt")
@@ -318,12 +324,16 @@ if (BUILD_TESTS)
 	#condor_pl_test(job_stork_file-file "Basic stork Test" "core;quick;full;quicknolink")
 	#condor_pl_test(job_dagman_stork_file-file "Basic stork dag Test" "core;dagman;quick;full;quicknolink")
 	#condor_pl_test(job_dagman_stork-remove "Basic stork dag w/remove Test" "core;dagman;quick;full;quicknolink")
-	condor_pl_test(job_core_err_java "Java Universe: basic error test" "core;quick;full;quicknolink;java")
-	condor_pl_test(job_core_output_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
-	condor_pl_test(job_core_hold_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
-	condor_pl_test(job_core_initialdir_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
-	condor_pl_test(job_core_input_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
-	#condor_pl_test(job_core_plus_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+
+    if ( ENABLE_JAVA_TESTS )
+		condor_pl_test(job_core_err_java "Java Universe: basic error test" "core;quick;full;quicknolink;java")
+		condor_pl_test(job_core_output_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+		condor_pl_test(job_core_hold_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+		condor_pl_test(job_core_initialdir_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+		condor_pl_test(job_core_input_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+		#condor_pl_test(job_core_plus_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+    endif ( ENABLE_JAVA_TESTS )
+
 	condor_pl_test(job_filexfer_streamout_van "Vanilla: test for streaming of output when both stream_output is true and false" "core;quick;full;quicknolink")
 	condor_pl_test(job_filexfer_streamerr_van "Vanilla: test for streaming of error when both stream_error is true and false" "core;quick;full;quicknolink")
 	#if !defined( IS_ALPHA_LINUX) && !defined(IS_HPUX10) && !defined(IS_HPUX11) && !defined(IS_IA64_LINUX_RHEL3) 
diff --git a/src/condor_tests/job_ckpt_standalone_std.c b/src/condor_tests/job_ckpt_standalone_std.c
new file mode 100644
index 0000000..4c6a834
--- /dev/null
+++ b/src/condor_tests/job_ckpt_standalone_std.c
@@ -0,0 +1,252 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* This program was originally the job_ckpt_stack_std.c test program.
+	It was repurposed and extended to test standalone checkpointing.
+*/
+
+/* This program analyzes the stack at run time to see if it is ok(i.e.
+	checkpointed and restored at the right boundaries). It does
+	this by calling a recursive function which allocates some
+	memory on the stack, fills it with a known value, checks to see
+	if the previous values were all correct, and then recurses to
+	do the process over again. It continues until it accumulates a
+	target size of the runtime stack(counting only the memory it
+	allocates on the stack). During these calls, it checkpoints and
+	restarts all the way checking the integrity of the run time
+	stack. In fact, when the recursion finishes, it back checks the
+	runtime stack for each frame it falls backwards. */
+
+/* XXX Right now this program only checkpoints at the deepest level and
+	then backchecks all the way. It should checkpoint more often to make
+	sure everything is being saved/restored correctly, but it eats up
+	far too much time to do it ever stack level. I need to fix it so it 
+	does it evey N stack pushes/pops. */
+
+/* This might need adjustment per OS revision */
+#define STACKSIZETARGET (1024*384) /* 384K run time stack */
+
+#define STACKINCREMENT 1024 /* bytes per allocated stack array */
+#define FALSE 0
+#define TRUE 1
+
+#include "x_fake_ckpt.h"
+
+/* This represents an activation record on the run time stack. In fact, this
+	is kept on the runtime stack along with the data it points to to really
+	make this test depend on a working stack. */
+struct Frame
+{
+	/* This represents the number stored in the array */
+	int value;
+	/* This points to a stack allocated array */
+	int *data;
+	/* This size of the stack allocates array */
+	int size;
+	/* This is null at the root of the activation records */
+	struct Frame *previous;
+};
+
+void init_data(int *data, int size, int value);
+int deepen(struct Frame *pf, int old_value);
+int is_stack_valid(struct Frame *f, int value);
+int data_valid(int *data, int size, int value);
+
+/* size of the runtime stack at various intervals */
+int g_sum = 0;
+
+/* pointer to heap allocated just before checkpoint */
+int *g_heap1 = NULL;
+/* pointer to heap allocated just after checkpoint */
+int *g_heap2 = NULL;
+int g_heap_size = (1024 * 1024 * 1); /* actually 4 Megs cause an int type */
+
+int main(void)
+{
+	/* Need to start this process as close to the start of main() as I can */
+	int data[STACKINCREMENT];
+	struct Frame f;
+	int validity;
+	int a, b, c;
+
+	init_data(data, STACKINCREMENT, 0);
+	/* the stopping condition for is_stack_valid()'s search through the
+		previous pointers. It stops when f.value is zero and the data
+		array associated with it is zero. Otherwise during the recursion value
+		increases by one for each deeper stack frame */
+	f.value = 0; 
+	f.data = &data[0];
+	f.size = STACKINCREMENT;
+	f.previous = NULL;
+	g_sum += STACKINCREMENT; /* record the fact I added to the stack */
+
+	a = is_stack_valid(&f, 0);
+	printf("Deepness Level: %d\n", 0);
+	b = deepen(&f, 0);
+	printf("Backchecking %d\n", 0), 
+	c = is_stack_valid(&f, 0);
+	validity = a && b && c;
+	if (validity == FALSE) {
+		printf("Stack failure.\n");
+		printf("FAILED\n");
+		exit(EXIT_FAILURE);
+	}
+
+	printf("Checking allocated memory heaps.\n");
+	if (data_valid(g_heap1, g_heap_size, 0xdeadbeef) == FALSE) {
+		printf("Memory heap 1 failure.\n");
+		printf("FAILED\n");
+		exit(EXIT_FAILURE);
+	}
+	if (data_valid(g_heap2, g_heap_size, 0xbeefdead) == FALSE) {
+		printf("Memory heap 2 failure.\n");
+		printf("FAILED\n");
+		exit(EXIT_FAILURE);
+	}
+
+	free(g_heap1);
+	g_heap1 = NULL;
+	free(g_heap2);
+	g_heap2 = NULL;
+
+	printf("SUCCESS\n");
+	exit(EXIT_SUCCESS);
+}
+
+/* fill the data array with a known value */
+void init_data(int *data, int size, int value)
+{
+	int i;
+	
+	for (i = 0; i < size; i++)
+	{
+		data[i] = value;
+	}
+}
+
+/* keep recursing down until I use up the amount of run time stack space I've
+	been allocated */
+int deepen(struct Frame *pf, int old_value)
+{
+	int test;
+	int data[STACKINCREMENT];
+	struct Frame f;
+	int new_value = old_value + 1;
+	int a, b;
+
+	printf("Deepness Level: %d\n", new_value);
+	init_data(data, STACKINCREMENT, new_value);
+	f.value = new_value;
+	f.data = &data[0];
+	f.size = STACKINCREMENT;
+	f.previous = pf;
+	g_sum += STACKINCREMENT; /* record the fact I added to the stack */
+
+	test = is_stack_valid(&f, new_value);
+
+	if (test == TRUE)
+	{
+		if (g_sum < STACKSIZETARGET)
+		{
+			/* recurse deeper and backcheck the results */
+				a = deepen(&f, new_value);
+				printf("Backchecking %d\n", new_value), 
+				b = is_stack_valid(&f, new_value);
+
+				return a && b;
+		}
+
+		/* allocate a chunk of memory that better be good when I come back from
+			the checkpoint */
+		g_heap1 = malloc(sizeof(int) * g_heap_size);
+		if (g_heap1 == NULL) {
+			printf("Out of memory while allocating heap1! Exiting.\n");
+			exit(EXIT_FAILURE);
+		}
+		init_data(g_heap1, g_heap_size, 0xdeadbeef);
+
+		/* save the big run time stack in a checkpoint */
+		printf("About to checkpoint....\n");
+		fflush(NULL);
+		ckpt_and_exit();
+		fflush(NULL);
+
+		printf("Returning from checkpoint....\n");
+
+		/* This *should* be true because we just checked it earlier, however
+			if it is not, we'll catch the error here. */
+		test = is_stack_valid(&f, new_value);
+
+		/* allocate another chunk of memory that better be good when I come
+			back from the checkpoint */
+		g_heap2 = malloc(sizeof(int) * g_heap_size);
+		if (g_heap2 == NULL) {
+			printf("Out of memory while allocating heap2! Exiting.\n");
+			exit(EXIT_FAILURE);
+		}
+		init_data(g_heap2, g_heap_size, 0xbeefdead);
+
+		return test;
+	}
+
+	return FALSE;
+}
+
+/* check to see of the stack frame and all previous ones are correct given
+	a decrementing value for each previous stack frame */
+int is_stack_valid(struct Frame *f, int value)
+{
+	int check;
+
+	check = data_valid(f->data, f->size, value);
+
+	if (value == 0)
+	{
+		if (check == TRUE)
+		{
+			return TRUE;
+		}
+		return FALSE;
+	}
+
+	/* check until the value is zero */
+	return is_stack_valid(f->previous, value - 1);
+}
+
+
+/* Check the data with a known value */
+int data_valid(int *data, int size, int value)
+{
+	int i;
+	
+	for (i = 0; i < size; i++)
+	{
+		if (data[i] != value)
+		{
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+
diff --git a/src/condor_tests/job_ckpt_standalone_std.run b/src/condor_tests/job_ckpt_standalone_std.run
new file mode 100755
index 0000000..94fad66
--- /dev/null
+++ b/src/condor_tests/job_ckpt_standalone_std.run
@@ -0,0 +1,131 @@
+#!/usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+# This program runs a standalone checkpointing job and ensures that it
+# both checkpointed and resumed correctly.
+
+use CondorUtils;
+use strict;
+use warnings;
+
+my $testdesc =  'Standalone Checkpointing Stack Test';
+my $testname = "job_ckpt_standalone_std.cndr.exe";
+my $ckptfile = "job_ckpt_standalone_std.cndr.exe.ckpt.$$";
+my $ret;
+my $last;
+
+# I need to do a little work to figure out the right arguments to pass to
+# setarch.
+my $pers = `uname -m`;
+my $pers_fix;
+my $pers_token;
+
+# We need to have the right base personality to run the stduniv program
+if ($pers =~ m/i\d86/) {
+	$pers_token = "i386";
+} else {
+	$pers_token = "x86_64";
+}
+
+# Now, we need to see if we're using a setarch that accepts the pile of
+# arguments we need, or an old crusty one which doesn't take any arguments.
+# This is a heuristic. We'll assume the most modern interface first.
+$pers_fix = "setarch $pers_token -L -B -R";
+
+# Sadly setarch just fails with no output and return value 1 when it can't
+# accept command line arguments it doesn't understand. So we test it with
+# something we KNOW to return true and if this fails, setarch is borken.
+$ret = system("$pers_fix /bin/true");
+
+if ($ret == -1 || $ret & 127) {
+	print "ERROR: Something went very wrong trying to figure out setarch.\n";
+	exit 1;
+}
+if (($ret >> 8) != 0) {
+	# use old style setarch instead
+	$pers_fix = "setarch $pers_token";
+}
+
+# Now that we're done with setarch detection, get to the test itself.
+
+print "Description: $testdesc\n";
+print "Running: $testname\n";
+
+# run the test, which will self checkpoint itself.
+
+# The program better exit with SIGUSR2!
+print "Starting standalone checkpointing test. Will checkpoint to $ckptfile.\n";
+$ret = runcmd("$pers_fix ./$testname -_condor_aggravate_bugs -_condor_D_CKPT " .
+			"-_condor_D_FULLDEBUG -_condor_D_ALWAYS " .
+			"-_condor_ckpt ./$ckptfile",
+		{expect_result => SIGNAL(12)});
+
+# Check the stderr, which contains the checkpoint debug output.
+$last = pop @{$ret->{'stderr'}};
+chomp $last;
+if ($last !~ m/Ckpt exit/) {
+	print "ERROR: The last line of the checkpointing job's stderr should " .
+		"have been 'Ckpt exit', but it wasn't! Fail.\n";
+	print "FAILURE\n";
+	exit 1;
+}
+
+# Check the stdout, which contains "About to checkpoint...."
+$last = pop @{$ret->{'stdout'}};
+chomp $last;
+if ($last !~ m/About to checkpoint\.\.\.\./) {
+	print "ERROR: The last line of the checkpointing job's stdout should " .
+		"have been 'About to checkpoint....', but it wasn't! Fail.\n";
+	print "FAILURE\n";
+	exit 1;
+}
+
+# The resuming program better exit with 0!
+print "Resuming standalone checkpointing test. Will resume from $ckptfile.\n";
+$ret = runcmd("$pers_fix ./$testname -_condor_aggravate_bugs -_condor_D_CKPT " .
+			"-_condor_D_FULLDEBUG -_condor_D_ALWAYS " .
+			"-_condor_restart ./$ckptfile");
+
+# Check the stderr, which contains the resumed job debug output.
+$last = pop @{$ret->{'stderr'}};
+chomp $last;
+if ($last !~ m/About to return to user code/) {
+	print "ERROR: The last line of the resuming job's stderr should have " .
+		"been 'About to return to user code', but it wasn't! Fail.\n";
+	print "FAILURE\n";
+	exit 1;
+}
+
+# Process the stdout which contains the output of the resumed job.
+$last = pop @{$ret->{'stdout'}};
+chomp $last;
+if ($last !~ m/SUCCESS/) {
+	print "ERROR: The last line of the resuming job should have " .
+		"been 'SUCCESS', but it wasn't!. Fail.\n";
+	print "FAILURE\n";
+	exit 1;
+}
+
+print "SUCCESS\n";
+
+exit 0;
+
+
+
diff --git a/src/condor_tools/config_val.cpp b/src/condor_tools/config_val.cpp
index 92ee0ee..09b84ee 100644
--- a/src/condor_tools/config_val.cpp
+++ b/src/condor_tools/config_val.cpp
@@ -398,6 +398,12 @@ main( int argc, char* argv[] )
 				while (collectors->next (collector)) {
 					if (collector->locate() &&
 					    sock.connect((char*) collector->addr(), 0)) {
+						// Do something with the connection, 
+						// such that we won't end up with 
+						// noise in the collector log
+						collector->startCommand( DC_NOP, &sock, 30 );
+						sock.encode();
+						sock.end_of_message();
 						// If we can connect to the
 						// collector, then we accept
 						// it as valid
diff --git a/src/condor_unit_tests/OTEST_Directory.cpp b/src/condor_unit_tests/OTEST_Directory.cpp
index eaab0ad..3843bad 100644
--- a/src/condor_unit_tests/OTEST_Directory.cpp
+++ b/src/condor_unit_tests/OTEST_Directory.cpp
@@ -167,8 +167,6 @@ static MyString
 static const char
 	*readme = "README";
 
-static time_t current_time;
-
 bool OTEST_Directory(void) {
 	emit_object("Directory");
 	emit_comment("Class to iterate filenames in a subdirectory.  Given a "
@@ -417,10 +415,6 @@ static void setup() {
 
 	// Close FILE* that was written to
 	cut_assert_z( fclose(file_1) );
-	
-	// Get the current time
-	current_time = time(NULL);
-
 }
 
 static void cleanup() {
@@ -1082,10 +1076,10 @@ static bool test_get_access_time_before() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	Directory dir(original_dir.Value());
-	time_t ret_val = dir.GetAccessTime();
+	time_t atime = dir.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", atime);
+	if(atime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1101,10 +1095,10 @@ static bool test_get_access_time_empty() {
 	emit_retval("%d", 0);
 	Directory dir(empty_dir.Value());
 	dir.Next();
-	time_t ret_val = dir.GetAccessTime();
+	time_t atime = dir.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", atime);
+	if(atime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1118,28 +1112,33 @@ static bool test_get_access_time_valid() {
 	Directory dir(original_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetAccessTime();
+	time_t atime = dir.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val == 0) {
+	emit_retval("%d", atime);
+	if(atime == 0) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_close() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a file that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a "
+		"file that was just created.");
 	emit_input_header();
 	emit_param("Directory", "%s", tmp_dir.Value());
 	Directory dir(tmp_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetAccessTime();
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, next);
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
+	time_t atime = dir.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - ret_val) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
@@ -1153,10 +1152,10 @@ static bool test_get_modify_time_before() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	Directory dir(original_dir.Value());
-	time_t ret_val = dir.GetModifyTime();
+	time_t mtime = dir.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", mtime);
+	if(mtime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1172,10 +1171,10 @@ static bool test_get_modify_time_empty() {
 	emit_retval("%d", 0);
 	Directory dir(empty_dir.Value());
 	dir.Next();
-	time_t ret_val = dir.GetModifyTime();
+	time_t mtime = dir.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", mtime);
+	if(mtime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1189,10 +1188,10 @@ static bool test_get_modify_time_valid() {
 	Directory dir(original_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetModifyTime();
+	time_t mtime = dir.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val == 0) {
+	emit_retval("%d", mtime);
+	if(mtime == 0) {
 		FAIL;
 	}
 	PASS;
@@ -1206,11 +1205,16 @@ static bool test_get_modify_time_close() {
 	Directory dir(tmp_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetModifyTime();
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, next);
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
+	time_t mtime = dir.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - ret_val) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
@@ -1224,10 +1228,10 @@ static bool test_get_create_time_before() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	Directory dir(original_dir.Value());
-	time_t ret_val = dir.GetCreateTime();
+	time_t ctime = dir.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", ctime);
+	if(ctime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1243,10 +1247,10 @@ static bool test_get_create_time_empty() {
 	emit_retval("%d", 0);
 	Directory dir(empty_dir.Value());
 	dir.Next();
-	time_t ret_val = dir.GetCreateTime();
+	time_t ctime = dir.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", ctime);
+	if(ctime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1260,10 +1264,10 @@ static bool test_get_create_time_valid() {
 	Directory dir(original_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetCreateTime();
+	time_t ctime = dir.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val == 0) {
+	emit_retval("%d", ctime);
+	if(ctime == 0) {
 		FAIL;
 	}
 	PASS;
@@ -1277,11 +1281,16 @@ static bool test_get_create_time_close() {
 	Directory dir(tmp_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetCreateTime();
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, next);
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
+	time_t ctime = dir.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - ret_val) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
diff --git a/src/condor_unit_tests/OTEST_StatInfo.cpp b/src/condor_unit_tests/OTEST_StatInfo.cpp
index 7f62e3a..5052829 100644
--- a/src/condor_unit_tests/OTEST_StatInfo.cpp
+++ b/src/condor_unit_tests/OTEST_StatInfo.cpp
@@ -133,8 +133,6 @@ static MyString
 static const char
 	*readme = "README";
 
-static time_t current_time;
-
 static int fd;
 
 bool OTEST_StatInfo(void) {
@@ -254,18 +252,18 @@ bool OTEST_StatInfo(void) {
 static void setup() {
 	int tmp_fd;
 
-	//Get the current working directory
+	// Get the current working directory
 	cut_assert_true( condor_getcwd(original_dir) );
 	original_dir += DIR_DELIM_CHAR;
 	
-	//Directory strings
+	// Directory strings
 	cut_assert_true( tmp.sprintf("testtmp%d", getpid()) );
 	
-	//Make a temporary directory to test
+	// Make a temporary directory to test
 	cut_assert_z( mkdir(tmp.Value(), 0700) );
 	cut_assert_z( chdir(tmp.Value()) );
 	
-	//Store some directories
+	// Store some directories
 	cut_assert_true( condor_getcwd(tmp_dir) );
 	tmp_dir += DIR_DELIM_CHAR;
 	cut_assert_true( empty_dir.sprintf("%s%s%c", tmp_dir.Value(), "empty_dir",
@@ -277,11 +275,11 @@ static void setup() {
 	cut_assert_true( file_dir.sprintf("%s%s%c", full_dir.Value(), "full_file",
 					 DIR_DELIM_CHAR) );
 	
-	//Put some files/directories in there
+	// Put some files/directories in there
 	cut_assert_z( mkdir("empty_dir", 0700) );
 	cut_assert_z( mkdir("full_dir", 0700) );
 	
-	//Create some symbolic links
+	// Create some symbolic links
 #ifndef WIN32
 	MyString link;
 	cut_assert_true( link.sprintf("%s%s", full_dir.Value(), "full_file") );
@@ -301,24 +299,21 @@ static void setup() {
 	cut_assert_z( mkdir("link_dir", 0700) );
 	fd = cut_assert_gez( safe_open_wrapper("empty_file", O_RDWR | O_CREAT) );
 
-	//Add some text
+	// Add some text
 	FILE* file_1 = safe_fopen_wrapper("full_file", "w+");
 	cut_assert_not_null( file_1 );
 	cut_assert_gz( fprintf(file_1, "This is some text!") );
 	cut_assert_z( chdir("..") );
 	
-	//Get back to original directory
+	// Get back to original directory
 	cut_assert_z( chdir("..") );
 
-	//Close FILE* that were written to
+	// Close FILE* that were written to
 	cut_assert_z( fclose(file_1) );
-	
-	//Get the current time
-	current_time = time(NULL);
 }
 
 static void cleanup() {
-	//Remove the created files/directories/symlinks
+	// Remove the created files/directories/symlinks
 	cut_assert_z( chdir(tmp.Value()) );
 	cut_assert_z( rmdir("empty_dir") );
 	cut_assert_z( remove("symlink_file") );
@@ -326,7 +321,7 @@ static void cleanup() {
 	cut_assert_z( chdir("full_dir") );
 	cut_assert_z( rmdir("link_dir") );
 	
-	//Just in case any of these weren't removed...
+	// Just in case any of these weren't removed...
 	remove("empty_file");
 	remove("full_file");
 	remove("executable_file");
@@ -863,27 +858,32 @@ static bool test_get_access_time_not_exist() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	StatInfo info("DoesNotExist", "DoesNotExist");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != 0) {
+	emit_retval("%d", atime);
+	if(atime != 0) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_file() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a file that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a "
+		"file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", full_dir.Value());
 	emit_param("File Name", "empty_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", full_dir.Value(), DIR_DELIM_CHAR, "empty_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
 	StatInfo info(full_dir.Value(), "empty_file");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
@@ -902,61 +902,76 @@ static bool test_get_access_time_file_old() {
 	emit_output_expected_header();
 	emit_retval("%d", st.st_atime);
 	StatInfo info(original_dir.Value(), readme);
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != st.st_atime) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_dir() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a directory that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a"
+		" directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "full_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "full_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
 	StatInfo info(tmp_dir.Value(), "full_dir");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_symlink_file() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a symlink to a file that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a "
+		"symlink to a file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
 	StatInfo info(tmp_dir.Value(), "symlink_file");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_symlink_dir() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a symlink to a directory that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a "
+		"symlink to a directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
 	StatInfo info(tmp_dir.Value(), "symlink_dir");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
@@ -971,27 +986,32 @@ static bool test_get_modify_time_not_exist() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	StatInfo info("DoesNotExist", "DoesNotExist");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != 0) {
+	emit_retval("%d", mtime);
+	if(mtime != 0) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_modify_time_file() {
-	emit_test("Test that GetModifyTime() returns a time close to the current "
-		"time for a file that was just created.");
+	emit_test("Test that GetModifyTime() returns the same time as stat() for a "
+		"file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", full_dir.Value());
 	emit_param("File Name", "empty_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", full_dir.Value(), DIR_DELIM_CHAR, "empty_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
 	StatInfo info(full_dir.Value(), "empty_file");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
@@ -1010,61 +1030,76 @@ static bool test_get_modify_time_file_old() {
 	emit_output_expected_header();
 	emit_retval("%d", st.st_mtime);
 	StatInfo info(original_dir.Value(), readme);
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != st.st_mtime) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_modify_time_dir() {
-	emit_test("Test that GetModifyTime() returns a time close to the current "
-		"time for a directory that was just created.");
+	emit_test("Test that GetModifyTime() returns the same time as stat() for a "
+		"directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "full_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "full_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
 	StatInfo info(tmp_dir.Value(), "full_dir");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_modify_time_symlink_file() {
-	emit_test("Test that GetModifyTime() returns a time close to the current "
-		"time for a symlink to a file that was just created.");
+	emit_test("Test that GetModifyTime() returns the same time as stat() for a "
+		"symlink to a file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
 	StatInfo info(tmp_dir.Value(), "symlink_file");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_modify_time_symlink_dir() {
-	emit_test("Test that GetModifyTime() returns a time close to the current "
-		"time for a symlink to a directory that was just created.");
+	emit_test("Test that GetModifyTime() returns the same time as stat() for a "
+		"symlink to a directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
 	StatInfo info(tmp_dir.Value(), "symlink_dir");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
@@ -1079,27 +1114,32 @@ static bool test_get_create_time_not_exist() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	StatInfo info("DoesNotExist", "DoesNotExist");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != 0) {
+	emit_retval("%d", ctime);
+	if(ctime != 0) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_create_time_file() {
-	emit_test("Test that GetCreateTime() returns a time close to the current "
-		"time for a file that was just created.");
+	emit_test("Test that GetCreateTime() returns the same time as stat() for a "
+		"file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", full_dir.Value());
 	emit_param("File Name", "empty_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", full_dir.Value(), DIR_DELIM_CHAR, "empty_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
 	StatInfo info(full_dir.Value(), "empty_file");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
@@ -1118,61 +1158,76 @@ static bool test_get_create_time_file_old() {
 	emit_output_expected_header();
 	emit_retval("%d", st.st_ctime);
 	StatInfo info(original_dir.Value(), readme);
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != st.st_ctime) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_create_time_dir() {
-	emit_test("Test that GetCreateTime() returns a time close to the current "
-		"time for a directory that was just created.");
+	emit_test("Test that GetCreateTime() returns the same time as stat() for a "
+		"directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "full_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "full_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
 	StatInfo info(tmp_dir.Value(), "full_dir");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_create_time_symlink_file() {
-	emit_test("Test that GetCreateTime() returns a time close to the current "
-		"time for a symlink to a file that was just created.");
+	emit_test("Test that GetCreateTime() returns the same time as stat() for a "
+		"symlink to a file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
 	StatInfo info(tmp_dir.Value(), "symlink_file");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_create_time_symlink_dir() {
-	emit_test("Test that GetCreateTime() returns a time close to the current "
-		"time for a symlink to a directory that was just created.");
+	emit_test("Test that GetCreateTime() returns the same time as stat() for a "
+		"symlink to a directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
 	StatInfo info(tmp_dir.Value(), "symlink_dir");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
diff --git a/src/condor_unit_tests/emit.cpp b/src/condor_unit_tests/emit.cpp
index c79c0a2..9e6559e 100644
--- a/src/condor_unit_tests/emit.cpp
+++ b/src/condor_unit_tests/emit.cpp
@@ -55,6 +55,7 @@ void Emitter::init(bool failures_printed, bool successes_printed) {
 	set_debug_flags("D_ALWAYS");
 	set_debug_flags("D_NOHEADER");
 	config();
+	global_start = time(0);
 }
 
 /* Formats and prints a parameter and its value as a sub-point of input,
@@ -78,7 +79,9 @@ void Emitter::emit_retval(const char* format, va_list args) {
 /* Emits a heading and the function string.
  */
 void Emitter::emit_function(const char* function) {
-	test_buf->sprintf("---------------------\nFUNCTION:  %s\n", function);
+	test_buf->sprintf("\n\n------------------------------------------------------"
+		"--------------------------\nFUNCTION:  %s\n---------------------------"
+		"-----------------------------------------------------\n", function);
 	if(print_failures && print_successes) {
 		dprintf(D_ALWAYS, "%s", test_buf->Value());
 		test_buf->setChar(0, '\0');
@@ -88,7 +91,9 @@ void Emitter::emit_function(const char* function) {
 /* Emits a heading and the object string.
  */
 void Emitter::emit_object(const char* object) {
-	test_buf->sprintf("---------------------\nOBJECT:  %s\n", object);
+	test_buf->sprintf("\n------------------------------------------------------"
+		"--------------------------\nOBJECT:  %s\n-----------------------------"
+		"---------------------------------------------------\n", object);
 	if(print_failures && print_successes) {
 		dprintf(D_ALWAYS, "%s", test_buf->Value());
 		test_buf->setChar(0, '\0');
@@ -146,7 +151,7 @@ void Emitter::emit_output_actual_header() {
  * be called via the PASS macro."
  */
 void Emitter::emit_result_success(int line) {
-	buf->sprintf_cat("RESULT:  SUCCESS, test passed at line %d (%ld seconds)\n", 
+	buf->sprintf_cat("RESULT:  SUCCESS, test passed at line %d (%ld seconds)\n",
 		line, time(0) - start);
 	print_now_if_possible();
 	if(print_successes && !print_failures) {
@@ -210,14 +215,15 @@ void Emitter::emit_test_break() {
 }
 
 void Emitter::emit_summary() {
-	dprintf(D_ALWAYS, "\n---------------------\nSUMMARY:\n");
-	dprintf(D_ALWAYS, "========\n");
+	dprintf(D_ALWAYS, "\n========\nSUMMARY:\n========\n");
 	dprintf(D_ALWAYS, "    Total Tested Objects:  %d\n", object_tests);
 	dprintf(D_ALWAYS, "    Total Unit Tests:      %d\n", function_tests);
 	dprintf(D_ALWAYS, "    Passed Unit Tests:     %d\n", passed_tests);
 	dprintf(D_ALWAYS, "    Failed Unit Tests:     %d\n", failed_tests);
 	dprintf(D_ALWAYS, "    Aborted Unit Tests:    %d\n", aborted_tests);
 	dprintf(D_ALWAYS, "    Skipped Unit Tests:    %d\n", skipped_tests);
+	dprintf(D_ALWAYS, "    Total Time Taken:      %ld seconds\n",
+			time(0) - global_start);
 }
 
 void Emitter::print_result_failure() {
diff --git a/src/condor_unit_tests/emit.h b/src/condor_unit_tests/emit.h
index 193642f..514e843 100644
--- a/src/condor_unit_tests/emit.h
+++ b/src/condor_unit_tests/emit.h
@@ -52,7 +52,7 @@ private:
 
 	MyString *buf, *test_buf;
 
-	time_t start;
+	time_t start, global_start;
 
 	void print_result_failure(void);
 	
diff --git a/src/condor_unit_tests/unit_test_utils.h b/src/condor_unit_tests/unit_test_utils.h
index 6dde910..2a3591a 100644
--- a/src/condor_unit_tests/unit_test_utils.h
+++ b/src/condor_unit_tests/unit_test_utils.h
@@ -210,4 +210,4 @@ struct timezone
 };
 
 int gettimeofday(struct timeval *tv, struct timezone *tz);
-#endif
\ No newline at end of file
+#endif
diff --git a/src/condor_utils/CMakeLists.txt b/src/condor_utils/CMakeLists.txt
index a9b6322..8e94ea9 100644
--- a/src/condor_utils/CMakeLists.txt
+++ b/src/condor_utils/CMakeLists.txt
@@ -47,7 +47,7 @@ endif()
 condor_static_lib( condorapi "${ApiSrcs}" )
 add_dependencies( condorapi utils )
 
-if (NOT WINDOWS)
+if (HAVE_LIBDL)
 	set(APILIBDEP dl)
 endif()
 
diff --git a/src/condor_utils/access_desktop.WINDOWS.cpp b/src/condor_utils/access_desktop.WINDOWS.cpp
index c192332..6b4a328 100644
--- a/src/condor_utils/access_desktop.WINDOWS.cpp
+++ b/src/condor_utils/access_desktop.WINDOWS.cpp
@@ -341,7 +341,7 @@ void RemoveSid(PSID *psid)
 BOOL AddTheAceWindowStation(HWINSTA hwinsta, PSID psid)
 {
 
-	ACCESS_ALLOWED_ACE   *pace;
+	ACCESS_ALLOWED_ACE  *pace      = NULL;
 	ACL_SIZE_INFORMATION aclSizeInfo;
 	BOOL                 bDaclExist;
 	BOOL                 bDaclPresent;
@@ -351,7 +351,7 @@ BOOL AddTheAceWindowStation(HWINSTA hwinsta, PSID psid)
 	DWORD                dwSidSize = 0;
 	DWORD                dwSdSizeNeeded;
 	PACL                 pacl;
-	PACL                 pNewAcl;
+	PACL                 pNewAcl   = NULL;
 	PSECURITY_DESCRIPTOR psd       = NULL;
 	PSECURITY_DESCRIPTOR psdNew    = NULL;
 	PVOID                pTempAce;
@@ -805,7 +805,7 @@ BOOL AddTheAceDesktop(HDESK hdesk, PSID psid)
 	DWORD                dwSidSize = 0;
 	DWORD                dwSdSizeNeeded;
 	PACL                 pacl;
-	PACL                 pNewAcl;
+	PACL                 pNewAcl   = NULL;
 	PSECURITY_DESCRIPTOR psd       = NULL;
 	PSECURITY_DESCRIPTOR psdNew    = NULL;
 	PVOID                pTempAce;
diff --git a/src/condor_utils/classad_log.cpp b/src/condor_utils/classad_log.cpp
index 90c4893..6872a63 100644
--- a/src/condor_utils/classad_log.cpp
+++ b/src/condor_utils/classad_log.cpp
@@ -28,11 +28,9 @@
 #include "util_lib_proto.h"
 #include "classad_merge.h"
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 #include "ClassAdLogPlugin.h"
 #endif
-#endif
 
 // explicitly instantiate the HashTable template
 
@@ -721,11 +719,9 @@ LogNewClassAd::Play(void *data_structure)
 	ad->SetTargetTypeName(targettype);
 	result = table->insert(HashKey(key), ad);
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 	ClassAdLogPluginManager::NewClassAd(key);
 #endif
-#endif
 
 	return result;
 }
@@ -791,11 +787,9 @@ LogDestroyClassAd::Play(void *data_structure)
 		return -1;
 	}
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 	ClassAdLogPluginManager::DestroyClassAd(key);
 #endif
-#endif
 
 	delete ad;
 	return table->remove(hkey);
@@ -841,11 +835,9 @@ LogSetAttribute::Play(void *data_structure)
 	rval = ad->AssignExpr(name, value);
 	ad->SetDirtyFlag(name, is_dirty);
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 	ClassAdLogPluginManager::SetAttribute(key, name, value);
 #endif
-#endif
 
 	return rval;
 }
@@ -940,11 +932,9 @@ LogDeleteAttribute::Play(void *data_structure)
 	if (table->lookup(HashKey(key), ad) < 0)
 		return -1;
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 	ClassAdLogPluginManager::DeleteAttribute(key, name);
 #endif
-#endif
 
 	return ad->Delete(name);
 }
diff --git a/src/condor_utils/classad_newold.cpp b/src/condor_utils/classad_newold.cpp
index 7edd7fc..4f43e1c 100644
--- a/src/condor_utils/classad_newold.cpp
+++ b/src/condor_utils/classad_newold.cpp
@@ -23,7 +23,6 @@
 #include "classad_newold.h"
 #include "condor_new_classads.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 bool new_to_old(classad::ClassAd & src, ClassAd & dst)
diff --git a/src/condor_utils/compat_classad.cpp b/src/condor_utils/compat_classad.cpp
index 203be06..c6c48e4 100644
--- a/src/condor_utils/compat_classad.cpp
+++ b/src/condor_utils/compat_classad.cpp
@@ -2172,8 +2172,19 @@ _GetReferences(classad::ExprTree *tree,
 	classad::References ext_refs_set;
 	classad::References int_refs_set;
 	classad::References::iterator set_itr;
-	GetExternalReferences(tree, ext_refs_set, true);
-	GetInternalReferences(tree, int_refs_set, true);
+
+	bool ok = true;
+	if( !GetExternalReferences(tree, ext_refs_set, true) ) {
+		ok = false;
+	}
+	if( !GetInternalReferences(tree, int_refs_set, true) ) {
+		ok = false;
+	}
+	if( !ok ) {
+		dprintf(D_FULLDEBUG,"warning: failed to get all attribute references in ClassAd (perhaps caused by circular reference).\n");
+		dPrint(D_FULLDEBUG);
+		dprintf(D_FULLDEBUG,"End of offending ad.\n");
+	}
 
 		// We first process the references and save results in
 		// final_*_refs_set.  The processing may hit duplicates that
diff --git a/src/condor_utils/config.cpp b/src/condor_utils/config.cpp
index abd4ef0..f28a70c 100644
--- a/src/condor_utils/config.cpp
+++ b/src/condor_utils/config.cpp
@@ -979,7 +979,10 @@ tryagain:
 				// the terminating pattern, this $$ match fails, try again.
 
 				char * end_marker = strstr(value, "])");
-				if( end_marker == NULL ) { goto tryagain; }
+				if( end_marker == NULL ) {
+					tvalue = value;
+					goto tryagain;
+				}
 
 				left_end = value - 2;
 				name = ++value;
diff --git a/src/condor_utils/cron_job_params.cpp b/src/condor_utils/cron_job_params.cpp
index 9e19571..1aaad8b 100644
--- a/src/condor_utils/cron_job_params.cpp
+++ b/src/condor_utils/cron_job_params.cpp
@@ -140,9 +140,9 @@ CronJobParams::Initialize( void )
 
 
 	// Parse the environment.
-	if ( !InitEnv( param_args ) ) {
+	if ( !InitEnv( param_env ) ) {
 		dprintf( D_ALWAYS,
-				 "CronJobParams: Failed to initialize arguments for job %s\n",
+				 "CronJobParams: Failed to initialize environment for job %s\n",
 				 GetName() );
 		return false;
 	}
diff --git a/src/condor_utils/directory.WINDOWS.cpp b/src/condor_utils/directory.WINDOWS.cpp
index e3e7058..6c9a54a 100644
--- a/src/condor_utils/directory.WINDOWS.cpp
+++ b/src/condor_utils/directory.WINDOWS.cpp
@@ -2300,7 +2300,7 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
         }
 
         if ( acl ) {
-             GlobalFree ( acl );
+             delete[] acl;
         }
 
     }
diff --git a/src/condor_utils/directory.cpp b/src/condor_utils/directory.cpp
index f07e538..c6b08f9 100644
--- a/src/condor_utils/directory.cpp
+++ b/src/condor_utils/directory.cpp
@@ -50,6 +50,20 @@
 	return i;
 // -----------------------------------------------
 
+DeleteFileLater::DeleteFileLater (const char * _name)
+{
+    filename = _name?strdup(_name):NULL;
+}
+
+DeleteFileLater::~DeleteFileLater ()
+{
+	if (filename) {
+        if (unlink(filename)) {  // conditional to defeat prefast warning.
+            dprintf(D_ALWAYS, "DeleteFileLater of %s failed err=%d", filename, errno);
+        }
+		free (filename);
+	}
+}
 
 
 #ifndef WIN32
@@ -616,8 +630,7 @@ Directory::setOwnerPriv( const char* path, si_error_t &err)
 			if (err == SINoFile) {
 				dprintf(D_FULLDEBUG, "Directory::setOwnerPriv() -- path %s does not exist (yet).\n", path);
 			} else {
-				dprintf( D_ALWAYS, "Directory::setOwnerPriv() -- failed to "
-					 "find owner of %s\n", path );
+				dprintf( D_ALWAYS, "Directory::setOwnerPriv() -- failed to find owner of %s\n", path );
 			}
 			return PRIV_UNKNOWN;
 		}
diff --git a/src/condor_utils/directory.h b/src/condor_utils/directory.h
index ddc46f3..8114ad2 100644
--- a/src/condor_utils/directory.h
+++ b/src/condor_utils/directory.h
@@ -255,16 +255,8 @@ private:
 // when the class instance is deleted
 class DeleteFileLater {
  public:
-	DeleteFileLater (const char * _name) {
-		filename = _name?strdup(_name):NULL;
-	}
-
-	~DeleteFileLater () {
-		if (filename) {
-			unlink(filename);
-			free (filename);
-		}
-	}
+	DeleteFileLater (const char * _name);
+	~DeleteFileLater ();
  protected:
 	char * filename;
 };
diff --git a/src/condor_utils/dprintf.cpp b/src/condor_utils/dprintf.cpp
index fa9749e..a1bc148 100644
--- a/src/condor_utils/dprintf.cpp
+++ b/src/condor_utils/dprintf.cpp
@@ -1328,6 +1328,11 @@ lock_or_mutex_file(int fd, LOCK_TYPE type, int do_block)
 	char *ptr = NULL;
 	char mutex_name[MAX_PATH];
 
+		// If we're trying to lock NUL, just return success early
+	if (strcasecmp(DebugLock, "NUL") == 0) {
+		return 0;
+	}
+
 	if ( use_kernel_mutex == FALSE ) {
 			// use a filesystem lock
 		return lock_file_plain(fd,type,do_block);
@@ -1341,10 +1346,6 @@ lock_or_mutex_file(int fd, LOCK_TYPE type, int do_block)
 		// starving to get the lock.  The Win32 mutex object,
 		// on the other hand, is FIFO --- thus starvation is avoided.
 
-		// If we're trying to lock NUL, just return success early
-	if (strcasecmp(DebugLock, "NUL") == 0) {
-		return 0;
-	}
 
 		// first, open a handle to the mutex if we haven't already
 	if ( debug_win32_mutex == NULL && DebugLock ) {
diff --git a/src/condor_utils/file_lock.cpp b/src/condor_utils/file_lock.cpp
index d2ac4ea..b2a013e 100644
--- a/src/condor_utils/file_lock.cpp
+++ b/src/condor_utils/file_lock.cpp
@@ -513,6 +513,7 @@ FileLock::obtain( LOCK_TYPE t )
 // their current position.  The lesson here is don't use fseeks and lseeks
 // interchangeably...
 	int		status = -1;
+	int saved_errno;
 
 	if ( m_use_kernel_mutex == -1 ) {
 		m_use_kernel_mutex = param_boolean_int("FILE_LOCK_VIA_MUTEX", TRUE);
@@ -538,6 +539,7 @@ FileLock::obtain( LOCK_TYPE t )
 			// This will help narrow down where the delay is coming from.
 		time_t before = time(NULL);
 		status = lock_file( m_fd, t, m_blocking );
+		saved_errno = errno;
 		time_t after = time(NULL);
 		if ( (after - before) > 5 ) {
 			dprintf( D_FULLDEBUG,
@@ -594,7 +596,7 @@ FileLock::obtain( LOCK_TYPE t )
 	}
 	if ( status != 0 ) {
 		dprintf( D_ALWAYS, "FileLock::obtain(%d) failed - errno %d (%s)\n",
-	                t, errno, strerror(errno) );
+	                t, saved_errno, strerror(saved_errno) );
 	}
 	else {
 		UtcTime	now( true );
@@ -688,8 +690,8 @@ FileLock::CreateHashName(const char *orig, bool useDefault)
 	char *temp_filename;
 	int c;
 	
-#if defined(_POSIX_PATH_MAX) && !defined(WIN32)
-	char *buffer = new char[_POSIX_PATH_MAX];
+#if defined(PATH_MAX) && !defined(WIN32)
+	char *buffer = new char[PATH_MAX];
 	temp_filename = realpath(orig, buffer);
 	if (temp_filename == NULL) {
 		temp_filename = new char[strlen(orig)+1];
diff --git a/src/condor_utils/lock_file.unix.cpp b/src/condor_utils/lock_file.unix.cpp
index e38291a..d2c7b4a 100644
--- a/src/condor_utils/lock_file.unix.cpp
+++ b/src/condor_utils/lock_file.unix.cpp
@@ -21,6 +21,16 @@
 #include "condor_config.h"
 #include "condor_debug.h"
 #include "file_lock.h"
+#include "condor_random_num.h"
+
+/* Declare some static variables here that are initialized by lock_file() and
+ * used by lock_file_plain(). We do this song and dance because we want to 
+ * initialize these variables by invoking various Condor library functions,
+ * like our randomization functions, and invoking those functions from
+ * lock_file_plain() is not permitted due to deadlock and/or threading reasons
+ */
+static unsigned int _lock_file_usleep_time = 0;
+static unsigned int _lock_file_num_retries = 0;
 
 /*
   Lock a file. This version is used for all unices. The windows version
@@ -35,6 +45,8 @@ lock_file_plain( int fd, LOCK_TYPE type, int do_block )
 {
 	struct flock	f;
 	int				cmd;
+	int rc, saved_errno;
+	unsigned int num_retries = 0;
 
 	if( do_block ) {
 		cmd = F_SETLKW;		/* blocking */
@@ -64,33 +76,95 @@ lock_file_plain( int fd, LOCK_TYPE type, int do_block )
 		return -1;
 	}
 
-		/* be signal safe */
-	while( fcntl(fd,cmd,&f) < 0 ) {
-		switch (errno) {
+		/* Call fcntl */
+	rc =  fcntl(fd,cmd,&f);
+	saved_errno = errno;
+
+		/* Deal with EINTR by retrying if in non-blocking mode */
+	while ( !do_block && rc < 0  && saved_errno == EINTR ) 
+	{
+		rc =  fcntl(fd,cmd,&f);
+		saved_errno = errno;
+	}
+
+		/* Deal w/ temporary errors by retrying if in blocking mode */
+	while ( do_block && rc < 0 && num_retries < _lock_file_num_retries ) 
+	{
+		struct timeval timer;
+		timer.tv_sec = 0;
+		timer.tv_usec = _lock_file_usleep_time;
+		switch (saved_errno) {
+				// for these errors, just retry the system call 
+				// immediately, don't increment number of retries.
 			case EINTR:
-				// this just means we were interrupted, not
-				// necessarily that we failed.
 				break;
+
+				// for these errors, retry the system call a limited
+				// number of times, and after waiting a 
+				// fraction of a second.
+			case ENOLCK:
+			case EACCES:
+			case EAGAIN:
+				num_retries++;
+				// do a platform independent usleep via select()
+				select(0,NULL,NULL,NULL,&timer);
+				break;
+
+				// anything else is not an errno indicative
+				// of a temporary condition, so break out of the 
+				// while loop.
 			default:
-				return -1;
+				num_retries = _lock_file_num_retries;
+				continue;
 		}
+		
+		rc =  fcntl(fd,cmd,&f);
+		saved_errno = errno;
+	}
+
+	if ( rc < 0 ) {
+		errno = saved_errno;
+		return -1;
+	} else {
+		return 0;
 	}
-	return 0;
 }
 
 int
 lock_file( int fd, LOCK_TYPE type, int do_block )
 {
 	int rc;
+	int saved_errno;
+	static bool initialized = false;
+
+	if ( !initialized ) {
+		initialized = true;
+		char *subsys = param("SUBSYSTEM");
+		if ( subsys && strcmp(subsys,"SCHEDD")==0 ) {
+			// If we are the schedd, retry early and often.
+			// usleep time averages to 1/20 of a second, and
+			// keep trying on average for 20 seconds.
+			_lock_file_usleep_time = get_random_uint() % 100000;
+			_lock_file_num_retries = 20 * 20;
+		} else {
+			// If we are not the schedd (eg we are the shadow), we
+			// can be less agressive. usleep an average of a second, try
+			// for 5 minutes.
+			_lock_file_usleep_time = get_random_uint() % 2000000;
+			_lock_file_num_retries = 60 * 5;
+		}
+		if (subsys) free(subsys);
+	}
 
 	rc = lock_file_plain( fd, type, do_block );
+	saved_errno = errno;
 
 	/* now, fcntl should work accross nfs.  but, due to bugs in some
 	   implementations (*cough* linux *cough*) it sometimes fails with
 	   errno 37 (ENOLCK).  if this happens we check the config to see
 	   if we should report this as an error.   -zmiller  07/15/02
 	   */
-	if ( rc == -1 && errno == ENOLCK ) {
+	if ( rc == -1 && saved_errno == ENOLCK ) {
 		char* p = param("IGNORE_NFS_LOCK_ERRORS");
 		char  val = 'N';
 
@@ -103,11 +177,20 @@ lock_file( int fd, LOCK_TYPE type, int do_block )
 				// pretend there was no error.
 			dprintf ( D_FULLDEBUG, "Ignoring error ENOLCK on fd %i\n", fd );
 			return 0;
-		} else {
-			errno = ENOLCK;
-			return rc;
 		}
 	}
 
+	if ( rc == -1 )
+	{
+		dprintf( D_ALWAYS, "lock_file returning ERROR, errno=%d (%s)\n",
+				saved_errno, strerror(saved_errno) );
+#if 0  // in v7.6.0, we cannot risk EXCEPTing, but do so in v7.7.0
+		if (saved_errno == EDEADLK || saved_errno == EFAULT) {
+			EXCEPT("lock_file failed with errno %d, should never happen!",saved_errno);
+		}
+#endif
+		errno = saved_errno;
+	}
+
 	return rc;
 }
diff --git a/src/condor_utils/param_info.in b/src/condor_utils/param_info.in
index 6a0f573..1a06e61 100644
--- a/src/condor_utils/param_info.in
+++ b/src/condor_utils/param_info.in
@@ -596,7 +596,7 @@ id=559
 
 [GSI_DAEMON_DIRECTORY]
 aliases=
-default=/etc/grid-security/
+default=
 version=0.0.0
 range=.*
 state=default
@@ -3558,7 +3558,7 @@ id=189
 
 [CREATE_CORE_FILES]
 aliases=
-default=false
+default=
 version=0.0.0
 range=.*
 state=default
@@ -9481,7 +9481,7 @@ id=555
 
 [GRIDMAP]
 aliases=
-default=$(GSI_DAEMON_DIRECTORY)/grid-mapfile
+default=
 version=0.0.0
 range=.*
 state=default
@@ -9497,7 +9497,7 @@ id=555
 
 [GSI_DAEMON_TRUSTED_CA_DIR]
 aliases=
-default=$(GSI_DAEMON_DIRECTORY)/certificates
+default=
 version=0.0.0
 range=.*
 state=default
@@ -10151,3 +10151,20 @@ usage=
 url=
 tags=
 id=601
+
+[SHADOW_RUN_UNKNOWN_USER_JOBS]
+aliases=
+default=false
+version=0.0.0
+range=.*
+state=default
+type=bool
+is_macro=false
+reconfig=false
+customization=seldom
+friendly_name=Shadow Run Unknown User Jobs
+usage=
+url=
+tags=shadow
+id=602
+
diff --git a/src/condor_utils/perm.WINDOWS.cpp b/src/condor_utils/perm.WINDOWS.cpp
index fd545ea..4dec99c 100644
--- a/src/condor_utils/perm.WINDOWS.cpp
+++ b/src/condor_utils/perm.WINDOWS.cpp
@@ -102,7 +102,7 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 		&pSD_length_needed			// address of required size of buffer
 		) ) {
 		dprintf(D_ALWAYS, "perm::GetFileSecurity(%s) failed (err=%d)\n", file_name, GetLastError());
-		delete pSD;
+		delete[] pSD;
 		return -1;
 	}
 	
@@ -114,7 +114,7 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 		&acl_defaulted					// address of flag for default disc. ACL
 		) ) {
 		dprintf(D_ALWAYS, "perm::GetSecurityDescriptorDacl failed (file=%s err=%d)\n", file_name, GetLastError());
-		delete pSD;
+		delete[] pSD;
 		return -1;
 	}
 	
@@ -134,7 +134,7 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 	// first get the number of ACEs in the ACL
 		if (! GetAclInformation( pacl,		// acl to get info from
 								acl_info,	// buffer to receive info
-								24,			// size in bytes of buffer
+								sizeof(acl_info),  // size in bytes of buffer
 								AclSizeInformation // class of info to retrieve
 								) ) {
 			dprintf(D_ALWAYS, "Perm::GetAclInformation failed with error %d\n", GetLastError() );
@@ -439,10 +439,8 @@ int perm::userInAce ( const LPVOID cur_ace, const char *account, const char *dom
 		char* builtin = getBuiltinDomainName();
 		char* nt_authority = getNTAuthorityDomainName();
 
-		
-		int success = GetComputerName( computerName, &nameLength );
-		
-		if (! success ) {
+		BOOL bSuccess = GetComputerName( computerName, &nameLength );
+		if ( ! bSuccess ) {
 			// this should never happen
 			dprintf(D_ALWAYS, "perm::GetComputerName failed: (Err: %d)", GetLastError());
 			result = -1; // failure
diff --git a/src/condor_utils/stl_string_utils.cpp b/src/condor_utils/stl_string_utils.cpp
index 230796a..237bb6d 100644
--- a/src/condor_utils/stl_string_utils.cpp
+++ b/src/condor_utils/stl_string_utils.cpp
@@ -44,7 +44,7 @@ bool operator>=(const MyString& L, const std::string& R) { return R <= L.Value()
 bool operator>=(const std::string& L, const MyString& R) { return L >= R.Value(); }
 
 
-int sprintf(std::string& s, const char* format, va_list pargs) {
+int vsprintf(std::string& s, const char* format, va_list pargs) {
     char fixbuf[STL_STRING_UTILS_FIXBUF];
     const int fixlen = sizeof(fixbuf)/sizeof(fixbuf[0]);
 	int n;
@@ -105,7 +105,7 @@ int sprintf(std::string& s, const char* format, va_list pargs) {
 int sprintf(std::string& s, const char* format, ...) {
     va_list args;
     va_start(args, format);
-    int r = sprintf(s, format, args);
+    int r = vsprintf(s, format, args);
     va_end(args);
     return r;
 }
@@ -115,7 +115,7 @@ int sprintf(MyString& s, const char* format, ...) {
     std::string t;
     va_start(args, format);
     // this gets me the sprintf-standard return value (# chars printed)
-    int r = sprintf(t, format, args);
+    int r = vsprintf(t, format, args);
     va_end(args);
     assign(s, t);
     return r;
@@ -125,7 +125,7 @@ int sprintf_cat(std::string& s, const char* format, ...) {
     va_list args;
     std::string t;
     va_start(args, format);
-    int r = sprintf(t, format, args);
+    int r = vsprintf(t, format, args);
     va_end(args);
     s += t;
     return r;
@@ -135,7 +135,7 @@ int sprintf_cat(MyString& s, const char* format, ...) {
     va_list args;
     std::string t;
     va_start(args, format);
-    int r = sprintf(t, format, args);
+    int r = vsprintf(t, format, args);
     va_end(args);
     s += t.c_str();
     return r;
diff --git a/src/condor_utils/store_cred.cpp b/src/condor_utils/store_cred.cpp
index 0bc7711..162d6ae 100644
--- a/src/condor_utils/store_cred.cpp
+++ b/src/condor_utils/store_cred.cpp
@@ -282,7 +282,7 @@ char* getStoredCredential(const char *username, const char *domain)
 		return NULL;
 	}
 
-	if ( _snprintf(pw, 511, "%S", w_pw) < 0 ) {
+	if ( _snprintf(pw, sizeof(pw), "%S", w_pw) < 0 ) {
 		return NULL;
 	}
 
@@ -922,7 +922,7 @@ read_from_keyboard(char* buf, int maxlength, bool echo) {
 	//Down convert the input into ASCII.
 	int converted = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, wbuffer, -1, buf, maxlength, NULL, NULL);
 
-	delete wbuffer;
+	delete[] wbuffer;
 #endif
 
 	return TRUE;
diff --git a/src/cream_gahp/cream_gahp_server.cpp b/src/cream_gahp/cream_gahp_server.cpp
index a09186e..b35d914 100644
--- a/src/cream_gahp/cream_gahp_server.cpp
+++ b/src/cream_gahp/cream_gahp_server.cpp
@@ -1348,7 +1348,7 @@ int thread_cream_job_status( Request **reqlist )
 			 it != reqids.end(); it++ ) {
 
 			char *msg = escape_spaces(ex.what());
-			enqueue_result( (*it) + " CREAM_Job_Start\\ Error:\\ " + msg );
+			enqueue_result( (*it) + " CREAM_Job_Status\\ Error:\\ " + msg );
 			free(msg);
 		}
 		return 1;
